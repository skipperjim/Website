/*!
 * 
 * A grunty Phaser.js game
 * 
 * @author Luke Wilde
 * @version 0.1.0
 * Copyright Luke Wilde. MIT licensed.
 * Made using Phaser Blank <https://github.com/lukewilde/phaser-blank/>
 */
!function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = "function" == typeof require && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
    return s;
}({
    "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\node_modules\\grunt-browserify\\node_modules\\browserify\\node_modules\\process\\browser.js": [ function(require, module, exports) {
        function drainQueue() {
            if (!draining) {
                draining = !0;
                for (var currentQueue, len = queue.length; len; ) {
                    currentQueue = queue, queue = [];
                    for (var i = -1; ++i < len; ) currentQueue[i]();
                    len = queue.length;
                }
                draining = !1;
            }
        }
        function noop() {}
        var process = module.exports = {}, queue = [], draining = !1;
        process.nextTick = function(fun) {
            queue.push(fun), draining || setTimeout(drainQueue, 0);
        }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
        process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, 
        process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
        process.emit = noop, process.binding = function(name) {
            throw new Error("process.binding is not supported");
        }, process.cwd = function() {
            return "/";
        }, process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        }, process.umask = function() {
            return 0;
        };
    }, {} ],
    "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\app.js": [ function(require, module, exports) {
        Phaser = require("Phaser"), properties = require("./properties"), Asteroid = require("./entities/Asteroid.js");
        var BaseGame = {
            Boot: require("./states/boot.js"),
            Preloader: require("./states/preloader.js"),
            MainMenu: require("./states/mainMenu.js"),
            Game: require("./states/game.js")
        };
        game = new Phaser.Game(properties.size.x, properties.size.y, Phaser.CANVAS, "gameContainer"), 
        game.state.add("Boot", BaseGame.Boot), game.state.add("Preloader", BaseGame.Preloader), 
        game.state.add("MainMenu", BaseGame.MainMenu), game.state.add("Game", BaseGame.Game), 
        game.state.start("Boot");
    }, {
        "./entities/Asteroid.js": "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\entities\\Asteroid.js",
        "./properties": "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\properties.js",
        "./states/boot.js": "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\states\\boot.js",
        "./states/game.js": "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\states\\game.js",
        "./states/mainMenu.js": "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\states\\mainMenu.js",
        "./states/preloader.js": "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\states\\preloader.js",
        Phaser: "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\lib\\phaser-arcade-physics.js"
    } ],
    "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\entities\\Asteroid.js": [ function(require, module, exports) {
        (function() {
            var Asteroid = (require("../properties"), function(game, x, y, size) {
                Phaser.Sprite.call(this, game, x, y, "large-asteroid_01"), this.asteroids, this.rotateSpeed = .05 + Math.random();
            });
            Asteroid.prototype = Object.create(Phaser.Sprite.prototype), Asteroid.prototype.constructor = Asteroid, 
            Asteroid.prototype.update = function() {}, Asteroid.setupAsteroidGroup = function() {
                this.asteroids = game.add.group();
                var numAsteroids = game.rnd.integerInRange(50, 100);
                this.asteroids.createMultiple(numAsteroids, "large-asteroid_01"), this.asteroids.setAll("anchor.x", .5), 
                this.asteroids.setAll("anchor.y", .5), this.asteroids.setAll("outOfBoundsKill", !0), 
                this.asteroids.setAll("checkWorldBounds", !0), this.asteroids.setAll("enableBody", !0);
                for (var i = 0; numAsteroids > i; i++) {
                    var asteroid = this.asteroids.getFirstExists(!1), randomScale = 1 + Math.random();
                    game.physics.arcade.enable(asteroid), asteroid.enableBody = !0, asteroid.body.velocity.x = game.rnd.integerInRange(10, 50), 
                    asteroid.body.velocity.y = game.rnd.integerInRange(10, 50), asteroid.acceleration = 25, 
                    asteroid.body.allowGravity = !0, asteroid.body.immovable = !1, asteroid.gravity = 0, 
                    asteroid.health = 10, asteroid.rotation = Math.random(), asteroid.body.collideWorldBounds = !1, 
                    asteroid.scale.setTo(randomScale, randomScale), asteroid.reset(game.world.randomX, game.world.randomY);
                }
            }, module.exports = Asteroid;
        }).call(this);
    }, {
        "../properties": "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\properties.js"
    } ],
    "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\entities\\Missile.js": [ function(require, module, exports) {
        (function() {
            var Missile = (require("../properties"), function(game, x, y) {
                Phaser.Sprite.call(this, game, x, y, "missile"), this.anchor.setTo(.5, .5), this.game.physics.enable(this, Phaser.Physics.ARCADE), 
                this.SPEED = 250, this.TURN_RATE = 5, this.WOBBLE_LIMIT = 15, this.WOBBLE_SPEED = 250, 
                this.SMOKE_LIFETIME = 3e3;
            });
            Missile.prototype = Object.create(Phaser.Sprite.prototype), Missile.prototype.constructor = Missile, 
            Missile.prototype.update = function() {
                var targetAngle = this.game.math.angleBetween(this.x, this.y, this.game.input.activePointer.x, this.game.input.activePointer.y);
                if (targetAngle += this.game.math.degToRad(this.wobble), this.rotation !== targetAngle) {
                    var delta = targetAngle - this.rotation;
                    delta > Math.PI && (delta -= 2 * Math.PI), delta < -Math.PI && (delta += 2 * Math.PI), 
                    delta > 0 ? this.angle += this.TURN_RATE : this.angle -= this.TURN_RATE, Math.abs(delta) < this.game.math.degToRad(this.TURN_RATE) && (this.rotation = targetAngle);
                }
                this.body.velocity.x = Math.cos(this.rotation) * this.SPEED, this.body.velocity.y = Math.sin(this.rotation) * this.SPEED;
            }, module.exports = Missile;
        }).call(this);
    }, {
        "../properties": "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\properties.js"
    } ],
    "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\properties.js": [ function(require, module, exports) {
        module.exports = {
            title: "Intension: Space",
            description: "My game using Phaser",
            port: 3017,
            liveReloadPort: 3018,
            showStats: !1,
            size: {
                x: "100",
                y: "100"
            },
            SEA_SCROLL_SPEED: 12,
            PLAYER_SPEED: 300,
            ENEMY_MIN_Y_VELOCITY: 30,
            ENEMY_MAX_Y_VELOCITY: 60,
            SHOOTER_MIN_VELOCITY: 30,
            SHOOTER_MAX_VELOCITY: 80,
            BOSS_Y_VELOCITY: 15,
            BOSS_X_VELOCITY: 200,
            BULLET_VELOCITY: 500,
            ENEMY_BULLET_VELOCITY: 150,
            POWERUP_VELOCITY: 100,
            SPAWN_ENEMY_DELAY: 1e3,
            SPAWN_SHOOTER_DELAY: 3e3,
            SHOT_DELAY: 100,
            SHOOTER_SHOT_DELAY: 2e3,
            BOSS_SHOT_DELAY: 1e3,
            ENEMY_HEALTH: 2,
            SHOOTER_HEALTH: 5,
            BOSS_HEALTH: 500,
            BULLET_DAMAGE: 1,
            CRASH_DAMAGE: 5,
            ENEMY_REWARD: 100,
            SHOOTER_REWARD: 400,
            BOSS_REWARD: 1e4,
            POWERUP_REWARD: 100,
            ENEMY_DROP_RATE: .3,
            SHOOTER_DROP_RATE: .5,
            BOSS_DROP_RATE: 0,
            PLAYER_EXTRA_LIVES: 3,
            PLAYER_GHOST_TIME: 3e3,
            INSTRUCTION_EXPIRE: 1e4,
            RETURN_MESSAGE_DELAY: 2e3
        };
    }, {} ],
    "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\states\\boot.js": [ function(require, module, exports) {
        (function() {
            var Stats = require("Stats"), Boot = (require("../properties"), function(game) {});
            Boot.prototype = {
                preload: function() {
                    this.load.image("preloaderBar", "images/preloader-bar.png#grunt-cache-bust");
                },
                create: function() {
                    this.input.maxPointers = 1, this.game.device.desktop || (this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL, 
                    this.scale.setMinMax(480, 260, 1024, 768), this.scale.forceLandscape = !0), this.scale.pageAlignHorizontally = !0, 
                    this.scale.pageAlignVertically = !0, this.scale.setScreenSize(!0), this.addStats(), 
                    this.state.start("Preloader");
                },
                addStats: function() {
                    var stats = new Stats();
                    stats.setMode(0), stats.domElement.style.position = "absolute", stats.domElement.style.left = "0px", 
                    stats.domElement.style.top = "0px", document.body.appendChild(stats.domElement), 
                    setInterval(function() {
                        stats.begin(), stats.end();
                    }, 1e3 / 60);
                }
            }, module.exports = Boot;
        }).call(this);
    }, {
        "../properties": "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\properties.js",
        Stats: "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\lib\\stats.min.js"
    } ],
    "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\states\\game.js": [ function(require, module, exports) {
        (function() {
            var Missile = (require("Stats"), require("../properties"), require("../entities/Missile")), Asteroid = require("../entities/Asteroid"), Game = function(game) {};
            Game.prototype = {
                create: function() {
                    this.game.renderer.clearBeforeRender = !1, this.game.renderer.roundPixels = !0, 
                    this.game.physics.startSystem(Phaser.Physics.ARCADE), this.game.world.setBounds(0, 0, 1920, 1324), 
                    this.setupBackground(), this.setupPlayer(), this.setupTrail(), this.setupAsteroids(), 
                    this.setupEnemies(), this.setupMissiles(), this.setupBullets(), this.setupExplosions(), 
                    this.setupPlayerIcons(), this.setupText(), this.cursors = this.input.keyboard.createCursorKeys(), 
                    this.game.input.keyboard.addKeyCapture([ Phaser.Keyboard.W ]), this.game.input.keyboard.addKeyCapture([ Phaser.Keyboard.A ]), 
                    this.game.input.keyboard.addKeyCapture([ Phaser.Keyboard.S ]), this.game.input.keyboard.addKeyCapture([ Phaser.Keyboard.D ]), 
                    this.game.input.keyboard.addKeyCapture([ Phaser.Keyboard.SPACEBAR ]), this.SHOT_DELAY = 100, 
                    this.BULLET_SPEED = 400, this.NUMBER_OF_BULLETS = 20, this.game.input.activePointer.x = this.game.width / 2, 
                    this.game.input.activePointer.y = this.game.height / 2;
                },
                update: function() {
                    this.checkCollisions(), this.processPlayerInput(), this.processDelayedEffects(), 
                    this.updateMissile();
                },
                updateMissile: function() {
                    0 === this.missileGroup.countLiving() && this.launchMissile(this.game.width / 2, this.game.height - 16), 
                    this.missileGroup.forEachAlive(function(m) {
                        var distance = this.game.math.distance(m.x, m.y, this.game.input.activePointer.x, this.game.input.activePointer.y);
                        25 > distance && (m.kill(), this.explode(m));
                    }, this);
                },
                setupBackground: function() {
                    this.background = this.game.add.tileSprite(0, 0, 1920, 1324, "milkyway");
                },
                setupPlayer: function() {
                    this.player = this.add.sprite(this.game.width / 2, this.game.height / 2, "player"), 
                    this.player.anchor.setTo(.5), this.physics.enable(this.player, Phaser.Physics.ARCADE), 
                    this.player.body.drag.set(50), this.player.body.maxVelocity.set(250), this.player.body.setSize(25, 25, 0, 0), 
                    this.player.body.collideWorldBounds = !0, this.weaponLevel = 0, this.acceleration = 600, 
                    this.drag = 400, this.maxSpeed = 400, this.game.camera.follow(this.player);
                },
                setupTrail: function() {
                    this.emitter = this.game.add.emitter(0, 0, 50), this.emitter.makeParticles("jets"), 
                    this.emitter.gravity = 0, this.player.addChild(this.emitter), this.emitter.y = 0, 
                    this.emitter.x = -16;
                    var px = 10 * this.player.body.velocity.x, py = 10 * this.player.body.velocity.y;
                    px *= -1, py *= -1, this.emitter.lifespan = 500, this.emitter.maxParticleSpeed = new Phaser.Point(-100, 50), 
                    this.emitter.minParticleSpeed = new Phaser.Point(-200, -50);
                },
                setupAsteroids: function() {
                    Asteroid.setupAsteroidGroup();
                },
                hitAsteroid: function(player, asteroid) {
                    console.log("nailing the asteroid");
                },
                setupEnemies: function() {
                    this.enemyPool = this.add.group(), this.enemyPool.enableBody = !0, this.enemyPool.physicsBodyType = Phaser.Physics.ARCADE, 
                    this.enemyPool.createMultiple(50, "frigate_02"), this.enemyPool.setAll("anchor.x", .5), 
                    this.enemyPool.setAll("anchor.y", .5), this.enemyPool.setAll("outOfBoundsKill", !0), 
                    this.enemyPool.setAll("checkWorldBounds", !0), this.enemyPool.setAll("reward", 100, !1, !1, 0, !0), 
                    this.enemyPool.setAll("dropRate", .2, !1, !1, 0, !0), this.enemyPool.forEach(function(enemy) {
                        enemy.animations.add("fly", [ 0, 1, 2 ], 20, !0), enemy.animations.add("hit", [ 3, 1, 3, 2 ], 20, !1), 
                        enemy.events.onAnimationComplete.add(function(e) {
                            e.play("fly");
                        }, this);
                    }), this.nextEnemyAt = 0, this.enemyDelay = Phaser.Timer.SECOND, this.shooterPool = this.add.group(), 
                    this.shooterPool.enableBody = !0, this.shooterPool.physicsBodyType = Phaser.Physics.ARCADE, 
                    this.shooterPool.createMultiple(20, "frigate_01"), this.shooterPool.setAll("anchor.x", .5), 
                    this.shooterPool.setAll("anchor.y", .5), this.shooterPool.setAll("outOfBoundsKill", !0), 
                    this.shooterPool.setAll("checkWorldBounds", !0), this.shooterPool.setAll("reward", 200, !1, !1, 0, !0), 
                    this.shooterPool.setAll("dropRate", .2, !1, !1, 0, !0), this.shooterPool.forEach(function(enemy) {
                        enemy.animations.add("fly", [ 0, 1, 2 ], 20, !0), enemy.animations.add("hit", [ 3, 1, 3, 2 ], 20, !1), 
                        enemy.events.onAnimationComplete.add(function(e) {
                            e.play("fly");
                        }, this);
                    }), this.nextShooterAt = this.time.now + 5 * Phaser.Timer.SECOND, this.shooterDelay = 3 * Phaser.Timer.SECOND, 
                    this.bossPool = this.add.group(), this.bossPool.enableBody = !0, this.bossPool.physicsBodyType = Phaser.Physics.ARCADE, 
                    this.bossPool.createMultiple(1, "boss"), this.bossPool.setAll("anchor.x", .5), this.bossPool.setAll("anchor.y", .5), 
                    this.bossPool.setAll("outOfBoundsKill", !0), this.bossPool.setAll("checkWorldBounds", !0), 
                    this.bossPool.setAll("reward", 5e3, !1, !1, 0, !0), this.bossPool.setAll("dropRate", 0, !1, !1, 0, !0), 
                    this.bossPool.forEach(function(enemy) {
                        enemy.animations.add("fly", [ 0, 1, 2 ], 20, !0), enemy.animations.add("hit", [ 3, 1, 3, 2 ], 20, !1), 
                        enemy.events.onAnimationComplete.add(function(e) {
                            e.play("fly");
                        }, this);
                    }), this.boss = this.bossPool.getTop(), this.bossApproaching = !1;
                },
                setupBullets: function() {
                    this.enemyBulletPool = this.add.group(), this.enemyBulletPool.enableBody = !0, this.enemyBulletPool.physicsBodyType = Phaser.Physics.ARCADE, 
                    this.enemyBulletPool.createMultiple(100, "enemyBullet"), this.enemyBulletPool.setAll("anchor.x", .5), 
                    this.enemyBulletPool.setAll("anchor.y", .5), this.enemyBulletPool.setAll("outOfBoundsKill", !0), 
                    this.enemyBulletPool.setAll("checkWorldBounds", !0), this.enemyBulletPool.setAll("reward", 0, !1, !1, 0, !0), 
                    this.bulletPool = this.add.group(), this.bulletPool.enableBody = !0, this.bulletPool.physicsBodyType = Phaser.Physics.ARCADE, 
                    this.bulletPool.createMultiple(100, "bullet"), this.bulletPool.setAll("anchor.x", .5), 
                    this.bulletPool.setAll("anchor.y", .5), this.bulletPool.setAll("outOfBoundsKill", !0), 
                    this.bulletPool.setAll("checkWorldBounds", !0), this.nextShotAt = 0, this.shotDelay = .1 * Phaser.Timer.SECOND;
                },
                setupMissiles: function() {
                    this.missileGroup = this.game.add.group(), 0 === this.missileGroup.countLiving() && this.fireMissile(this.game.width / 2, this.game.height - 16), 
                    this.missileGroup.forEachAlive(function(m) {
                        var distance = this.game.math.distance(m.x, m.y, this.player.x, this.player.y);
                        50 > distance && (m.kill(), this.explode(m));
                    }, this);
                },
                fireMissile: function(x, y) {
                    var missile = this.missileGroup.getFirstDead();
                    return null === missile && (missile = new Missile(this.game), this.missileGroup.add(missile)), 
                    missile.revive(), missile.x = x, missile.y = y, missile;
                },
                setupExplosions: function() {
                    this.explosionPool = this.add.group(), this.explosionPool.enableBody = !0, this.explosionPool.physicsBodyType = Phaser.Physics.ARCADE, 
                    this.explosionPool.createMultiple(100, "explosion"), this.explosionPool.setAll("anchor.x", .5), 
                    this.explosionPool.setAll("anchor.y", .5), this.explosionPool.forEach(function(explosion) {
                        explosion.animations.add("boom");
                    });
                },
                setupEmitterExplosions: function() {
                    var emitter = this.game.add.emitter(this.player.x, this.player.y, 100);
                    emitter.makeParticles("playerParticle"), emitter.minParticleSpeed.setTo(-200, -200), 
                    emitter.maxParticleSpeed.setTo(200, 200), emitter.gravity = 0, emitter.start(!0, 1e3, null, 100);
                },
                setupPlayerIcons: function() {
                    this.powerUpPool = this.add.group(), this.powerUpPool.enableBody = !0, this.powerUpPool.physicsBodyType = Phaser.Physics.ARCADE, 
                    this.powerUpPool.createMultiple(5, "powerup1"), this.powerUpPool.setAll("anchor.x", .5), 
                    this.powerUpPool.setAll("anchor.y", .5), this.powerUpPool.setAll("outOfBoundsKill", !0), 
                    this.powerUpPool.setAll("checkWorldBounds", !0), this.powerUpPool.setAll("reward", 100, !1, !1, 0, !0), 
                    this.lives = this.add.group();
                    for (var firstLifeIconX = this.game.width - 10 - 90, i = 0; 3 > i; i++) {
                        var life = this.lives.create(firstLifeIconX + 30 * i, 30, "frigate_01");
                        life.scale.setTo(.5, .5), life.anchor.setTo(.5, .5);
                    }
                },
                setupText: function() {
                    this.instructions = this.add.text(this.game.width / 2, this.game.height - 100, "Use Arrow Keys to Move, Press SPACE to Fire\nTapping/clicking does both", {
                        font: "20px monospace",
                        fill: "#fff",
                        align: "center"
                    }), this.instructions.anchor.setTo(.5, .5), this.instExpire = this.time.now + 6e3, 
                    this.score = 0, this.scoreText = this.add.text(this.game.width / 2, 30, "" + this.score, {
                        font: "20px monospace",
                        fill: "#fff",
                        align: "center"
                    }), this.scoreText.anchor.setTo(.5, .5);
                },
                setupBitmapTrail: function() {
                    this.bmd = this.game.add.bitmapData(1920, 1324), this.bmd.context.fillStyle = "#ffffff";
                    this.game.add.sprite(0, 0, this.bmd);
                },
                setupAudio: function() {
                    this.explosionSFX = this.add.audio("explosion"), this.playerExplosionSFX = this.add.audio("playerExplosion"), 
                    this.enemyFireSFX = this.add.audio("enemyFire"), this.playerFireSFX = this.add.audio("playerFire"), 
                    this.powerUpSFX = this.add.audio("powerUp");
                },
                checkCollisions: function() {
                    this.physics.arcade.collide(this.player, Asteroid.asteroids, this.hitAsteroid, null, this), 
                    this.physics.arcade.overlap(this.bulletPool, this.enemyPool, this.enemyHit, null, this), 
                    this.physics.arcade.overlap(this.bulletPool, this.shooterPool, this.enemyHit, null, this), 
                    this.physics.arcade.overlap(this.bulletPool, Asteroid.asteroids, this.asteroidHit, null, this), 
                    this.physics.arcade.overlap(this.player, this.enemyPool, this.playerHit, null, this), 
                    this.physics.arcade.overlap(this.player, this.shooterPool, this.playerHit, null, this), 
                    this.physics.arcade.overlap(this.player, this.enemyBulletPool, this.playerHit, null, this), 
                    this.physics.arcade.overlap(this.player, this.powerUpPool, this.playerPowerUp, null, this), 
                    this.bossApproaching === !1 && (this.physics.arcade.overlap(this.bulletPool, this.bossPool, this.enemyHit, null, this), 
                    this.physics.arcade.overlap(this.player, this.bossPool, this.playerHit, null, this));
                },
                spawnEnemies: function() {
                    if (this.nextEnemyAt < this.time.now && this.enemyPool.countDead() > 0) {
                        this.nextEnemyAt = this.time.now + this.enemyDelay;
                        var enemy = this.enemyPool.getFirstExists(!1);
                        enemy.reset(this.rnd.integerInRange(20, this.game.width - 20), 0, 2), enemy.body.velocity.y = this.rnd.integerInRange(30, 60), 
                        enemy.angle = 180, enemy.play("fly");
                    }
                    if (this.nextShooterAt < this.time.now && this.shooterPool.countDead() > 0) {
                        this.nextShooterAt = this.time.now + this.shooterDelay;
                        var shooter = this.shooterPool.getFirstExists(!1);
                        shooter.reset(this.rnd.integerInRange(20, this.game.width - 20), 0, 5);
                        var target = this.rnd.integerInRange(20, this.game.width - 20);
                        shooter.rotation = this.physics.arcade.moveToXY(shooter, target, this.game.height, this.rnd.integerInRange(35, 80)) - Math.PI / 2, 
                        shooter.play("fly"), shooter.nextShotAt = 0;
                    }
                },
                enemyFire: function() {
                    if (this.shooterPool.forEachAlive(function(enemy) {
                        if (this.time.now > enemy.nextShotAt && this.enemyBulletPool.countDead() > 0) {
                            var bullet = this.enemyBulletPool.getFirstExists(!1);
                            bullet.reset(enemy.x, enemy.y), this.physics.arcade.moveToObject(bullet, this.player, 150), 
                            enemy.nextShotAt = this.time.now + 2 * Phaser.Timer.SECOND;
                        }
                    }, this), this.bossApproaching === !1 && this.boss.alive && this.boss.nextShotAt < this.time.now && this.enemyBulletPool.countDead() >= 10) {
                        this.boss.nextShotAt = this.time.now + Phaser.Timer.SECOND;
                        for (var i = 0; 5 > i; i++) {
                            var leftBullet = this.enemyBulletPool.getFirstExists(!1);
                            leftBullet.reset(this.boss.x - 10 - 10 * i, this.boss.y + 20);
                            var rightBullet = this.enemyBulletPool.getFirstExists(!1);
                            rightBullet.reset(this.boss.x + 10 + 10 * i, this.boss.y + 20), this.boss.health > 100 ? (this.physics.arcade.moveToObject(leftBullet, this.player, 150), 
                            this.physics.arcade.moveToObject(rightBullet, this.player, 150)) : (this.physics.arcade.moveToXY(leftBullet, this.player.x - 100 * i, this.player.y, 150), 
                            this.physics.arcade.moveToXY(rightBullet, this.player.x + 100 * i, this.player.y, 150));
                        }
                    }
                },
                processPlayerInput: function() {
                    this.player.rotation = this.game.physics.arcade.angleToPointer(this.player), this.cursors.up.isDown || this.input.keyboard.isDown(Phaser.Keyboard.W) ? (this.game.physics.arcade.accelerationFromRotation(this.player.rotation, 200, this.player.body.acceleration), 
                    this.renderTrail()) : this.cursors.down.isDown || this.input.keyboard.isDown(Phaser.Keyboard.S) ? this.game.physics.arcade.accelerationFromRotation(this.player.rotation, -100, this.player.body.acceleration) : this.player.body.acceleration.set(0), 
                    this.cursors.left.isDown || this.input.keyboard.isDown(Phaser.Keyboard.A) || this.cursors.right.isDown || this.input.keyboard.isDown(Phaser.Keyboard.D), 
                    (this.input.keyboard.isDown(Phaser.Keyboard.SPACEBAR) || this.input.activePointer.isDown) && (this.returnText && this.returnText.exists ? this.quitGame() : this.fire());
                },
                processDelayedEffects: function() {
                    this.instructions.exists && this.time.now > this.instExpire && this.instructions.destroy(), 
                    this.ghostUntil && this.ghostUntil < this.time.now && (this.ghostUntil = null, this.player.play("fly")), 
                    this.showReturn && this.time.now > this.showReturn && (this.returnText = this.add.text(this.game.width / 2, this.game.height / 2 + 20, "Press Z or Tap Game to go back to Main Menu", {
                        font: "16px sans-serif",
                        fill: "#fff"
                    }), this.returnText.anchor.setTo(.5, .5), this.showReturn = !1), this.bossApproaching && this.boss.y > 80 && (this.bossApproaching = !1, 
                    this.boss.nextShotAt = 0, this.boss.body.velocity.y = 0, this.boss.body.velocity.x = 200, 
                    this.boss.body.bounce.x = 1, this.boss.body.collideWorldBounds = !0);
                },
                renderTrail: function() {
                    this.emitter.emitParticle();
                },
                renderBitmapTrail: function() {
                    this.bmd.context.fillRect(this.player.x, this.player.y, 1, 1), this.bmd.dirty = !0;
                },
                enemyHit: function(bullet, enemy) {
                    bullet.kill(), this.damageEnemy(enemy, 1);
                },
                asteroidHit: function(bullet, asteroid) {
                    bullet.kill(), this.damageAsteroid(asteroid, 1);
                },
                playerHit: function(player, enemy) {
                    this.damageEnemy(enemy, 5), this.explode(player), player.kill();
                    var life = this.lives.getFirstAlive();
                    null !== life ? (life.kill(), this.weaponLevel = 0) : (this.explode(player), player.kill(), 
                    this.displayEnd(!1));
                },
                damageEnemy: function(enemy, damage) {
                    enemy.damage(damage), enemy.alive ? enemy.play("hit") : (this.explode(enemy), this.spawnPowerUp(enemy), 
                    this.addToScore(enemy.reward), "boss" === enemy.key && (this.enemyPool.destroy(), 
                    this.shooterPool.destroy(), this.bossPool.destroy(), this.enemyBulletPool.destroy(), 
                    this.displayEnd(!0)));
                },
                damageAsteroid: function(asteroid, damage) {
                    asteroid.damage(damage), console.log(asteroid.alive ? "asteroid being hit is alive" : "asteroid should be dead");
                },
                addToScore: function(score) {
                    this.score += score, this.scoreText.text = this.score, this.score >= 2e4 && 1 == this.bossPool.countDead() && this.spawnBoss();
                },
                playerPowerUp: function(player, powerUp) {
                    this.addToScore(powerUp.reward), powerUp.kill(), this.weaponLevel < 5 && this.weaponLevel++;
                },
                displayEnd: function(win) {
                    if (!this.endText || !this.endText.exists) {
                        var msg = win ? "You Win! Greeaat Jooob!!!" : "Game Over nub!";
                        this.endText = this.add.text(this.game.width / 2, this.game.height / 2 - 60, msg, {
                            font: "72px serif",
                            fill: "#fff"
                        }), this.endText.anchor.setTo(.5, 0), this.showReturn = this.time.now + 2 * Phaser.Timer.SECOND;
                    }
                },
                explode: function(sprite) {
                    if (0 !== this.explosionPool.countDead()) {
                        var explosion = this.explosionPool.getFirstExists(!1);
                        explosion.reset(sprite.x, sprite.y), explosion.play("boom", 15, !1, !0), explosion.body.velocity.x = sprite.body.velocity.x, 
                        explosion.body.velocity.y = sprite.body.velocity.y;
                    }
                },
                spawnPowerUp: function(enemy) {
                    if (0 !== this.powerUpPool.countDead() && 5 !== this.weaponLevel && this.rnd.frac() < enemy.dropRate) {
                        var powerUp = this.powerUpPool.getFirstExists(!1);
                        powerUp.reset(enemy.x, enemy.y), powerUp.body.velocity.y = 100;
                    }
                },
                spawnBoss: function() {
                    this.bossApproaching = !0, this.boss.reset(this.game.width / 2, 0, 250), this.physics.enable(this.boss, Phaser.Physics.ARCADE), 
                    this.boss.body.velocity.y = 15, this.boss.play("fly");
                },
                fire: function() {
                    if (this.player.alive && !(this.nextShotAt > this.time.now)) {
                        this.nextShotAt = this.time.now + this.shotDelay;
                        var bullet;
                        if (0 === this.weaponLevel) {
                            if (0 === this.bulletPool.countDead()) return;
                            bullet = this.bulletPool.getFirstExists(!1), bullet.reset(this.player.x, this.player.y), 
                            bullet.rotation = this.player.rotation, bullet.body.velocity.x = Math.cos(bullet.rotation) * this.BULLET_SPEED, 
                            bullet.body.velocity.y = Math.sin(bullet.rotation) * this.BULLET_SPEED;
                        } else {
                            if (this.bulletPool.countDead() < 2 * this.weaponLevel) return;
                            for (var i = 0; i < this.weaponLevel; i++) bullet = this.bulletPool.getFirstExists(!1), 
                            bullet.reset(this.player.x - (10 + 6 * i), this.player.y - 20), this.physics.arcade.velocityFromAngle(-95 - 10 * i, 500, bullet.body.velocity), 
                            bullet = this.bulletPool.getFirstExists(!1), bullet.reset(this.player.x + (10 + 6 * i), this.player.y - 20), 
                            this.physics.arcade.velocityFromAngle(-85 + 10 * i, 500, bullet.body.velocity);
                        }
                    }
                },
                quitGame: function(pointer) {
                    this.sea.destroy(), this.player.destroy(), this.enemyPool.destroy(), this.bulletPool.destroy(), 
                    this.explosionPool.destroy(), this.shooterPool.destroy(), this.enemyBulletPool.destroy(), 
                    this.powerUpPool.destroy(), this.bossPool.destroy(), this.instructions.destroy(), 
                    this.scoreText.destroy(), this.endText.destroy(), this.returnText.destroy(), this.state.start("MainMenu");
                },
                screenWrap: function(sprite) {
                    sprite.x < 0 ? sprite.x = this.game.width : sprite.x > this.game.width && (sprite.x = 0), 
                    sprite.y < 0 ? sprite.y = this.game.height : sprite.y > this.game.height && (sprite.y = 0);
                },
                scrollBackground: function() {
                    this.game.camera.atLimit.x || (this.background.tilePosition.x += .5 * this.player.body.velocity.x * this.game.time.physicsElapsed), 
                    this.game.camera.atLimit.y || (this.background.tilePosition.y += .5 * this.player.body.velocity.y * this.game.time.physicsElapsed);
                },
                render: function() {
                    this.game.debug.spriteInfo(this.player, 32, 32), this.game.debug.text("activePointerCoords: " + this.game.input.activePointer.x + ", " + this.game.input.activePointer.y, 32, 170);
                }
            }, module.exports = Game;
        }).call(this);
    }, {
        "../entities/Asteroid": "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\entities\\Asteroid.js",
        "../entities/Missile": "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\entities\\Missile.js",
        "../properties": "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\properties.js",
        Stats: "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\lib\\stats.min.js"
    } ],
    "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\states\\mainMenu.js": [ function(require, module, exports) {
        (function() {
            var MainMenu = function(game) {
                this.music = null, this.playButton = null;
            };
            MainMenu.prototype = {
                create: function() {
                    this.background = this.game.add.tileSprite(0, 0, this.game.width, this.game.height, "milkyway"), 
                    this.background.autoScroll(-20, 0);
                    var text = "Tap to begin", style = {
                        font: "30px Arial",
                        fill: "#fff",
                        align: "center"
                    }, t = this.game.add.text(this.game.width / 2, this.game.height / 2, text, style);
                    t.anchor.set(.5);
                },
                update: function() {
                    this.input.activePointer.isDown && this.startGame();
                },
                startGame: function(pointer) {
                    this.state.start("Game");
                }
            }, module.exports = MainMenu;
        }).call(this);
    }, {} ],
    "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\states\\preloader.js": [ function(require, module, exports) {
        (function() {
            var Preloader = function(game) {
                this.background = null, this.preloadBar = null;
            };
            Preloader.prototype = {
                preload: function() {
                    this.stage.backgroundColor = "#2d2d2d", this.preloadBar = this.add.sprite(this.game.width / 2 - 100, this.game.height / 2, "preloaderBar"), 
                    this.add.text(this.game.width / 2, this.game.height / 2 - 30, "Loading...", {
                        font: "32px monospace",
                        fill: "#fff"
                    }).anchor.setTo(.5, .5), this.load.setPreloadSprite(this.preloadBar), this.load.image("titlepage", "images/titlepage.png#grunt-cache-bust"), 
                    this.load.image("milkyway", "images/MilkyWay_Large.jpg#grunt-cache-bust"), this.load.image("stars", "images/starfield.jpg#grunt-cache-bust"), 
                    this.load.image("bullet", "images/bullet.png#grunt-cache-bust"), this.load.image("missile", "images/bomb.png#grunt-cache-bust"), 
                    this.load.image("enemyBullet", "images/enemy-bullet.png#grunt-cache-bust"), this.load.image("powerup1", "images/powerup1.png#grunt-cache-bust"), 
                    this.load.spritesheet("greenEnemy", "images/enemy.png#grunt-cache-bust", 32, 32), 
                    this.load.spritesheet("whiteEnemy", "images/shooting-enemy.png#grunt-cache-bust", 32, 32), 
                    this.load.spritesheet("boss", "images/boss.png#grunt-cache-bust", 93, 75), this.load.spritesheet("explosion", "images/explosion.png#grunt-cache-bust", 32, 32), 
                    this.load.image("player", "images/frigate_01.png#grunt-cache-bust"), this.load.image("frigate_01", "images/frigate_01.png#grunt-cache-bust"), 
                    this.load.image("frigate_02", "images/frigate_02.png#grunt-cache-bust"), this.load.image("frigate_03", "images/frigate_03.png#grunt-cache-bust"), 
                    this.load.image("frigate_04", "images/frigate_04.png#grunt-cache-bust"), this.load.image("jets", "images/jets.png#grunt-cache-bust"), 
                    this.game.load.image("large-asteroid_01", "images/asteroid_01.png#grunt-cache-bust"), 
                    this.game.load.image("large-asteroid_02", "images/asteroid_02.png#grunt-cache-bust"), 
                    this.game.load.image("large-asteroid_03", "images/asteroid_03.png#grunt-cache-bust"), 
                    this.game.load.image("medium-asteroid_01", "images/asteroid_04.png#grunt-cache-bust"), 
                    this.game.load.image("medium-asteroid_02", "images/asteroid_05.png#grunt-cache-bust"), 
                    this.game.load.image("medium-asteroid_03", "images/asteroid_06.png#grunt-cache-bust"), 
                    this.game.load.image("medium-asteroid_04", "images/asteroid_07.png#grunt-cache-bust"), 
                    this.game.load.image("small-asteroid_01", "images/asteroid_08.png#grunt-cache-bust"), 
                    this.game.load.image("small-asteroid_02", "images/asteroid_09.png#grunt-cache-bust"), 
                    this.game.load.image("small-asteroid_03", "images/asteroid_10.png#grunt-cache-bust"), 
                    this.game.load.image("small-asteroid_04", "images/asteroid_11.png#grunt-cache-bust");
                },
                create: function() {
                    this.preloadBar.cropEnabled = !1;
                },
                update: function() {
                    this.state.start("MainMenu");
                }
            }, module.exports = Preloader;
        }).call(this);
    }, {} ],
    "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\lib\\phaser-arcade-physics.js": [ function(require, module, exports) {
        (function(process, global) {
            __browserify_shim_require__ = require, function(module, exports, require, define, browserify_shim__define__module__export__) {
                (function() {
                    var root = this, PIXI = PIXI || {};
                    PIXI.WEBGL_RENDERER = 0, PIXI.CANVAS_RENDERER = 1, PIXI.VERSION = "v2.2.0", PIXI.blendModes = {
                        NORMAL: 0,
                        ADD: 1,
                        MULTIPLY: 2,
                        SCREEN: 3,
                        OVERLAY: 4,
                        DARKEN: 5,
                        LIGHTEN: 6,
                        COLOR_DODGE: 7,
                        COLOR_BURN: 8,
                        HARD_LIGHT: 9,
                        SOFT_LIGHT: 10,
                        DIFFERENCE: 11,
                        EXCLUSION: 12,
                        HUE: 13,
                        SATURATION: 14,
                        COLOR: 15,
                        LUMINOSITY: 16
                    }, PIXI.scaleModes = {
                        DEFAULT: 0,
                        LINEAR: 0,
                        NEAREST: 1
                    }, PIXI._UID = 0, "undefined" != typeof Float32Array ? (PIXI.Float32Array = Float32Array, 
                    PIXI.Uint16Array = Uint16Array, PIXI.Uint32Array = Uint32Array, PIXI.ArrayBuffer = ArrayBuffer) : (PIXI.Float32Array = Array, 
                    PIXI.Uint16Array = Array), PIXI.INTERACTION_FREQUENCY = 30, PIXI.AUTO_PREVENT_DEFAULT = !0, 
                    PIXI.PI_2 = 2 * Math.PI, PIXI.RAD_TO_DEG = 180 / Math.PI, PIXI.DEG_TO_RAD = Math.PI / 180, 
                    PIXI.RETINA_PREFIX = "@2x", PIXI.dontSayHello = !1, PIXI.defaultRenderOptions = {
                        view: null,
                        transparent: !1,
                        antialias: !1,
                        preserveDrawingBuffer: !1,
                        resolution: 1,
                        clearBeforeRender: !0,
                        autoResize: !1
                    }, PIXI.sayHello = function(type) {
                        if (!PIXI.dontSayHello) {
                            if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                                var args = [ "%c %c %c Pixi.js " + PIXI.VERSION + " - " + type + "  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ ", "background: #ff66a5", "background: #ff66a5", "color: #ff66a5; background: #030307;", "background: #ff66a5", "background: #ffc3dc", "background: #ff66a5", "color: #ff2424; background: #fff", "color: #ff2424; background: #fff", "color: #ff2424; background: #fff" ];
                                console.log.apply(console, args);
                            } else window.console && console.log("Pixi.js " + PIXI.VERSION + " - http://www.pixijs.com/");
                            PIXI.dontSayHello = !0;
                        }
                    }, PIXI.Polygon = function(points) {
                        if (points instanceof Array || (points = Array.prototype.slice.call(arguments)), 
                        points[0] instanceof PIXI.Point) {
                            for (var p = [], i = 0, il = points.length; il > i; i++) p.push(points[i].x, points[i].y);
                            points = p;
                        }
                        this.closed = !0, this.points = points;
                    }, PIXI.Polygon.prototype.clone = function() {
                        var points = this.points.slice();
                        return new PIXI.Polygon(points);
                    }, PIXI.Polygon.prototype.contains = function(x, y) {
                        for (var inside = !1, length = this.points.length / 2, i = 0, j = length - 1; length > i; j = i++) {
                            var xi = this.points[2 * i], yi = this.points[2 * i + 1], xj = this.points[2 * j], yj = this.points[2 * j + 1], intersect = yi > y != yj > y && (xj - xi) * (y - yi) / (yj - yi) + xi > x;
                            intersect && (inside = !inside);
                        }
                        return inside;
                    }, PIXI.Polygon.prototype.constructor = PIXI.Polygon, PIXI.Matrix = function() {
                        this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0;
                    }, PIXI.Matrix.prototype.fromArray = function(array) {
                        this.a = array[0], this.b = array[1], this.c = array[3], this.d = array[4], this.tx = array[2], 
                        this.ty = array[5];
                    }, PIXI.Matrix.prototype.toArray = function(transpose) {
                        this.array || (this.array = new PIXI.Float32Array(9));
                        var array = this.array;
                        return transpose ? (array[0] = this.a, array[1] = this.b, array[2] = 0, array[3] = this.c, 
                        array[4] = this.d, array[5] = 0, array[6] = this.tx, array[7] = this.ty, array[8] = 1) : (array[0] = this.a, 
                        array[1] = this.c, array[2] = this.tx, array[3] = this.b, array[4] = this.d, array[5] = this.ty, 
                        array[6] = 0, array[7] = 0, array[8] = 1), array;
                    }, PIXI.Matrix.prototype.apply = function(pos, newPos) {
                        return newPos = newPos || new PIXI.Point(), newPos.x = this.a * pos.x + this.c * pos.y + this.tx, 
                        newPos.y = this.b * pos.x + this.d * pos.y + this.ty, newPos;
                    }, PIXI.Matrix.prototype.applyInverse = function(pos, newPos) {
                        newPos = newPos || new PIXI.Point();
                        var id = 1 / (this.a * this.d + this.c * -this.b);
                        return newPos.x = this.d * id * pos.x + -this.c * id * pos.y + (this.ty * this.c - this.tx * this.d) * id, 
                        newPos.y = this.a * id * pos.y + -this.b * id * pos.x + (-this.ty * this.a + this.tx * this.b) * id, 
                        newPos;
                    }, PIXI.Matrix.prototype.translate = function(x, y) {
                        return this.tx += x, this.ty += y, this;
                    }, PIXI.Matrix.prototype.scale = function(x, y) {
                        return this.a *= x, this.d *= y, this.c *= x, this.b *= y, this.tx *= x, this.ty *= y, 
                        this;
                    }, PIXI.Matrix.prototype.rotate = function(angle) {
                        var cos = Math.cos(angle), sin = Math.sin(angle), a1 = this.a, c1 = this.c, tx1 = this.tx;
                        return this.a = a1 * cos - this.b * sin, this.b = a1 * sin + this.b * cos, this.c = c1 * cos - this.d * sin, 
                        this.d = c1 * sin + this.d * cos, this.tx = tx1 * cos - this.ty * sin, this.ty = tx1 * sin + this.ty * cos, 
                        this;
                    }, PIXI.Matrix.prototype.append = function(matrix) {
                        var a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d;
                        return this.a = matrix.a * a1 + matrix.b * c1, this.b = matrix.a * b1 + matrix.b * d1, 
                        this.c = matrix.c * a1 + matrix.d * c1, this.d = matrix.c * b1 + matrix.d * d1, 
                        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx, this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty, 
                        this;
                    }, PIXI.Matrix.prototype.identity = function() {
                        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, 
                        this;
                    }, PIXI.identityMatrix = new PIXI.Matrix(), PIXI.Rectangle = function(x, y, width, height) {
                        this.x = x || 0, this.y = y || 0, this.width = width || 0, this.height = height || 0;
                    }, PIXI.Rectangle.prototype.clone = function() {
                        return new PIXI.Rectangle(this.x, this.y, this.width, this.height);
                    }, PIXI.Rectangle.prototype.contains = function(x, y) {
                        if (this.width <= 0 || this.height <= 0) return !1;
                        var x1 = this.x;
                        if (x >= x1 && x <= x1 + this.width) {
                            var y1 = this.y;
                            if (y >= y1 && y <= y1 + this.height) return !0;
                        }
                        return !1;
                    }, PIXI.Rectangle.prototype.constructor = PIXI.Rectangle, PIXI.EmptyRectangle = new PIXI.Rectangle(0, 0, 0, 0), 
                    PIXI.RoundedRectangle = function(x, y, width, height, radius) {
                        this.x = x || 0, this.y = y || 0, this.width = width || 0, this.height = height || 0, 
                        this.radius = radius || 20;
                    }, PIXI.RoundedRectangle.prototype.clone = function() {
                        return new PIXI.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
                    }, PIXI.RoundedRectangle.prototype.contains = function(x, y) {
                        if (this.width <= 0 || this.height <= 0) return !1;
                        var x1 = this.x;
                        if (x >= x1 && x <= x1 + this.width) {
                            var y1 = this.y;
                            if (y >= y1 && y <= y1 + this.height) return !0;
                        }
                        return !1;
                    }, PIXI.RoundedRectangle.prototype.constructor = PIXI.RoundedRectangle, PIXI.DisplayObject = function() {
                        this.position = new PIXI.Point(), this.scale = new PIXI.Point(1, 1), this.transformCallback = null, 
                        this.transformCallbackContext = null, this.pivot = new PIXI.Point(0, 0), this.rotation = 0, 
                        this.alpha = 1, this.visible = !0, this.hitArea = null, this.buttonMode = !1, this.renderable = !1, 
                        this.parent = null, this.stage = null, this.worldAlpha = 1, this._interactive = !1, 
                        this.defaultCursor = "pointer", this.worldTransform = new PIXI.Matrix(), this._sr = 0, 
                        this._cr = 1, this.filterArea = null, this._bounds = new PIXI.Rectangle(0, 0, 1, 1), 
                        this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1;
                    }, PIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject, Object.defineProperty(PIXI.DisplayObject.prototype, "interactive", {
                        get: function() {
                            return this._interactive;
                        },
                        set: function(value) {
                            this._interactive = value, this.stage && (this.stage.dirty = !0);
                        }
                    }), Object.defineProperty(PIXI.DisplayObject.prototype, "worldVisible", {
                        get: function() {
                            var item = this;
                            do {
                                if (!item.visible) return !1;
                                item = item.parent;
                            } while (item);
                            return !0;
                        }
                    }), Object.defineProperty(PIXI.DisplayObject.prototype, "mask", {
                        get: function() {
                            return this._mask;
                        },
                        set: function(value) {
                            this._mask && (this._mask.isMask = !1), this._mask = value, this._mask && (this._mask.isMask = !0);
                        }
                    }), Object.defineProperty(PIXI.DisplayObject.prototype, "filters", {
                        get: function() {
                            return this._filters;
                        },
                        set: function(value) {
                            if (value) {
                                for (var passes = [], i = 0; i < value.length; i++) for (var filterPasses = value[i].passes, j = 0; j < filterPasses.length; j++) passes.push(filterPasses[j]);
                                this._filterBlock = {
                                    target: this,
                                    filterPasses: passes
                                };
                            }
                            this._filters = value;
                        }
                    }), Object.defineProperty(PIXI.DisplayObject.prototype, "cacheAsBitmap", {
                        get: function() {
                            return this._cacheAsBitmap;
                        },
                        set: function(value) {
                            this._cacheAsBitmap !== value && (value ? this._generateCachedSprite() : this._destroyCachedSprite(), 
                            this._cacheAsBitmap = value);
                        }
                    }), PIXI.DisplayObject.prototype.updateTransform = function() {
                        var a, b, c, d, tx, ty, pt = this.parent.worldTransform, wt = this.worldTransform;
                        this.rotation % PIXI.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, 
                        this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), a = this._cr * this.scale.x, 
                        b = this._sr * this.scale.x, c = -this._sr * this.scale.y, d = this._cr * this.scale.y, 
                        tx = this.position.x, ty = this.position.y, (this.pivot.x || this.pivot.y) && (tx -= this.pivot.x * a + this.pivot.y * c, 
                        ty -= this.pivot.x * b + this.pivot.y * d), wt.a = a * pt.a + b * pt.c, wt.b = a * pt.b + b * pt.d, 
                        wt.c = c * pt.a + d * pt.c, wt.d = c * pt.b + d * pt.d, wt.tx = tx * pt.a + ty * pt.c + pt.tx, 
                        wt.ty = tx * pt.b + ty * pt.d + pt.ty) : (a = this.scale.x, d = this.scale.y, tx = this.position.x - this.pivot.x * a, 
                        ty = this.position.y - this.pivot.y * d, wt.a = a * pt.a, wt.b = a * pt.b, wt.c = d * pt.c, 
                        wt.d = d * pt.d, wt.tx = tx * pt.a + ty * pt.c + pt.tx, wt.ty = tx * pt.b + ty * pt.d + pt.ty), 
                        this.worldAlpha = this.alpha * this.parent.worldAlpha, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, wt, pt);
                    }, PIXI.DisplayObject.prototype.displayObjectUpdateTransform = PIXI.DisplayObject.prototype.updateTransform, 
                    PIXI.DisplayObject.prototype.getBounds = function(matrix) {
                        return matrix = matrix, PIXI.EmptyRectangle;
                    }, PIXI.DisplayObject.prototype.getLocalBounds = function() {
                        return this.getBounds(PIXI.identityMatrix);
                    }, PIXI.DisplayObject.prototype.setStageReference = function(stage) {
                        this.stage = stage, this._interactive && (this.stage.dirty = !0);
                    }, PIXI.DisplayObject.prototype.generateTexture = function(resolution, scaleMode, renderer) {
                        var bounds = this.getLocalBounds(), renderTexture = new PIXI.RenderTexture(0 | bounds.width, 0 | bounds.height, renderer, scaleMode, resolution);
                        return PIXI.DisplayObject._tempMatrix.tx = -bounds.x, PIXI.DisplayObject._tempMatrix.ty = -bounds.y, 
                        renderTexture.render(this, PIXI.DisplayObject._tempMatrix), renderTexture;
                    }, PIXI.DisplayObject.prototype.updateCache = function() {
                        this._generateCachedSprite();
                    }, PIXI.DisplayObject.prototype.toGlobal = function(position) {
                        return this.displayObjectUpdateTransform(), this.worldTransform.apply(position);
                    }, PIXI.DisplayObject.prototype.toLocal = function(position, from) {
                        return from && (position = from.toGlobal(position)), this.displayObjectUpdateTransform(), 
                        this.worldTransform.applyInverse(position);
                    }, PIXI.DisplayObject.prototype._renderCachedSprite = function(renderSession) {
                        this._cachedSprite.worldAlpha = this.worldAlpha, renderSession.gl ? PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession) : PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);
                    }, PIXI.DisplayObject.prototype._generateCachedSprite = function() {
                        this._cacheAsBitmap = !1;
                        var bounds = this.getLocalBounds();
                        if (this._cachedSprite) this._cachedSprite.texture.resize(0 | bounds.width, 0 | bounds.height); else {
                            var renderTexture = new PIXI.RenderTexture(0 | bounds.width, 0 | bounds.height);
                            this._cachedSprite = new PIXI.Sprite(renderTexture), this._cachedSprite.worldTransform = this.worldTransform;
                        }
                        var tempFilters = this._filters;
                        this._filters = null, this._cachedSprite.filters = tempFilters, PIXI.DisplayObject._tempMatrix.tx = -bounds.x, 
                        PIXI.DisplayObject._tempMatrix.ty = -bounds.y, this._cachedSprite.texture.render(this, PIXI.DisplayObject._tempMatrix, !0), 
                        this._cachedSprite.anchor.x = -(bounds.x / bounds.width), this._cachedSprite.anchor.y = -(bounds.y / bounds.height), 
                        this._filters = tempFilters, this._cacheAsBitmap = !0;
                    }, PIXI.DisplayObject.prototype._destroyCachedSprite = function() {
                        this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null);
                    }, PIXI.DisplayObject.prototype._renderWebGL = function(renderSession) {
                        renderSession = renderSession;
                    }, PIXI.DisplayObject.prototype._renderCanvas = function(renderSession) {
                        renderSession = renderSession;
                    }, PIXI.DisplayObject._tempMatrix = new PIXI.Matrix(), Object.defineProperty(PIXI.DisplayObject.prototype, "x", {
                        get: function() {
                            return this.position.x;
                        },
                        set: function(value) {
                            this.position.x = value;
                        }
                    }), Object.defineProperty(PIXI.DisplayObject.prototype, "y", {
                        get: function() {
                            return this.position.y;
                        },
                        set: function(value) {
                            this.position.y = value;
                        }
                    }), PIXI.DisplayObjectContainer = function() {
                        PIXI.DisplayObject.call(this), this.children = [];
                    }, PIXI.DisplayObjectContainer.prototype = Object.create(PIXI.DisplayObject.prototype), 
                    PIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer, 
                    Object.defineProperty(PIXI.DisplayObjectContainer.prototype, "width", {
                        get: function() {
                            return this.scale.x * this.getLocalBounds().width;
                        },
                        set: function(value) {
                            var width = this.getLocalBounds().width;
                            this.scale.x = 0 !== width ? value / width : 1, this._width = value;
                        }
                    }), Object.defineProperty(PIXI.DisplayObjectContainer.prototype, "height", {
                        get: function() {
                            return this.scale.y * this.getLocalBounds().height;
                        },
                        set: function(value) {
                            var height = this.getLocalBounds().height;
                            this.scale.y = 0 !== height ? value / height : 1, this._height = value;
                        }
                    }), PIXI.DisplayObjectContainer.prototype.addChild = function(child) {
                        return this.addChildAt(child, this.children.length);
                    }, PIXI.DisplayObjectContainer.prototype.addChildAt = function(child, index) {
                        if (index >= 0 && index <= this.children.length) return child.parent && child.parent.removeChild(child), 
                        child.parent = this, this.children.splice(index, 0, child), this.stage && child.setStageReference(this.stage), 
                        child;
                        throw new Error(child + "addChildAt: The index " + index + " supplied is out of bounds " + this.children.length);
                    }, PIXI.DisplayObjectContainer.prototype.swapChildren = function(child, child2) {
                        if (child !== child2) {
                            var index1 = this.getChildIndex(child), index2 = this.getChildIndex(child2);
                            if (0 > index1 || 0 > index2) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                            this.children[index1] = child2, this.children[index2] = child;
                        }
                    }, PIXI.DisplayObjectContainer.prototype.getChildIndex = function(child) {
                        var index = this.children.indexOf(child);
                        if (-1 === index) throw new Error("The supplied DisplayObject must be a child of the caller");
                        return index;
                    }, PIXI.DisplayObjectContainer.prototype.setChildIndex = function(child, index) {
                        if (0 > index || index >= this.children.length) throw new Error("The supplied index is out of bounds");
                        var currentIndex = this.getChildIndex(child);
                        this.children.splice(currentIndex, 1), this.children.splice(index, 0, child);
                    }, PIXI.DisplayObjectContainer.prototype.getChildAt = function(index) {
                        if (0 > index || index >= this.children.length) throw new Error("getChildAt: Supplied index " + index + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
                        return this.children[index];
                    }, PIXI.DisplayObjectContainer.prototype.removeChild = function(child) {
                        var index = this.children.indexOf(child);
                        if (-1 !== index) return this.removeChildAt(index);
                    }, PIXI.DisplayObjectContainer.prototype.removeChildAt = function(index) {
                        var child = this.getChildAt(index);
                        return this.stage && child.removeStageReference(), child.parent = void 0, this.children.splice(index, 1), 
                        child;
                    }, PIXI.DisplayObjectContainer.prototype.removeChildren = function(beginIndex, endIndex) {
                        var begin = beginIndex || 0, end = "number" == typeof endIndex ? endIndex : this.children.length, range = end - begin;
                        if (range > 0 && end >= range) {
                            for (var removed = this.children.splice(begin, range), i = 0; i < removed.length; i++) {
                                var child = removed[i];
                                this.stage && child.removeStageReference(), child.parent = void 0;
                            }
                            return removed;
                        }
                        if (0 === range && 0 === this.children.length) return [];
                        throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range");
                    }, PIXI.DisplayObjectContainer.prototype.updateTransform = function() {
                        if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap)) for (var i = 0, j = this.children.length; j > i; i++) this.children[i].updateTransform();
                    }, PIXI.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = PIXI.DisplayObjectContainer.prototype.updateTransform, 
                    PIXI.DisplayObjectContainer.prototype.getBounds = function() {
                        if (0 === this.children.length) return PIXI.EmptyRectangle;
                        for (var childBounds, childMaxX, childMaxY, minX = 1 / 0, minY = 1 / 0, maxX = -(1 / 0), maxY = -(1 / 0), childVisible = !1, i = 0, j = this.children.length; j > i; i++) {
                            var child = this.children[i];
                            child.visible && (childVisible = !0, childBounds = this.children[i].getBounds(), 
                            minX = minX < childBounds.x ? minX : childBounds.x, minY = minY < childBounds.y ? minY : childBounds.y, 
                            childMaxX = childBounds.width + childBounds.x, childMaxY = childBounds.height + childBounds.y, 
                            maxX = maxX > childMaxX ? maxX : childMaxX, maxY = maxY > childMaxY ? maxY : childMaxY);
                        }
                        if (!childVisible) return PIXI.EmptyRectangle;
                        var bounds = this._bounds;
                        return bounds.x = minX, bounds.y = minY, bounds.width = maxX - minX, bounds.height = maxY - minY, 
                        bounds;
                    }, PIXI.DisplayObjectContainer.prototype.getLocalBounds = function() {
                        var matrixCache = this.worldTransform;
                        this.worldTransform = PIXI.identityMatrix;
                        for (var i = 0, j = this.children.length; j > i; i++) this.children[i].updateTransform();
                        var bounds = this.getBounds();
                        return this.worldTransform = matrixCache, bounds;
                    }, PIXI.DisplayObjectContainer.prototype.setStageReference = function(stage) {
                        this.stage = stage, this._interactive && (this.stage.dirty = !0);
                        for (var i = 0, j = this.children.length; j > i; i++) {
                            var child = this.children[i];
                            child.setStageReference(stage);
                        }
                    }, PIXI.DisplayObjectContainer.prototype.removeStageReference = function() {
                        for (var i = 0, j = this.children.length; j > i; i++) {
                            var child = this.children[i];
                            child.removeStageReference();
                        }
                        this._interactive && (this.stage.dirty = !0), this.stage = null;
                    }, PIXI.DisplayObjectContainer.prototype._renderWebGL = function(renderSession) {
                        if (this.visible && !(this.alpha <= 0)) {
                            if (this._cacheAsBitmap) return void this._renderCachedSprite(renderSession);
                            var i, j;
                            if (this._mask || this._filters) {
                                for (this._filters && (renderSession.spriteBatch.flush(), renderSession.filterManager.pushFilter(this._filterBlock)), 
                                this._mask && (renderSession.spriteBatch.stop(), renderSession.maskManager.pushMask(this.mask, renderSession), 
                                renderSession.spriteBatch.start()), i = 0, j = this.children.length; j > i; i++) this.children[i]._renderWebGL(renderSession);
                                renderSession.spriteBatch.stop(), this._mask && renderSession.maskManager.popMask(this._mask, renderSession), 
                                this._filters && renderSession.filterManager.popFilter(), renderSession.spriteBatch.start();
                            } else for (i = 0, j = this.children.length; j > i; i++) this.children[i]._renderWebGL(renderSession);
                        }
                    }, PIXI.DisplayObjectContainer.prototype._renderCanvas = function(renderSession) {
                        if (this.visible !== !1 && 0 !== this.alpha) {
                            if (this._cacheAsBitmap) return void this._renderCachedSprite(renderSession);
                            this._mask && renderSession.maskManager.pushMask(this._mask, renderSession);
                            for (var i = 0, j = this.children.length; j > i; i++) {
                                var child = this.children[i];
                                child._renderCanvas(renderSession);
                            }
                            this._mask && renderSession.maskManager.popMask(renderSession);
                        }
                    }, PIXI.Sprite = function(texture) {
                        PIXI.DisplayObjectContainer.call(this), this.anchor = new PIXI.Point(), this.texture = texture || PIXI.Texture.emptyTexture, 
                        this._width = 0, this._height = 0, this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, 
                        this.shader = null, this.texture.baseTexture.hasLoaded ? this.onTextureUpdate() : this.texture.on("update", this.onTextureUpdate.bind(this)), 
                        this.renderable = !0;
                    }, PIXI.Sprite.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), 
                    PIXI.Sprite.prototype.constructor = PIXI.Sprite, Object.defineProperty(PIXI.Sprite.prototype, "width", {
                        get: function() {
                            return this.scale.x * this.texture.frame.width;
                        },
                        set: function(value) {
                            this.scale.x = value / this.texture.frame.width, this._width = value;
                        }
                    }), Object.defineProperty(PIXI.Sprite.prototype, "height", {
                        get: function() {
                            return this.scale.y * this.texture.frame.height;
                        },
                        set: function(value) {
                            this.scale.y = value / this.texture.frame.height, this._height = value;
                        }
                    }), PIXI.Sprite.prototype.setTexture = function(texture) {
                        this.texture = texture, this.cachedTint = 16777215;
                    }, PIXI.Sprite.prototype.onTextureUpdate = function() {
                        this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height);
                    }, PIXI.Sprite.prototype.getBounds = function(matrix) {
                        var width = this.texture.frame.width, height = this.texture.frame.height, w0 = width * (1 - this.anchor.x), w1 = width * -this.anchor.x, h0 = height * (1 - this.anchor.y), h1 = height * -this.anchor.y, worldTransform = matrix || this.worldTransform, a = worldTransform.a, b = worldTransform.b, c = worldTransform.c, d = worldTransform.d, tx = worldTransform.tx, ty = worldTransform.ty, maxX = -(1 / 0), maxY = -(1 / 0), minX = 1 / 0, minY = 1 / 0;
                        if (0 === b && 0 === c) 0 > a && (a *= -1), 0 > d && (d *= -1), minX = a * w1 + tx, 
                        maxX = a * w0 + tx, minY = d * h1 + ty, maxY = d * h0 + ty; else {
                            var x1 = a * w1 + c * h1 + tx, y1 = d * h1 + b * w1 + ty, x2 = a * w0 + c * h1 + tx, y2 = d * h1 + b * w0 + ty, x3 = a * w0 + c * h0 + tx, y3 = d * h0 + b * w0 + ty, x4 = a * w1 + c * h0 + tx, y4 = d * h0 + b * w1 + ty;
                            minX = minX > x1 ? x1 : minX, minX = minX > x2 ? x2 : minX, minX = minX > x3 ? x3 : minX, 
                            minX = minX > x4 ? x4 : minX, minY = minY > y1 ? y1 : minY, minY = minY > y2 ? y2 : minY, 
                            minY = minY > y3 ? y3 : minY, minY = minY > y4 ? y4 : minY, maxX = x1 > maxX ? x1 : maxX, 
                            maxX = x2 > maxX ? x2 : maxX, maxX = x3 > maxX ? x3 : maxX, maxX = x4 > maxX ? x4 : maxX, 
                            maxY = y1 > maxY ? y1 : maxY, maxY = y2 > maxY ? y2 : maxY, maxY = y3 > maxY ? y3 : maxY, 
                            maxY = y4 > maxY ? y4 : maxY;
                        }
                        var bounds = this._bounds;
                        return bounds.x = minX, bounds.width = maxX - minX, bounds.y = minY, bounds.height = maxY - minY, 
                        this._currentBounds = bounds, bounds;
                    }, PIXI.Sprite.prototype._renderWebGL = function(renderSession) {
                        if (this.visible && !(this.alpha <= 0) && this.renderable) {
                            var i, j;
                            if (this._mask || this._filters) {
                                var spriteBatch = renderSession.spriteBatch;
                                for (this._filters && (spriteBatch.flush(), renderSession.filterManager.pushFilter(this._filterBlock)), 
                                this._mask && (spriteBatch.stop(), renderSession.maskManager.pushMask(this.mask, renderSession), 
                                spriteBatch.start()), spriteBatch.render(this), i = 0, j = this.children.length; j > i; i++) this.children[i]._renderWebGL(renderSession);
                                spriteBatch.stop(), this._mask && renderSession.maskManager.popMask(this._mask, renderSession), 
                                this._filters && renderSession.filterManager.popFilter(), spriteBatch.start();
                            } else for (renderSession.spriteBatch.render(this), i = 0, j = this.children.length; j > i; i++) this.children[i]._renderWebGL(renderSession);
                        }
                    }, PIXI.Sprite.prototype._renderCanvas = function(renderSession) {
                        if (!(this.visible === !1 || 0 === this.alpha || this.renderable === !1 || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
                            if (this.blendMode !== renderSession.currentBlendMode && (renderSession.currentBlendMode = this.blendMode, 
                            renderSession.context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode]), 
                            this._mask && renderSession.maskManager.pushMask(this._mask, renderSession), this.texture.valid) {
                                var resolution = this.texture.baseTexture.resolution / renderSession.resolution;
                                renderSession.context.globalAlpha = this.worldAlpha, renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode && (renderSession.scaleMode = this.texture.baseTexture.scaleMode, 
                                renderSession.context[renderSession.smoothProperty] = renderSession.scaleMode === PIXI.scaleModes.LINEAR);
                                var dx = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width, dy = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;
                                renderSession.roundPixels ? (renderSession.context.setTransform(this.worldTransform.a, this.worldTransform.b, this.worldTransform.c, this.worldTransform.d, this.worldTransform.tx * renderSession.resolution | 0, this.worldTransform.ty * renderSession.resolution | 0), 
                                dx = 0 | dx, dy = 0 | dy) : renderSession.context.setTransform(this.worldTransform.a, this.worldTransform.b, this.worldTransform.c, this.worldTransform.d, this.worldTransform.tx * renderSession.resolution, this.worldTransform.ty * renderSession.resolution), 
                                16777215 !== this.tint ? (this.cachedTint !== this.tint && (this.cachedTint = this.tint, 
                                this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint)), renderSession.context.drawImage(this.tintedTexture, 0, 0, this.texture.crop.width, this.texture.crop.height, dx / resolution, dy / resolution, this.texture.crop.width / resolution, this.texture.crop.height / resolution)) : renderSession.context.drawImage(this.texture.baseTexture.source, this.texture.crop.x, this.texture.crop.y, this.texture.crop.width, this.texture.crop.height, dx / resolution, dy / resolution, this.texture.crop.width / resolution, this.texture.crop.height / resolution);
                            }
                            for (var i = 0, j = this.children.length; j > i; i++) this.children[i]._renderCanvas(renderSession);
                            this._mask && renderSession.maskManager.popMask(renderSession);
                        }
                    }, PIXI.Sprite.fromFrame = function(frameId) {
                        var texture = PIXI.TextureCache[frameId];
                        if (!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache' + this);
                        return new PIXI.Sprite(texture);
                    }, PIXI.Sprite.fromImage = function(imageId, crossorigin, scaleMode) {
                        var texture = PIXI.Texture.fromImage(imageId, crossorigin, scaleMode);
                        return new PIXI.Sprite(texture);
                    }, PIXI.SpriteBatch = function(texture) {
                        PIXI.DisplayObjectContainer.call(this), this.textureThing = texture, this.ready = !1;
                    }, PIXI.SpriteBatch.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), 
                    PIXI.SpriteBatch.prototype.constructor = PIXI.SpriteBatch, PIXI.SpriteBatch.prototype.initWebGL = function(gl) {
                        this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(gl), this.ready = !0;
                    }, PIXI.SpriteBatch.prototype.updateTransform = function() {
                        this.displayObjectUpdateTransform();
                    }, PIXI.SpriteBatch.prototype._renderWebGL = function(renderSession) {
                        !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(renderSession.gl), 
                        renderSession.spriteBatch.stop(), renderSession.shaderManager.setShader(renderSession.shaderManager.fastShader), 
                        this.fastSpriteBatch.begin(this, renderSession), this.fastSpriteBatch.render(this), 
                        renderSession.spriteBatch.start());
                    }, PIXI.SpriteBatch.prototype._renderCanvas = function(renderSession) {
                        if (this.visible && !(this.alpha <= 0) && this.children.length) {
                            var context = renderSession.context;
                            context.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
                            for (var transform = this.worldTransform, isRotated = !0, i = 0; i < this.children.length; i++) {
                                var child = this.children[i];
                                if (child.visible) {
                                    var texture = child.texture, frame = texture.frame;
                                    if (context.globalAlpha = this.worldAlpha * child.alpha, child.rotation % (2 * Math.PI) === 0) isRotated && (context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty), 
                                    isRotated = !1), context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, child.anchor.x * -frame.width * child.scale.x + child.position.x + .5 | 0, child.anchor.y * -frame.height * child.scale.y + child.position.y + .5 | 0, frame.width * child.scale.x, frame.height * child.scale.y); else {
                                        isRotated || (isRotated = !0), child.displayObjectUpdateTransform();
                                        var childTransform = child.worldTransform;
                                        renderSession.roundPixels ? context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, 0 | childTransform.tx, 0 | childTransform.ty) : context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx, childTransform.ty), 
                                        context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, child.anchor.x * -frame.width + .5 | 0, child.anchor.y * -frame.height + .5 | 0, frame.width, frame.height);
                                    }
                                }
                            }
                        }
                    }, PIXI.FilterBlock = function() {
                        this.visible = !0, this.renderable = !0;
                    }, PIXI.FilterBlock.prototype.constructor = PIXI.FilterBlock, PIXI.Text = function(text, style) {
                        this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), 
                        this.resolution = 1, PIXI.Sprite.call(this, PIXI.Texture.fromCanvas(this.canvas)), 
                        this.setText(text), this.setStyle(style);
                    }, PIXI.Text.prototype = Object.create(PIXI.Sprite.prototype), PIXI.Text.prototype.constructor = PIXI.Text, 
                    Object.defineProperty(PIXI.Text.prototype, "width", {
                        get: function() {
                            return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width;
                        },
                        set: function(value) {
                            this.scale.x = value / this.texture.frame.width, this._width = value;
                        }
                    }), Object.defineProperty(PIXI.Text.prototype, "height", {
                        get: function() {
                            return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height;
                        },
                        set: function(value) {
                            this.scale.y = value / this.texture.frame.height, this._height = value;
                        }
                    }), PIXI.Text.prototype.setStyle = function(style) {
                        style = style || {}, style.font = style.font || "bold 20pt Arial", style.fill = style.fill || "black", 
                        style.align = style.align || "left", style.stroke = style.stroke || "black", style.strokeThickness = style.strokeThickness || 0, 
                        style.wordWrap = style.wordWrap || !1, style.wordWrapWidth = style.wordWrapWidth || 100, 
                        style.dropShadow = style.dropShadow || !1, style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6, 
                        style.dropShadowDistance = style.dropShadowDistance || 4, style.dropShadowColor = style.dropShadowColor || "black", 
                        this.style = style, this.dirty = !0;
                    }, PIXI.Text.prototype.setText = function(text) {
                        this.text = text.toString() || " ", this.dirty = !0;
                    }, PIXI.Text.prototype.updateText = function() {
                        this.texture.baseTexture.resolution = this.resolution, this.context.font = this.style.font;
                        var outputText = this.text;
                        this.style.wordWrap && (outputText = this.wordWrap(this.text));
                        for (var lines = outputText.split(/(?:\r\n|\r|\n)/), lineWidths = [], maxLineWidth = 0, fontProperties = this.determineFontProperties(this.style.font), i = 0; i < lines.length; i++) {
                            var lineWidth = this.context.measureText(lines[i]).width;
                            lineWidths[i] = lineWidth, maxLineWidth = Math.max(maxLineWidth, lineWidth);
                        }
                        var width = maxLineWidth + this.style.strokeThickness;
                        this.style.dropShadow && (width += this.style.dropShadowDistance), this.canvas.width = (width + this.context.lineWidth) * this.resolution;
                        var lineHeight = fontProperties.fontSize + this.style.strokeThickness, height = lineHeight * lines.length;
                        this.style.dropShadow && (height += this.style.dropShadowDistance), this.canvas.height = height * this.resolution, 
                        this.context.scale(this.resolution, this.resolution), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), 
                        this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, 
                        this.context.lineWidth = this.style.strokeThickness, this.context.textBaseline = "alphabetic";
                        var linePositionX, linePositionY;
                        if (this.style.dropShadow) {
                            this.context.fillStyle = this.style.dropShadowColor;
                            var xShadowOffset = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance, yShadowOffset = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance;
                            for (i = 0; i < lines.length; i++) linePositionX = this.style.strokeThickness / 2, 
                            linePositionY = this.style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent, 
                            "right" === this.style.align ? linePositionX += maxLineWidth - lineWidths[i] : "center" === this.style.align && (linePositionX += (maxLineWidth - lineWidths[i]) / 2), 
                            this.style.fill && this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset);
                        }
                        for (this.context.fillStyle = this.style.fill, i = 0; i < lines.length; i++) linePositionX = this.style.strokeThickness / 2, 
                        linePositionY = this.style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent, 
                        "right" === this.style.align ? linePositionX += maxLineWidth - lineWidths[i] : "center" === this.style.align && (linePositionX += (maxLineWidth - lineWidths[i]) / 2), 
                        this.style.stroke && this.style.strokeThickness && this.context.strokeText(lines[i], linePositionX, linePositionY), 
                        this.style.fill && this.context.fillText(lines[i], linePositionX, linePositionY);
                        this.updateTexture();
                    }, PIXI.Text.prototype.updateTexture = function() {
                        this.texture.baseTexture.width = this.canvas.width, this.texture.baseTexture.height = this.canvas.height, 
                        this.texture.crop.width = this.texture.frame.width = this.canvas.width, this.texture.crop.height = this.texture.frame.height = this.canvas.height, 
                        this._width = this.canvas.width, this._height = this.canvas.height, this.texture.baseTexture.dirty();
                    }, PIXI.Text.prototype._renderWebGL = function(renderSession) {
                        this.dirty && (this.resolution = renderSession.resolution, this.updateText(), this.dirty = !1), 
                        PIXI.Sprite.prototype._renderWebGL.call(this, renderSession);
                    }, PIXI.Text.prototype._renderCanvas = function(renderSession) {
                        this.dirty && (this.resolution = renderSession.resolution, this.updateText(), this.dirty = !1), 
                        PIXI.Sprite.prototype._renderCanvas.call(this, renderSession);
                    }, PIXI.Text.prototype.determineFontProperties = function(fontStyle) {
                        var properties = PIXI.Text.fontPropertiesCache[fontStyle];
                        if (!properties) {
                            properties = {};
                            var canvas = PIXI.Text.fontPropertiesCanvas, context = PIXI.Text.fontPropertiesContext;
                            context.font = fontStyle;
                            var width = Math.ceil(context.measureText("|Mq").width), baseline = Math.ceil(context.measureText("M").width), height = 2 * baseline;
                            baseline = 1.4 * baseline | 0, canvas.width = width, canvas.height = height, context.fillStyle = "#f00", 
                            context.fillRect(0, 0, width, height), context.font = fontStyle, context.textBaseline = "alphabetic", 
                            context.fillStyle = "#000", context.fillText("|MÉq", 0, baseline);
                            var i, j, imagedata = context.getImageData(0, 0, width, height).data, pixels = imagedata.length, line = 4 * width, idx = 0, stop = !1;
                            for (i = 0; baseline > i; i++) {
                                for (j = 0; line > j; j += 4) if (255 !== imagedata[idx + j]) {
                                    stop = !0;
                                    break;
                                }
                                if (stop) break;
                                idx += line;
                            }
                            for (properties.ascent = baseline - i, idx = pixels - line, stop = !1, i = height; i > baseline; i--) {
                                for (j = 0; line > j; j += 4) if (255 !== imagedata[idx + j]) {
                                    stop = !0;
                                    break;
                                }
                                if (stop) break;
                                idx -= line;
                            }
                            properties.descent = i - baseline, properties.descent += 6, properties.fontSize = properties.ascent + properties.descent, 
                            PIXI.Text.fontPropertiesCache[fontStyle] = properties;
                        }
                        return properties;
                    }, PIXI.Text.prototype.wordWrap = function(text) {
                        for (var result = "", lines = text.split("\n"), i = 0; i < lines.length; i++) {
                            for (var spaceLeft = this.style.wordWrapWidth, words = lines[i].split(" "), j = 0; j < words.length; j++) {
                                var wordWidth = this.context.measureText(words[j]).width, wordWidthWithSpace = wordWidth + this.context.measureText(" ").width;
                                0 === j || wordWidthWithSpace > spaceLeft ? (j > 0 && (result += "\n"), result += words[j], 
                                spaceLeft = this.style.wordWrapWidth - wordWidth) : (spaceLeft -= wordWidthWithSpace, 
                                result += " " + words[j]);
                            }
                            i < lines.length - 1 && (result += "\n");
                        }
                        return result;
                    }, PIXI.Text.prototype.getBounds = function(matrix) {
                        return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, matrix);
                    }, PIXI.Text.prototype.destroy = function(destroyBaseTexture) {
                        this.context = null, this.canvas = null, this.texture.destroy(void 0 === destroyBaseTexture ? !0 : destroyBaseTexture);
                    }, PIXI.Text.fontPropertiesCache = {}, PIXI.Text.fontPropertiesCanvas = document.createElement("canvas"), 
                    PIXI.Text.fontPropertiesContext = PIXI.Text.fontPropertiesCanvas.getContext("2d"), 
                    PIXI.BitmapText = function(text, style) {
                        PIXI.DisplayObjectContainer.call(this), this.textWidth = 0, this.textHeight = 0, 
                        this._pool = [], this.setText(text), this.setStyle(style), this.updateText(), this.dirty = !1;
                    }, PIXI.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), 
                    PIXI.BitmapText.prototype.constructor = PIXI.BitmapText, PIXI.BitmapText.prototype.setText = function(text) {
                        this.text = text || " ", this.dirty = !0;
                    }, PIXI.BitmapText.prototype.setStyle = function(style) {
                        style = style || {}, style.align = style.align || "left", this.style = style;
                        var font = style.font.split(" ");
                        this.fontName = font[font.length - 1], this.fontSize = font.length >= 2 ? parseInt(font[font.length - 2], 10) : PIXI.BitmapText.fonts[this.fontName].size, 
                        this.dirty = !0, this.tint = style.tint;
                    }, PIXI.BitmapText.prototype.updateText = function() {
                        for (var data = PIXI.BitmapText.fonts[this.fontName], pos = new PIXI.Point(), prevCharCode = null, chars = [], maxLineWidth = 0, lineWidths = [], line = 0, scale = this.fontSize / data.size, i = 0; i < this.text.length; i++) {
                            var charCode = this.text.charCodeAt(i);
                            if (/(?:\r\n|\r|\n)/.test(this.text.charAt(i))) lineWidths.push(pos.x), maxLineWidth = Math.max(maxLineWidth, pos.x), 
                            line++, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null; else {
                                var charData = data.chars[charCode];
                                charData && (prevCharCode && charData.kerning[prevCharCode] && (pos.x += charData.kerning[prevCharCode]), 
                                chars.push({
                                    texture: charData.texture,
                                    line: line,
                                    charCode: charCode,
                                    position: new PIXI.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)
                                }), pos.x += charData.xAdvance, prevCharCode = charCode);
                            }
                        }
                        lineWidths.push(pos.x), maxLineWidth = Math.max(maxLineWidth, pos.x);
                        var lineAlignOffsets = [];
                        for (i = 0; line >= i; i++) {
                            var alignOffset = 0;
                            "right" === this.style.align ? alignOffset = maxLineWidth - lineWidths[i] : "center" === this.style.align && (alignOffset = (maxLineWidth - lineWidths[i]) / 2), 
                            lineAlignOffsets.push(alignOffset);
                        }
                        var lenChildren = this.children.length, lenChars = chars.length, tint = this.tint || 16777215;
                        for (i = 0; lenChars > i; i++) {
                            var c = lenChildren > i ? this.children[i] : this._pool.pop();
                            c ? c.setTexture(chars[i].texture) : c = new PIXI.Sprite(chars[i].texture), c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale, 
                            c.position.y = chars[i].position.y * scale, c.scale.x = c.scale.y = scale, c.tint = tint, 
                            c.parent || this.addChild(c);
                        }
                        for (;this.children.length > lenChars; ) {
                            var child = this.getChildAt(this.children.length - 1);
                            this._pool.push(child), this.removeChild(child);
                        }
                        this.textWidth = maxLineWidth * scale, this.textHeight = (pos.y + data.lineHeight) * scale;
                    }, PIXI.BitmapText.prototype.updateTransform = function() {
                        this.dirty && (this.updateText(), this.dirty = !1), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
                    }, PIXI.BitmapText.fonts = {}, PIXI.Stage = function(backgroundColor) {
                        PIXI.DisplayObjectContainer.call(this), this.worldTransform = new PIXI.Matrix(), 
                        this.interactive = !0, this.interactionManager = new PIXI.InteractionManager(this), 
                        this.dirty = !0, this.stage = this, this.stage.hitArea = new PIXI.Rectangle(0, 0, 1e5, 1e5), 
                        this.setBackgroundColor(backgroundColor);
                    }, PIXI.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), 
                    PIXI.Stage.prototype.constructor = PIXI.Stage, PIXI.Stage.prototype.setInteractionDelegate = function(domElement) {
                        this.interactionManager.setTargetDomElement(domElement);
                    }, PIXI.Stage.prototype.updateTransform = function() {
                        this.worldAlpha = 1;
                        for (var i = 0, j = this.children.length; j > i; i++) this.children[i].updateTransform();
                        this.dirty && (this.dirty = !1, this.interactionManager.dirty = !0), this.interactive && this.interactionManager.update();
                    }, PIXI.Stage.prototype.setBackgroundColor = function(backgroundColor) {
                        this.backgroundColor = backgroundColor || 0, this.backgroundColorSplit = PIXI.hex2rgb(this.backgroundColor);
                        var hex = this.backgroundColor.toString(16);
                        hex = "000000".substr(0, 6 - hex.length) + hex, this.backgroundColorString = "#" + hex;
                    }, PIXI.Stage.prototype.getMousePosition = function() {
                        return this.interactionManager.mouse.global;
                    }, function(window) {
                        for (var lastTime = 0, vendors = [ "ms", "moz", "webkit", "o" ], x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"], 
                        window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
                        window.requestAnimationFrame || (window.requestAnimationFrame = function(callback) {
                            var currTime = new Date().getTime(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), id = window.setTimeout(function() {
                                callback(currTime + timeToCall);
                            }, timeToCall);
                            return lastTime = currTime + timeToCall, id;
                        }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function(id) {
                            clearTimeout(id);
                        }), window.requestAnimFrame = window.requestAnimationFrame;
                    }(this), PIXI.hex2rgb = function(hex) {
                        return [ (hex >> 16 & 255) / 255, (hex >> 8 & 255) / 255, (255 & hex) / 255 ];
                    }, PIXI.rgb2hex = function(rgb) {
                        return (255 * rgb[0] << 16) + (255 * rgb[1] << 8) + 255 * rgb[2];
                    }, "function" != typeof Function.prototype.bind && (Function.prototype.bind = function() {
                        return function(thisArg) {
                            function bound() {
                                for (var i = arguments.length, args = new Array(i); i--; ) args[i] = arguments[i];
                                return args = boundArgs.concat(args), target.apply(this instanceof bound ? this : thisArg, args);
                            }
                            var target = this, i = arguments.length - 1, boundArgs = [];
                            if (i > 0) for (boundArgs.length = i; i--; ) boundArgs[i] = arguments[i + 1];
                            if ("function" != typeof target) throw new TypeError();
                            return bound.prototype = function F(proto) {
                                return proto && (F.prototype = proto), this instanceof F ? void 0 : new F();
                            }(target.prototype), bound;
                        };
                    }()), PIXI.AjaxRequest = function() {
                        var activexmodes = [ "Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Microsoft.XMLHTTP" ];
                        if (!window.ActiveXObject) return window.XMLHttpRequest ? new window.XMLHttpRequest() : !1;
                        for (var i = 0; i < activexmodes.length; i++) try {
                            return new window.ActiveXObject(activexmodes[i]);
                        } catch (e) {}
                    }, PIXI.canUseNewCanvasBlendModes = function() {
                        if ("undefined" == typeof document) return !1;
                        var canvas = document.createElement("canvas");
                        canvas.width = 1, canvas.height = 1;
                        var context = canvas.getContext("2d");
                        return context.fillStyle = "#000", context.fillRect(0, 0, 1, 1), context.globalCompositeOperation = "multiply", 
                        context.fillStyle = "#fff", context.fillRect(0, 0, 1, 1), 0 === context.getImageData(0, 0, 1, 1).data[0];
                    }, PIXI.getNextPowerOfTwo = function(number) {
                        if (number > 0 && 0 === (number & number - 1)) return number;
                        for (var result = 1; number > result; ) result <<= 1;
                        return result;
                    }, PIXI.isPowerOfTwo = function(width, height) {
                        return width > 0 && 0 === (width & width - 1) && height > 0 && 0 === (height & height - 1);
                    }, PIXI.EventTarget = {
                        call: function(obj) {
                            obj && (obj = obj.prototype || obj, PIXI.EventTarget.mixin(obj));
                        },
                        mixin: function(obj) {
                            obj.listeners = function(eventName) {
                                return this._listeners = this._listeners || {}, this._listeners[eventName] ? this._listeners[eventName].slice() : [];
                            }, obj.emit = obj.dispatchEvent = function(eventName, data) {
                                if (this._listeners = this._listeners || {}, "object" == typeof eventName && (data = eventName, 
                                eventName = eventName.type), data && data.__isEventObject === !0 || (data = new PIXI.Event(this, eventName, data)), 
                                this._listeners && this._listeners[eventName]) {
                                    var i, listeners = this._listeners[eventName].slice(0), length = listeners.length, fn = listeners[0];
                                    for (i = 0; length > i; fn = listeners[++i]) if (fn.call(this, data), data.stoppedImmediate) return this;
                                    if (data.stopped) return this;
                                }
                                return this.parent && this.parent.emit && this.parent.emit.call(this.parent, eventName, data), 
                                this;
                            }, obj.on = obj.addEventListener = function(eventName, fn) {
                                return this._listeners = this._listeners || {}, (this._listeners[eventName] = this._listeners[eventName] || []).push(fn), 
                                this;
                            }, obj.once = function(eventName, fn) {
                                function onceHandlerWrapper() {
                                    fn.apply(self.off(eventName, onceHandlerWrapper), arguments);
                                }
                                this._listeners = this._listeners || {};
                                var self = this;
                                return onceHandlerWrapper._originalHandler = fn, this.on(eventName, onceHandlerWrapper);
                            }, obj.off = obj.removeEventListener = function(eventName, fn) {
                                if (this._listeners = this._listeners || {}, !this._listeners[eventName]) return this;
                                for (var list = this._listeners[eventName], i = fn ? list.length : 0; i-- > 0; ) (list[i] === fn || list[i]._originalHandler === fn) && list.splice(i, 1);
                                return 0 === list.length && delete this._listeners[eventName], this;
                            }, obj.removeAllListeners = function(eventName) {
                                return this._listeners = this._listeners || {}, this._listeners[eventName] ? (delete this._listeners[eventName], 
                                this) : this;
                            };
                        }
                    }, PIXI.Event = function(target, name, data) {
                        this.__isEventObject = !0, this.stopped = !1, this.stoppedImmediate = !1, this.target = target, 
                        this.type = name, this.data = data, this.content = data, this.timeStamp = Date.now();
                    }, PIXI.Event.prototype.stopPropagation = function() {
                        this.stopped = !0;
                    }, PIXI.Event.prototype.stopImmediatePropagation = function() {
                        this.stoppedImmediate = !0;
                    }, PIXI.PolyK = {}, PIXI.PolyK.Triangulate = function(p) {
                        var sign = !0, n = p.length >> 1;
                        if (3 > n) return [];
                        for (var tgs = [], avl = [], i = 0; n > i; i++) avl.push(i);
                        i = 0;
                        for (var al = n; al > 3; ) {
                            var i0 = avl[(i + 0) % al], i1 = avl[(i + 1) % al], i2 = avl[(i + 2) % al], ax = p[2 * i0], ay = p[2 * i0 + 1], bx = p[2 * i1], by = p[2 * i1 + 1], cx = p[2 * i2], cy = p[2 * i2 + 1], earFound = !1;
                            if (PIXI.PolyK._convex(ax, ay, bx, by, cx, cy, sign)) {
                                earFound = !0;
                                for (var j = 0; al > j; j++) {
                                    var vi = avl[j];
                                    if (vi !== i0 && vi !== i1 && vi !== i2 && PIXI.PolyK._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
                                        earFound = !1;
                                        break;
                                    }
                                }
                            }
                            if (earFound) tgs.push(i0, i1, i2), avl.splice((i + 1) % al, 1), al--, i = 0; else if (i++ > 3 * al) {
                                if (!sign) return null;
                                for (tgs = [], avl = [], i = 0; n > i; i++) avl.push(i);
                                i = 0, al = n, sign = !1;
                            }
                        }
                        return tgs.push(avl[0], avl[1], avl[2]), tgs;
                    }, PIXI.PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy) {
                        var v0x = cx - ax, v0y = cy - ay, v1x = bx - ax, v1y = by - ay, v2x = px - ax, v2y = py - ay, dot00 = v0x * v0x + v0y * v0y, dot01 = v0x * v1x + v0y * v1y, dot02 = v0x * v2x + v0y * v2y, dot11 = v1x * v1x + v1y * v1y, dot12 = v1x * v2x + v1y * v2y, invDenom = 1 / (dot00 * dot11 - dot01 * dot01), u = (dot11 * dot02 - dot01 * dot12) * invDenom, v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                        return u >= 0 && v >= 0 && 1 > u + v;
                    }, PIXI.PolyK._convex = function(ax, ay, bx, by, cx, cy, sign) {
                        return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0 === sign;
                    }, PIXI.initDefaultShaders = function() {}, PIXI.CompileVertexShader = function(gl, shaderSrc) {
                        return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);
                    }, PIXI.CompileFragmentShader = function(gl, shaderSrc) {
                        return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);
                    }, PIXI._CompileShader = function(gl, shaderSrc, shaderType) {
                        var src = shaderSrc.join("\n"), shader = gl.createShader(shaderType);
                        return gl.shaderSource(shader, src), gl.compileShader(shader), gl.getShaderParameter(shader, gl.COMPILE_STATUS) ? shader : (window.console.log(gl.getShaderInfoLog(shader)), 
                        null);
                    }, PIXI.compileProgram = function(gl, vertexSrc, fragmentSrc) {
                        var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc), vertexShader = PIXI.CompileVertexShader(gl, vertexSrc), shaderProgram = gl.createProgram();
                        return gl.attachShader(shaderProgram, vertexShader), gl.attachShader(shaderProgram, fragmentShader), 
                        gl.linkProgram(shaderProgram), gl.getProgramParameter(shaderProgram, gl.LINK_STATUS) || window.console.log("Could not initialise shaders"), 
                        shaderProgram;
                    }, PIXI.PixiShader = function(gl) {
                        this._UID = PIXI._UID++, this.gl = gl, this.program = null, this.fragmentSrc = [ "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ], 
                        this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], 
                        this.init();
                    }, PIXI.PixiShader.prototype.constructor = PIXI.PixiShader, PIXI.PixiShader.prototype.init = function() {
                        var gl = this.gl, program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);
                        gl.useProgram(program), this.uSampler = gl.getUniformLocation(program, "uSampler"), 
                        this.projectionVector = gl.getUniformLocation(program, "projectionVector"), this.offsetVector = gl.getUniformLocation(program, "offsetVector"), 
                        this.dimensions = gl.getUniformLocation(program, "dimensions"), this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"), 
                        this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord"), this.colorAttribute = gl.getAttribLocation(program, "aColor"), 
                        -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [ this.aVertexPosition, this.aTextureCoord, this.colorAttribute ];
                        for (var key in this.uniforms) this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);
                        this.initUniforms(), this.program = program;
                    }, PIXI.PixiShader.prototype.initUniforms = function() {
                        this.textureCount = 1;
                        var uniform, gl = this.gl;
                        for (var key in this.uniforms) {
                            uniform = this.uniforms[key];
                            var type = uniform.type;
                            "sampler2D" === type ? (uniform._init = !1, null !== uniform.value && this.initSampler2D(uniform)) : "mat2" === type || "mat3" === type || "mat4" === type ? (uniform.glMatrix = !0, 
                            uniform.glValueLength = 1, "mat2" === type ? uniform.glFunc = gl.uniformMatrix2fv : "mat3" === type ? uniform.glFunc = gl.uniformMatrix3fv : "mat4" === type && (uniform.glFunc = gl.uniformMatrix4fv)) : (uniform.glFunc = gl["uniform" + type], 
                            uniform.glValueLength = "2f" === type || "2i" === type ? 2 : "3f" === type || "3i" === type ? 3 : "4f" === type || "4i" === type ? 4 : 1);
                        }
                    }, PIXI.PixiShader.prototype.initSampler2D = function(uniform) {
                        if (uniform.value && uniform.value.baseTexture && uniform.value.baseTexture.hasLoaded) {
                            var gl = this.gl;
                            if (gl.activeTexture(gl["TEXTURE" + this.textureCount]), gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]), 
                            uniform.textureData) {
                                var data = uniform.textureData, magFilter = data.magFilter ? data.magFilter : gl.LINEAR, minFilter = data.minFilter ? data.minFilter : gl.LINEAR, wrapS = data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE, wrapT = data.wrapT ? data.wrapT : gl.CLAMP_TO_EDGE, format = data.luminance ? gl.LUMINANCE : gl.RGBA;
                                if (data.repeat && (wrapS = gl.REPEAT, wrapT = gl.REPEAT), gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY), 
                                data.width) {
                                    var width = data.width ? data.width : 512, height = data.height ? data.height : 2, border = data.border ? data.border : 0;
                                    gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);
                                } else gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source);
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter), 
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
                            }
                            gl.uniform1i(uniform.uniformLocation, this.textureCount), uniform._init = !0, this.textureCount++;
                        }
                    }, PIXI.PixiShader.prototype.syncUniforms = function() {
                        this.textureCount = 1;
                        var uniform, gl = this.gl;
                        for (var key in this.uniforms) uniform = this.uniforms[key], 1 === uniform.glValueLength ? uniform.glMatrix === !0 ? uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value) : uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value) : 2 === uniform.glValueLength ? uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y) : 3 === uniform.glValueLength ? uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z) : 4 === uniform.glValueLength ? uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w) : "sampler2D" === uniform.type && (uniform._init ? (gl.activeTexture(gl["TEXTURE" + this.textureCount]), 
                        uniform.value.baseTexture._dirty[gl.id] ? PIXI.instances[gl.id].updateTexture(uniform.value.baseTexture) : gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]), 
                        gl.uniform1i(uniform.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(uniform));
                    }, PIXI.PixiShader.prototype.destroy = function() {
                        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null;
                    }, PIXI.PixiShader.defaultVertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}" ], 
                    PIXI.PixiFastShader = function(gl) {
                        this._UID = PIXI._UID++, this.gl = gl, this.program = null, this.fragmentSrc = [ "precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ], 
                        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}" ], 
                        this.textureCount = 0, this.init();
                    }, PIXI.PixiFastShader.prototype.constructor = PIXI.PixiFastShader, PIXI.PixiFastShader.prototype.init = function() {
                        var gl = this.gl, program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
                        gl.useProgram(program), this.uSampler = gl.getUniformLocation(program, "uSampler"), 
                        this.projectionVector = gl.getUniformLocation(program, "projectionVector"), this.offsetVector = gl.getUniformLocation(program, "offsetVector"), 
                        this.dimensions = gl.getUniformLocation(program, "dimensions"), this.uMatrix = gl.getUniformLocation(program, "uMatrix"), 
                        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"), this.aPositionCoord = gl.getAttribLocation(program, "aPositionCoord"), 
                        this.aScale = gl.getAttribLocation(program, "aScale"), this.aRotation = gl.getAttribLocation(program, "aRotation"), 
                        this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord"), this.colorAttribute = gl.getAttribLocation(program, "aColor"), 
                        -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [ this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute ], 
                        this.program = program;
                    }, PIXI.PixiFastShader.prototype.destroy = function() {
                        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null;
                    }, PIXI.StripShader = function(gl) {
                        this._UID = PIXI._UID++, this.gl = gl, this.program = null, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}" ], 
                        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}" ], 
                        this.init();
                    }, PIXI.StripShader.prototype.constructor = PIXI.StripShader, PIXI.StripShader.prototype.init = function() {
                        var gl = this.gl, program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
                        gl.useProgram(program), this.uSampler = gl.getUniformLocation(program, "uSampler"), 
                        this.projectionVector = gl.getUniformLocation(program, "projectionVector"), this.offsetVector = gl.getUniformLocation(program, "offsetVector"), 
                        this.colorAttribute = gl.getAttribLocation(program, "aColor"), this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"), 
                        this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord"), this.attributes = [ this.aVertexPosition, this.aTextureCoord ], 
                        this.translationMatrix = gl.getUniformLocation(program, "translationMatrix"), this.alpha = gl.getUniformLocation(program, "alpha"), 
                        this.program = program;
                    }, PIXI.StripShader.prototype.destroy = function() {
                        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null;
                    }, PIXI.PrimitiveShader = function(gl) {
                        this._UID = PIXI._UID++, this.gl = gl, this.program = null, this.fragmentSrc = [ "precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}" ], 
                        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}" ], 
                        this.init();
                    }, PIXI.PrimitiveShader.prototype.constructor = PIXI.PrimitiveShader, PIXI.PrimitiveShader.prototype.init = function() {
                        var gl = this.gl, program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
                        gl.useProgram(program), this.projectionVector = gl.getUniformLocation(program, "projectionVector"), 
                        this.offsetVector = gl.getUniformLocation(program, "offsetVector"), this.tintColor = gl.getUniformLocation(program, "tint"), 
                        this.flipY = gl.getUniformLocation(program, "flipY"), this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"), 
                        this.colorAttribute = gl.getAttribLocation(program, "aColor"), this.attributes = [ this.aVertexPosition, this.colorAttribute ], 
                        this.translationMatrix = gl.getUniformLocation(program, "translationMatrix"), this.alpha = gl.getUniformLocation(program, "alpha"), 
                        this.program = program;
                    }, PIXI.PrimitiveShader.prototype.destroy = function() {
                        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null;
                    }, PIXI.ComplexPrimitiveShader = function(gl) {
                        this._UID = PIXI._UID++, this.gl = gl, this.program = null, this.fragmentSrc = [ "precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}" ], 
                        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}" ], 
                        this.init();
                    }, PIXI.ComplexPrimitiveShader.prototype.constructor = PIXI.ComplexPrimitiveShader, 
                    PIXI.ComplexPrimitiveShader.prototype.init = function() {
                        var gl = this.gl, program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
                        gl.useProgram(program), this.projectionVector = gl.getUniformLocation(program, "projectionVector"), 
                        this.offsetVector = gl.getUniformLocation(program, "offsetVector"), this.tintColor = gl.getUniformLocation(program, "tint"), 
                        this.color = gl.getUniformLocation(program, "color"), this.flipY = gl.getUniformLocation(program, "flipY"), 
                        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition"), this.attributes = [ this.aVertexPosition, this.colorAttribute ], 
                        this.translationMatrix = gl.getUniformLocation(program, "translationMatrix"), this.alpha = gl.getUniformLocation(program, "alpha"), 
                        this.program = program;
                    }, PIXI.ComplexPrimitiveShader.prototype.destroy = function() {
                        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null;
                    }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.renderGraphics = function(graphics, renderSession) {
                        var webGLData, gl = renderSession.gl, projection = renderSession.projection, offset = renderSession.offset, shader = renderSession.shaderManager.primitiveShader;
                        graphics.dirty && PIXI.WebGLGraphics.updateGraphics(graphics, gl);
                        for (var webGL = graphics._webGL[gl.id], i = 0; i < webGL.data.length; i++) 1 === webGL.data[i].mode ? (webGLData = webGL.data[i], 
                        renderSession.stencilManager.pushStencil(graphics, webGLData, renderSession), gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, 2 * (webGLData.indices.length - 4)), 
                        renderSession.stencilManager.popStencil(graphics, webGLData, renderSession)) : (webGLData = webGL.data[i], 
                        renderSession.shaderManager.setShader(shader), shader = renderSession.shaderManager.primitiveShader, 
                        gl.uniformMatrix3fv(shader.translationMatrix, !1, graphics.worldTransform.toArray(!0)), 
                        gl.uniform1f(shader.flipY, 1), gl.uniform2f(shader.projectionVector, projection.x, -projection.y), 
                        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y), gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint)), 
                        gl.uniform1f(shader.alpha, graphics.worldAlpha), gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer), 
                        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, !1, 24, 0), gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, !1, 24, 8), 
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer), gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0));
                    }, PIXI.WebGLGraphics.updateGraphics = function(graphics, gl) {
                        var webGL = graphics._webGL[gl.id];
                        webGL || (webGL = graphics._webGL[gl.id] = {
                            lastIndex: 0,
                            data: [],
                            gl: gl
                        }), graphics.dirty = !1;
                        var i;
                        if (graphics.clearDirty) {
                            for (graphics.clearDirty = !1, i = 0; i < webGL.data.length; i++) {
                                var graphicsData = webGL.data[i];
                                graphicsData.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(graphicsData);
                            }
                            webGL.data = [], webGL.lastIndex = 0;
                        }
                        var webGLData;
                        for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++) {
                            var data = graphics.graphicsData[i];
                            if (data.type === PIXI.Graphics.POLY) {
                                if (data.points = data.shape.points.slice(), data.shape.closed && (data.points[0] !== data.points[data.points.length - 2] || data.points[1] !== data.points[data.points.length - 1]) && data.points.push(data.points[0], data.points[1]), 
                                data.fill && data.points.length >= 6) if (data.points.length < 12) {
                                    webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                                    var canDrawUsingSimple = PIXI.WebGLGraphics.buildPoly(data, webGLData);
                                    canDrawUsingSimple || (webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1), PIXI.WebGLGraphics.buildComplexPoly(data, webGLData));
                                } else webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1), PIXI.WebGLGraphics.buildComplexPoly(data, webGLData);
                                data.lineWidth > 0 && (webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0), PIXI.WebGLGraphics.buildLine(data, webGLData));
                            } else webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0), data.type === PIXI.Graphics.RECT ? PIXI.WebGLGraphics.buildRectangle(data, webGLData) : data.type === PIXI.Graphics.CIRC || data.type === PIXI.Graphics.ELIP ? PIXI.WebGLGraphics.buildCircle(data, webGLData) : data.type === PIXI.Graphics.RREC && PIXI.WebGLGraphics.buildRoundedRectangle(data, webGLData);
                            webGL.lastIndex++;
                        }
                        for (i = 0; i < webGL.data.length; i++) webGLData = webGL.data[i], webGLData.dirty && webGLData.upload();
                    }, PIXI.WebGLGraphics.switchMode = function(webGL, type) {
                        var webGLData;
                        return webGL.data.length ? (webGLData = webGL.data[webGL.data.length - 1], (webGLData.mode !== type || 1 === type) && (webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl), 
                        webGLData.mode = type, webGL.data.push(webGLData))) : (webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl), 
                        webGLData.mode = type, webGL.data.push(webGLData)), webGLData.dirty = !0, webGLData;
                    }, PIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData) {
                        var rectData = graphicsData.shape, x = rectData.x, y = rectData.y, width = rectData.width, height = rectData.height;
                        if (graphicsData.fill) {
                            var color = PIXI.hex2rgb(graphicsData.fillColor), alpha = graphicsData.fillAlpha, r = color[0] * alpha, g = color[1] * alpha, b = color[2] * alpha, verts = webGLData.points, indices = webGLData.indices, vertPos = verts.length / 6;
                            verts.push(x, y), verts.push(r, g, b, alpha), verts.push(x + width, y), verts.push(r, g, b, alpha), 
                            verts.push(x, y + height), verts.push(r, g, b, alpha), verts.push(x + width, y + height), 
                            verts.push(r, g, b, alpha), indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
                        }
                        if (graphicsData.lineWidth) {
                            var tempPoints = graphicsData.points;
                            graphicsData.points = [ x, y, x + width, y, x + width, y + height, x, y + height, x, y ], 
                            PIXI.WebGLGraphics.buildLine(graphicsData, webGLData), graphicsData.points = tempPoints;
                        }
                    }, PIXI.WebGLGraphics.buildRoundedRectangle = function(graphicsData, webGLData) {
                        var rrectData = graphicsData.shape, x = rrectData.x, y = rrectData.y, width = rrectData.width, height = rrectData.height, radius = rrectData.radius, recPoints = [];
                        if (recPoints.push(x, y + radius), recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height)), 
                        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius)), 
                        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y)), 
                        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + radius, y, x, y, x, y + radius)), 
                        graphicsData.fill) {
                            var color = PIXI.hex2rgb(graphicsData.fillColor), alpha = graphicsData.fillAlpha, r = color[0] * alpha, g = color[1] * alpha, b = color[2] * alpha, verts = webGLData.points, indices = webGLData.indices, vecPos = verts.length / 6, triangles = PIXI.PolyK.Triangulate(recPoints), i = 0;
                            for (i = 0; i < triangles.length; i += 3) indices.push(triangles[i] + vecPos), indices.push(triangles[i] + vecPos), 
                            indices.push(triangles[i + 1] + vecPos), indices.push(triangles[i + 2] + vecPos), 
                            indices.push(triangles[i + 2] + vecPos);
                            for (i = 0; i < recPoints.length; i++) verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);
                        }
                        if (graphicsData.lineWidth) {
                            var tempPoints = graphicsData.points;
                            graphicsData.points = recPoints, PIXI.WebGLGraphics.buildLine(graphicsData, webGLData), 
                            graphicsData.points = tempPoints;
                        }
                    }, PIXI.WebGLGraphics.quadraticBezierCurve = function(fromX, fromY, cpX, cpY, toX, toY) {
                        function getPt(n1, n2, perc) {
                            var diff = n2 - n1;
                            return n1 + diff * perc;
                        }
                        for (var xa, ya, xb, yb, x, y, n = 20, points = [], j = 0, i = 0; n >= i; i++) j = i / n, 
                        xa = getPt(fromX, cpX, j), ya = getPt(fromY, cpY, j), xb = getPt(cpX, toX, j), yb = getPt(cpY, toY, j), 
                        x = getPt(xa, xb, j), y = getPt(ya, yb, j), points.push(x, y);
                        return points;
                    }, PIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData) {
                        var width, height, circleData = graphicsData.shape, x = circleData.x, y = circleData.y;
                        graphicsData.type === PIXI.Graphics.CIRC ? (width = circleData.radius, height = circleData.radius) : (width = circleData.width, 
                        height = circleData.height);
                        var totalSegs = 40, seg = 2 * Math.PI / totalSegs, i = 0;
                        if (graphicsData.fill) {
                            var color = PIXI.hex2rgb(graphicsData.fillColor), alpha = graphicsData.fillAlpha, r = color[0] * alpha, g = color[1] * alpha, b = color[2] * alpha, verts = webGLData.points, indices = webGLData.indices, vecPos = verts.length / 6;
                            for (indices.push(vecPos), i = 0; totalSegs + 1 > i; i++) verts.push(x, y, r, g, b, alpha), 
                            verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha), 
                            indices.push(vecPos++, vecPos++);
                            indices.push(vecPos - 1);
                        }
                        if (graphicsData.lineWidth) {
                            var tempPoints = graphicsData.points;
                            for (graphicsData.points = [], i = 0; totalSegs + 1 > i; i++) graphicsData.points.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height);
                            PIXI.WebGLGraphics.buildLine(graphicsData, webGLData), graphicsData.points = tempPoints;
                        }
                    }, PIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData) {
                        var i = 0, points = graphicsData.points;
                        if (0 !== points.length) {
                            if (graphicsData.lineWidth % 2) for (i = 0; i < points.length; i++) points[i] += .5;
                            var firstPoint = new PIXI.Point(points[0], points[1]), lastPoint = new PIXI.Point(points[points.length - 2], points[points.length - 1]);
                            if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) {
                                points = points.slice(), points.pop(), points.pop(), lastPoint = new PIXI.Point(points[points.length - 2], points[points.length - 1]);
                                var midPointX = lastPoint.x + .5 * (firstPoint.x - lastPoint.x), midPointY = lastPoint.y + .5 * (firstPoint.y - lastPoint.y);
                                points.unshift(midPointX, midPointY), points.push(midPointX, midPointY);
                            }
                            var px, py, p1x, p1y, p2x, p2y, p3x, p3y, perpx, perpy, perp2x, perp2y, perp3x, perp3y, a1, b1, c1, a2, b2, c2, denom, pdist, dist, verts = webGLData.points, indices = webGLData.indices, length = points.length / 2, indexCount = points.length, indexStart = verts.length / 6, width = graphicsData.lineWidth / 2, color = PIXI.hex2rgb(graphicsData.lineColor), alpha = graphicsData.lineAlpha, r = color[0] * alpha, g = color[1] * alpha, b = color[2] * alpha;
                            for (p1x = points[0], p1y = points[1], p2x = points[2], p2y = points[3], perpx = -(p1y - p2y), 
                            perpy = p1x - p2x, dist = Math.sqrt(perpx * perpx + perpy * perpy), perpx /= dist, 
                            perpy /= dist, perpx *= width, perpy *= width, verts.push(p1x - perpx, p1y - perpy, r, g, b, alpha), 
                            verts.push(p1x + perpx, p1y + perpy, r, g, b, alpha), i = 1; length - 1 > i; i++) p1x = points[2 * (i - 1)], 
                            p1y = points[2 * (i - 1) + 1], p2x = points[2 * i], p2y = points[2 * i + 1], p3x = points[2 * (i + 1)], 
                            p3y = points[2 * (i + 1) + 1], perpx = -(p1y - p2y), perpy = p1x - p2x, dist = Math.sqrt(perpx * perpx + perpy * perpy), 
                            perpx /= dist, perpy /= dist, perpx *= width, perpy *= width, perp2x = -(p2y - p3y), 
                            perp2y = p2x - p3x, dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y), perp2x /= dist, 
                            perp2y /= dist, perp2x *= width, perp2y *= width, a1 = -perpy + p1y - (-perpy + p2y), 
                            b1 = -perpx + p2x - (-perpx + p1x), c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y), 
                            a2 = -perp2y + p3y - (-perp2y + p2y), b2 = -perp2x + p2x - (-perp2x + p3x), c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y), 
                            denom = a1 * b2 - a2 * b1, Math.abs(denom) < .1 ? (denom += 10.1, verts.push(p2x - perpx, p2y - perpy, r, g, b, alpha), 
                            verts.push(p2x + perpx, p2y + perpy, r, g, b, alpha)) : (px = (b1 * c2 - b2 * c1) / denom, 
                            py = (a2 * c1 - a1 * c2) / denom, pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y), 
                            pdist > 19600 ? (perp3x = perpx - perp2x, perp3y = perpy - perp2y, dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y), 
                            perp3x /= dist, perp3y /= dist, perp3x *= width, perp3y *= width, verts.push(p2x - perp3x, p2y - perp3y), 
                            verts.push(r, g, b, alpha), verts.push(p2x + perp3x, p2y + perp3y), verts.push(r, g, b, alpha), 
                            verts.push(p2x - perp3x, p2y - perp3y), verts.push(r, g, b, alpha), indexCount++) : (verts.push(px, py), 
                            verts.push(r, g, b, alpha), verts.push(p2x - (px - p2x), p2y - (py - p2y)), verts.push(r, g, b, alpha)));
                            for (p1x = points[2 * (length - 2)], p1y = points[2 * (length - 2) + 1], p2x = points[2 * (length - 1)], 
                            p2y = points[2 * (length - 1) + 1], perpx = -(p1y - p2y), perpy = p1x - p2x, dist = Math.sqrt(perpx * perpx + perpy * perpy), 
                            perpx /= dist, perpy /= dist, perpx *= width, perpy *= width, verts.push(p2x - perpx, p2y - perpy), 
                            verts.push(r, g, b, alpha), verts.push(p2x + perpx, p2y + perpy), verts.push(r, g, b, alpha), 
                            indices.push(indexStart), i = 0; indexCount > i; i++) indices.push(indexStart++);
                            indices.push(indexStart - 1);
                        }
                    }, PIXI.WebGLGraphics.buildComplexPoly = function(graphicsData, webGLData) {
                        var points = graphicsData.points.slice();
                        if (!(points.length < 6)) {
                            var indices = webGLData.indices;
                            webGLData.points = points, webGLData.alpha = graphicsData.fillAlpha, webGLData.color = PIXI.hex2rgb(graphicsData.fillColor);
                            for (var x, y, minX = 1 / 0, maxX = -(1 / 0), minY = 1 / 0, maxY = -(1 / 0), i = 0; i < points.length; i += 2) x = points[i], 
                            y = points[i + 1], minX = minX > x ? x : minX, maxX = x > maxX ? x : maxX, minY = minY > y ? y : minY, 
                            maxY = y > maxY ? y : maxY;
                            points.push(minX, minY, maxX, minY, maxX, maxY, minX, maxY);
                            var length = points.length / 2;
                            for (i = 0; length > i; i++) indices.push(i);
                        }
                    }, PIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData) {
                        var points = graphicsData.points;
                        if (!(points.length < 6)) {
                            var verts = webGLData.points, indices = webGLData.indices, length = points.length / 2, color = PIXI.hex2rgb(graphicsData.fillColor), alpha = graphicsData.fillAlpha, r = color[0] * alpha, g = color[1] * alpha, b = color[2] * alpha, triangles = PIXI.PolyK.Triangulate(points);
                            if (!triangles) return !1;
                            var vertPos = verts.length / 6, i = 0;
                            for (i = 0; i < triangles.length; i += 3) indices.push(triangles[i] + vertPos), 
                            indices.push(triangles[i] + vertPos), indices.push(triangles[i + 1] + vertPos), 
                            indices.push(triangles[i + 2] + vertPos), indices.push(triangles[i + 2] + vertPos);
                            for (i = 0; length > i; i++) verts.push(points[2 * i], points[2 * i + 1], r, g, b, alpha);
                            return !0;
                        }
                    }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(gl) {
                        this.gl = gl, this.color = [ 0, 0, 0 ], this.points = [], this.indices = [], this.buffer = gl.createBuffer(), 
                        this.indexBuffer = gl.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0;
                    }, PIXI.WebGLGraphicsData.prototype.reset = function() {
                        this.points = [], this.indices = [];
                    }, PIXI.WebGLGraphicsData.prototype.upload = function() {
                        var gl = this.gl;
                        this.glPoints = new PIXI.Float32Array(this.points), gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer), 
                        gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW), this.glIndicies = new PIXI.Uint16Array(this.indices), 
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndicies, gl.STATIC_DRAW), 
                        this.dirty = !1;
                    }, PIXI.glContexts = [], PIXI.instances = [], PIXI.WebGLRenderer = function(width, height, options) {
                        if (options) for (var i in PIXI.defaultRenderOptions) "undefined" == typeof options[i] && (options[i] = PIXI.defaultRenderOptions[i]); else options = PIXI.defaultRenderOptions;
                        PIXI.defaultRenderer || (PIXI.sayHello("webGL"), PIXI.defaultRenderer = this), this.type = PIXI.WEBGL_RENDERER, 
                        this.resolution = options.resolution, this.transparent = options.transparent, this.autoResize = options.autoResize || !1, 
                        this.preserveDrawingBuffer = options.preserveDrawingBuffer, this.clearBeforeRender = options.clearBeforeRender, 
                        this.width = width || 800, this.height = height || 600, this.view = options.view || document.createElement("canvas"), 
                        this.contextLostBound = this.handleContextLost.bind(this), this.contextRestoredBound = this.handleContextRestored.bind(this), 
                        this.view.addEventListener("webglcontextlost", this.contextLostBound, !1), this.view.addEventListener("webglcontextrestored", this.contextRestoredBound, !1), 
                        this._contextOptions = {
                            alpha: this.transparent,
                            antialias: options.antialias,
                            premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
                            stencil: !0,
                            preserveDrawingBuffer: options.preserveDrawingBuffer
                        }, this.projection = new PIXI.Point(), this.offset = new PIXI.Point(0, 0), this.shaderManager = new PIXI.WebGLShaderManager(), 
                        this.spriteBatch = new PIXI.WebGLSpriteBatch(), this.maskManager = new PIXI.WebGLMaskManager(), 
                        this.filterManager = new PIXI.WebGLFilterManager(), this.stencilManager = new PIXI.WebGLStencilManager(), 
                        this.blendModeManager = new PIXI.WebGLBlendModeManager(), this.renderSession = {}, 
                        this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, 
                        this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, 
                        this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, 
                        this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, 
                        this.renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes();
                    }, PIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer, PIXI.WebGLRenderer.prototype.initContext = function() {
                        var gl = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
                        if (this.gl = gl, !gl) throw new Error("This browser does not support webGL. Try using the canvas renderer");
                        this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId++, PIXI.glContexts[this.glContextId] = gl, 
                        PIXI.instances[this.glContextId] = this, gl.disable(gl.DEPTH_TEST), gl.disable(gl.CULL_FACE), 
                        gl.enable(gl.BLEND), this.shaderManager.setContext(gl), this.spriteBatch.setContext(gl), 
                        this.maskManager.setContext(gl), this.filterManager.setContext(gl), this.blendModeManager.setContext(gl), 
                        this.stencilManager.setContext(gl), this.renderSession.gl = this.gl, this.resize(this.width, this.height);
                    }, PIXI.WebGLRenderer.prototype.render = function(stage) {
                        if (!this.contextLost) {
                            this.__stage !== stage && (stage.interactive && stage.interactionManager.removeEvents(), 
                            this.__stage = stage), stage.updateTransform();
                            var gl = this.gl;
                            stage._interactive ? stage._interactiveEventsAdded || (stage._interactiveEventsAdded = !0, 
                            stage.interactionManager.setTarget(this)) : stage._interactiveEventsAdded && (stage._interactiveEventsAdded = !1, 
                            stage.interactionManager.setTarget(this)), gl.viewport(0, 0, this.width, this.height), 
                            gl.bindFramebuffer(gl.FRAMEBUFFER, null), this.clearBeforeRender && (this.transparent ? gl.clearColor(0, 0, 0, 0) : gl.clearColor(stage.backgroundColorSplit[0], stage.backgroundColorSplit[1], stage.backgroundColorSplit[2], 1), 
                            gl.clear(gl.COLOR_BUFFER_BIT)), this.renderDisplayObject(stage, this.projection);
                        }
                    }, PIXI.WebGLRenderer.prototype.renderDisplayObject = function(displayObject, projection, buffer) {
                        this.renderSession.blendModeManager.setBlendMode(PIXI.blendModes.NORMAL), this.renderSession.drawCount = 0, 
                        this.renderSession.flipY = buffer ? -1 : 1, this.renderSession.projection = projection, 
                        this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), 
                        this.filterManager.begin(this.renderSession, buffer), displayObject._renderWebGL(this.renderSession), 
                        this.spriteBatch.end();
                    }, PIXI.WebGLRenderer.prototype.resize = function(width, height) {
                        this.width = width * this.resolution, this.height = height * this.resolution, this.view.width = this.width, 
                        this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", 
                        this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), 
                        this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution;
                    }, PIXI.WebGLRenderer.prototype.updateTexture = function(texture) {
                        if (texture.hasLoaded) {
                            var gl = this.gl;
                            return texture._glTextures[gl.id] || (texture._glTextures[gl.id] = gl.createTexture()), 
                            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha), 
                            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source), 
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST), 
                            texture.mipmap && PIXI.isPowerOfTwo(texture.width, texture.height) ? (gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST), 
                            gl.generateMipmap(gl.TEXTURE_2D)) : gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST), 
                            texture._powerOf2 ? (gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT), 
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)) : (gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), 
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)), texture._dirty[gl.id] = !1, 
                            texture._glTextures[gl.id];
                        }
                    }, PIXI.WebGLRenderer.prototype.handleContextLost = function(event) {
                        event.preventDefault(), this.contextLost = !0;
                    }, PIXI.WebGLRenderer.prototype.handleContextRestored = function() {
                        this.initContext();
                        for (var key in PIXI.TextureCache) {
                            var texture = PIXI.TextureCache[key].baseTexture;
                            texture._glTextures = [];
                        }
                        this.contextLost = !1;
                    }, PIXI.WebGLRenderer.prototype.destroy = function() {
                        this.view.removeEventListener("webglcontextlost", this.contextLostBound), this.view.removeEventListener("webglcontextrestored", this.contextRestoredBound), 
                        PIXI.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, 
                        this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), 
                        this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, 
                        this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null;
                    }, PIXI.WebGLRenderer.prototype.mapBlendModes = function() {
                        var gl = this.gl;
                        PIXI.blendModesWebGL || (PIXI.blendModesWebGL = [], PIXI.blendModesWebGL[PIXI.blendModes.NORMAL] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.ADD] = [ gl.SRC_ALPHA, gl.DST_ALPHA ], PIXI.blendModesWebGL[PIXI.blendModes.MULTIPLY] = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.SCREEN] = [ gl.SRC_ALPHA, gl.ONE ], PIXI.blendModesWebGL[PIXI.blendModes.OVERLAY] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.DARKEN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.LIGHTEN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_DODGE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_BURN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.HARD_LIGHT] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.SOFT_LIGHT] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.DIFFERENCE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.EXCLUSION] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.HUE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.SATURATION] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.COLOR] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], 
                        PIXI.blendModesWebGL[PIXI.blendModes.LUMINOSITY] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ]);
                    }, PIXI.WebGLRenderer.glContextId = 0, PIXI.WebGLBlendModeManager = function() {
                        this.currentBlendMode = 99999;
                    }, PIXI.WebGLBlendModeManager.prototype.constructor = PIXI.WebGLBlendModeManager, 
                    PIXI.WebGLBlendModeManager.prototype.setContext = function(gl) {
                        this.gl = gl;
                    }, PIXI.WebGLBlendModeManager.prototype.setBlendMode = function(blendMode) {
                        if (this.currentBlendMode === blendMode) return !1;
                        this.currentBlendMode = blendMode;
                        var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];
                        return this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]), !0;
                    }, PIXI.WebGLBlendModeManager.prototype.destroy = function() {
                        this.gl = null;
                    }, PIXI.WebGLMaskManager = function() {}, PIXI.WebGLMaskManager.prototype.constructor = PIXI.WebGLMaskManager, 
                    PIXI.WebGLMaskManager.prototype.setContext = function(gl) {
                        this.gl = gl;
                    }, PIXI.WebGLMaskManager.prototype.pushMask = function(maskData, renderSession) {
                        var gl = renderSession.gl;
                        maskData.dirty && PIXI.WebGLGraphics.updateGraphics(maskData, gl), maskData._webGL[gl.id].data.length && renderSession.stencilManager.pushStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);
                    }, PIXI.WebGLMaskManager.prototype.popMask = function(maskData, renderSession) {
                        var gl = this.gl;
                        renderSession.stencilManager.popStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);
                    }, PIXI.WebGLMaskManager.prototype.destroy = function() {
                        this.gl = null;
                    }, PIXI.WebGLStencilManager = function() {
                        this.stencilStack = [], this.reverse = !0, this.count = 0;
                    }, PIXI.WebGLStencilManager.prototype.setContext = function(gl) {
                        this.gl = gl;
                    }, PIXI.WebGLStencilManager.prototype.pushStencil = function(graphics, webGLData, renderSession) {
                        var gl = this.gl;
                        this.bindGraphics(graphics, webGLData, renderSession), 0 === this.stencilStack.length && (gl.enable(gl.STENCIL_TEST), 
                        gl.clear(gl.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(webGLData);
                        var level = this.count;
                        gl.colorMask(!1, !1, !1, !1), gl.stencilFunc(gl.ALWAYS, 0, 255), gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT), 
                        1 === webGLData.mode ? (gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0), 
                        this.reverse ? (gl.stencilFunc(gl.EQUAL, 255 - level, 255), gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR)) : (gl.stencilFunc(gl.EQUAL, level, 255), 
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR)), gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, 2 * (webGLData.indices.length - 4)), 
                        this.reverse ? gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255) : gl.stencilFunc(gl.EQUAL, level + 1, 255), 
                        this.reverse = !this.reverse) : (this.reverse ? (gl.stencilFunc(gl.EQUAL, level, 255), 
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR)) : (gl.stencilFunc(gl.EQUAL, 255 - level, 255), 
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR)), gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0), 
                        this.reverse ? gl.stencilFunc(gl.EQUAL, level + 1, 255) : gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255)), 
                        gl.colorMask(!0, !0, !0, !0), gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP), this.count++;
                    }, PIXI.WebGLStencilManager.prototype.bindGraphics = function(graphics, webGLData, renderSession) {
                        this._currentGraphics = graphics;
                        var shader, gl = this.gl, projection = renderSession.projection, offset = renderSession.offset;
                        1 === webGLData.mode ? (shader = renderSession.shaderManager.complexPrimitiveShader, 
                        renderSession.shaderManager.setShader(shader), gl.uniform1f(shader.flipY, renderSession.flipY), 
                        gl.uniformMatrix3fv(shader.translationMatrix, !1, graphics.worldTransform.toArray(!0)), 
                        gl.uniform2f(shader.projectionVector, projection.x, -projection.y), gl.uniform2f(shader.offsetVector, -offset.x, -offset.y), 
                        gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint)), gl.uniform3fv(shader.color, webGLData.color), 
                        gl.uniform1f(shader.alpha, graphics.worldAlpha * webGLData.alpha), gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer), 
                        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, !1, 8, 0), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer)) : (shader = renderSession.shaderManager.primitiveShader, 
                        renderSession.shaderManager.setShader(shader), gl.uniformMatrix3fv(shader.translationMatrix, !1, graphics.worldTransform.toArray(!0)), 
                        gl.uniform1f(shader.flipY, renderSession.flipY), gl.uniform2f(shader.projectionVector, projection.x, -projection.y), 
                        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y), gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint)), 
                        gl.uniform1f(shader.alpha, graphics.worldAlpha), gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer), 
                        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, !1, 24, 0), gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, !1, 24, 8), 
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer));
                    }, PIXI.WebGLStencilManager.prototype.popStencil = function(graphics, webGLData, renderSession) {
                        var gl = this.gl;
                        if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) gl.disable(gl.STENCIL_TEST); else {
                            var level = this.count;
                            this.bindGraphics(graphics, webGLData, renderSession), gl.colorMask(!1, !1, !1, !1), 
                            1 === webGLData.mode ? (this.reverse = !this.reverse, this.reverse ? (gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255), 
                            gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR)) : (gl.stencilFunc(gl.EQUAL, level + 1, 255), 
                            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR)), gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, 2 * (webGLData.indices.length - 4)), 
                            gl.stencilFunc(gl.ALWAYS, 0, 255), gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT), gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0), 
                            this.reverse ? gl.stencilFunc(gl.EQUAL, level, 255) : gl.stencilFunc(gl.EQUAL, 255 - level, 255)) : (this.reverse ? (gl.stencilFunc(gl.EQUAL, level + 1, 255), 
                            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR)) : (gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255), 
                            gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR)), gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0), 
                            this.reverse ? gl.stencilFunc(gl.EQUAL, level, 255) : gl.stencilFunc(gl.EQUAL, 255 - level, 255)), 
                            gl.colorMask(!0, !0, !0, !0), gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                        }
                    }, PIXI.WebGLStencilManager.prototype.destroy = function() {
                        this.stencilStack = null, this.gl = null;
                    }, PIXI.WebGLShaderManager = function() {
                        this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
                        for (var i = 0; i < this.maxAttibs; i++) this.attribState[i] = !1;
                        this.stack = [];
                    }, PIXI.WebGLShaderManager.prototype.constructor = PIXI.WebGLShaderManager, PIXI.WebGLShaderManager.prototype.setContext = function(gl) {
                        this.gl = gl, this.primitiveShader = new PIXI.PrimitiveShader(gl), this.complexPrimitiveShader = new PIXI.ComplexPrimitiveShader(gl), 
                        this.defaultShader = new PIXI.PixiShader(gl), this.fastShader = new PIXI.PixiFastShader(gl), 
                        this.stripShader = new PIXI.StripShader(gl), this.setShader(this.defaultShader);
                    }, PIXI.WebGLShaderManager.prototype.setAttribs = function(attribs) {
                        var i;
                        for (i = 0; i < this.tempAttribState.length; i++) this.tempAttribState[i] = !1;
                        for (i = 0; i < attribs.length; i++) {
                            var attribId = attribs[i];
                            this.tempAttribState[attribId] = !0;
                        }
                        var gl = this.gl;
                        for (i = 0; i < this.attribState.length; i++) this.attribState[i] !== this.tempAttribState[i] && (this.attribState[i] = this.tempAttribState[i], 
                        this.tempAttribState[i] ? gl.enableVertexAttribArray(i) : gl.disableVertexAttribArray(i));
                    }, PIXI.WebGLShaderManager.prototype.setShader = function(shader) {
                        return this._currentId === shader._UID ? !1 : (this._currentId = shader._UID, this.currentShader = shader, 
                        this.gl.useProgram(shader.program), this.setAttribs(shader.attributes), !0);
                    }, PIXI.WebGLShaderManager.prototype.destroy = function() {
                        this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), 
                        this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), 
                        this.stripShader.destroy(), this.gl = null;
                    }, PIXI.WebGLSpriteBatch = function() {
                        this.vertSize = 5, this.size = 2e3;
                        var numVerts = 4 * this.size * 4 * this.vertSize, numIndices = 6 * this.size;
                        this.vertices = new PIXI.ArrayBuffer(numVerts), this.positions = new PIXI.Float32Array(this.vertices), 
                        this.colors = new PIXI.Uint32Array(this.vertices), this.indices = new PIXI.Uint16Array(numIndices), 
                        this.lastIndexCount = 0;
                        for (var i = 0, j = 0; numIndices > i; i += 6, j += 4) this.indices[i + 0] = j + 0, 
                        this.indices[i + 1] = j + 1, this.indices[i + 2] = j + 2, this.indices[i + 3] = j + 0, 
                        this.indices[i + 4] = j + 2, this.indices[i + 5] = j + 3;
                        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, 
                        this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], 
                        this.defaultShader = new PIXI.AbstractFilter([ "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ]);
                    }, PIXI.WebGLSpriteBatch.prototype.setContext = function(gl) {
                        this.gl = gl, this.vertexBuffer = gl.createBuffer(), this.indexBuffer = gl.createBuffer(), 
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW), 
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer), gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW), 
                        this.currentBlendMode = 99999;
                        var shader = new PIXI.PixiShader(gl);
                        shader.fragmentSrc = this.defaultShader.fragmentSrc, shader.uniforms = {}, shader.init(), 
                        this.defaultShader.shaders[gl.id] = shader;
                    }, PIXI.WebGLSpriteBatch.prototype.begin = function(renderSession) {
                        this.renderSession = renderSession, this.shader = this.renderSession.shaderManager.defaultShader, 
                        this.start();
                    }, PIXI.WebGLSpriteBatch.prototype.end = function() {
                        this.flush();
                    }, PIXI.WebGLSpriteBatch.prototype.render = function(sprite) {
                        var texture = sprite.texture;
                        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = texture.baseTexture);
                        var uvs = texture._uvs;
                        if (uvs) {
                            var w0, w1, h0, h1, aX = sprite.anchor.x, aY = sprite.anchor.y;
                            if (texture.trim) {
                                var trim = texture.trim;
                                w1 = trim.x - aX * trim.width, w0 = w1 + texture.crop.width, h1 = trim.y - aY * trim.height, 
                                h0 = h1 + texture.crop.height;
                            } else w0 = texture.frame.width * (1 - aX), w1 = texture.frame.width * -aX, h0 = texture.frame.height * (1 - aY), 
                            h1 = texture.frame.height * -aY;
                            var index = 4 * this.currentBatchSize * this.vertSize, resolution = texture.baseTexture.resolution, worldTransform = sprite.worldTransform, a = worldTransform.a / resolution, b = worldTransform.b / resolution, c = worldTransform.c / resolution, d = worldTransform.d / resolution, tx = worldTransform.tx, ty = worldTransform.ty, colors = this.colors, positions = this.positions;
                            this.renderSession.roundPixels ? (positions[index] = a * w1 + c * h1 + tx | 0, positions[index + 1] = d * h1 + b * w1 + ty | 0, 
                            positions[index + 5] = a * w0 + c * h1 + tx | 0, positions[index + 6] = d * h1 + b * w0 + ty | 0, 
                            positions[index + 10] = a * w0 + c * h0 + tx | 0, positions[index + 11] = d * h0 + b * w0 + ty | 0, 
                            positions[index + 15] = a * w1 + c * h0 + tx | 0, positions[index + 16] = d * h0 + b * w1 + ty | 0) : (positions[index] = a * w1 + c * h1 + tx, 
                            positions[index + 1] = d * h1 + b * w1 + ty, positions[index + 5] = a * w0 + c * h1 + tx, 
                            positions[index + 6] = d * h1 + b * w0 + ty, positions[index + 10] = a * w0 + c * h0 + tx, 
                            positions[index + 11] = d * h0 + b * w0 + ty, positions[index + 15] = a * w1 + c * h0 + tx, 
                            positions[index + 16] = d * h0 + b * w1 + ty), positions[index + 2] = uvs.x0, positions[index + 3] = uvs.y0, 
                            positions[index + 7] = uvs.x1, positions[index + 8] = uvs.y1, positions[index + 12] = uvs.x2, 
                            positions[index + 13] = uvs.y2, positions[index + 17] = uvs.x3, positions[index + 18] = uvs.y3;
                            var tint = sprite.tint;
                            colors[index + 4] = colors[index + 9] = colors[index + 14] = colors[index + 19] = (tint >> 16) + (65280 & tint) + ((255 & tint) << 16) + (255 * sprite.worldAlpha << 24), 
                            this.sprites[this.currentBatchSize++] = sprite;
                        }
                    }, PIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function(tilingSprite) {
                        var texture = tilingSprite.tilingTexture;
                        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = texture.baseTexture), 
                        tilingSprite._uvs || (tilingSprite._uvs = new PIXI.TextureUvs());
                        var uvs = tilingSprite._uvs;
                        tilingSprite.tilePosition.x %= texture.baseTexture.width * tilingSprite.tileScaleOffset.x, 
                        tilingSprite.tilePosition.y %= texture.baseTexture.height * tilingSprite.tileScaleOffset.y;
                        var offsetX = tilingSprite.tilePosition.x / (texture.baseTexture.width * tilingSprite.tileScaleOffset.x), offsetY = tilingSprite.tilePosition.y / (texture.baseTexture.height * tilingSprite.tileScaleOffset.y), scaleX = tilingSprite.width / texture.baseTexture.width / (tilingSprite.tileScale.x * tilingSprite.tileScaleOffset.x), scaleY = tilingSprite.height / texture.baseTexture.height / (tilingSprite.tileScale.y * tilingSprite.tileScaleOffset.y);
                        uvs.x0 = 0 - offsetX, uvs.y0 = 0 - offsetY, uvs.x1 = 1 * scaleX - offsetX, uvs.y1 = 0 - offsetY, 
                        uvs.x2 = 1 * scaleX - offsetX, uvs.y2 = 1 * scaleY - offsetY, uvs.x3 = 0 - offsetX, 
                        uvs.y3 = 1 * scaleY - offsetY;
                        var tint = tilingSprite.tint, color = (tint >> 16) + (65280 & tint) + ((255 & tint) << 16) + (255 * tilingSprite.alpha << 24), positions = this.positions, colors = this.colors, width = tilingSprite.width, height = tilingSprite.height, aX = tilingSprite.anchor.x, aY = tilingSprite.anchor.y, w0 = width * (1 - aX), w1 = width * -aX, h0 = height * (1 - aY), h1 = height * -aY, index = 4 * this.currentBatchSize * this.vertSize, resolution = texture.baseTexture.resolution, worldTransform = tilingSprite.worldTransform, a = worldTransform.a / resolution, b = worldTransform.b / resolution, c = worldTransform.c / resolution, d = worldTransform.d / resolution, tx = worldTransform.tx, ty = worldTransform.ty;
                        positions[index++] = a * w1 + c * h1 + tx, positions[index++] = d * h1 + b * w1 + ty, 
                        positions[index++] = uvs.x0, positions[index++] = uvs.y0, colors[index++] = color, 
                        positions[index++] = a * w0 + c * h1 + tx, positions[index++] = d * h1 + b * w0 + ty, 
                        positions[index++] = uvs.x1, positions[index++] = uvs.y1, colors[index++] = color, 
                        positions[index++] = a * w0 + c * h0 + tx, positions[index++] = d * h0 + b * w0 + ty, 
                        positions[index++] = uvs.x2, positions[index++] = uvs.y2, colors[index++] = color, 
                        positions[index++] = a * w1 + c * h0 + tx, positions[index++] = d * h0 + b * w1 + ty, 
                        positions[index++] = uvs.x3, positions[index++] = uvs.y3, colors[index++] = color, 
                        this.sprites[this.currentBatchSize++] = tilingSprite;
                    }, PIXI.WebGLSpriteBatch.prototype.flush = function() {
                        if (0 !== this.currentBatchSize) {
                            var shader, gl = this.gl;
                            if (this.dirty) {
                                this.dirty = !1, gl.activeTexture(gl.TEXTURE0), gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer), 
                                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer), shader = this.defaultShader.shaders[gl.id];
                                var stride = 4 * this.vertSize;
                                gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, !1, stride, 0), gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, !1, stride, 8), 
                                gl.vertexAttribPointer(shader.colorAttribute, 4, gl.UNSIGNED_BYTE, !0, stride, 16);
                            }
                            if (this.currentBatchSize > .5 * this.size) gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices); else {
                                var view = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                                gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
                            }
                            for (var nextTexture, nextBlendMode, nextShader, sprite, batchSize = 0, start = 0, currentBaseTexture = null, currentBlendMode = this.renderSession.blendModeManager.currentBlendMode, currentShader = null, blendSwap = !1, shaderSwap = !1, i = 0, j = this.currentBatchSize; j > i; i++) {
                                if (sprite = this.sprites[i], nextTexture = sprite.texture.baseTexture, nextBlendMode = sprite.blendMode, 
                                nextShader = sprite.shader || this.defaultShader, blendSwap = currentBlendMode !== nextBlendMode, 
                                shaderSwap = currentShader !== nextShader, (currentBaseTexture !== nextTexture || blendSwap || shaderSwap) && (this.renderBatch(currentBaseTexture, batchSize, start), 
                                start = i, batchSize = 0, currentBaseTexture = nextTexture, blendSwap && (currentBlendMode = nextBlendMode, 
                                this.renderSession.blendModeManager.setBlendMode(currentBlendMode)), shaderSwap)) {
                                    currentShader = nextShader, shader = currentShader.shaders[gl.id], shader || (shader = new PIXI.PixiShader(gl), 
                                    shader.fragmentSrc = currentShader.fragmentSrc, shader.uniforms = currentShader.uniforms, 
                                    shader.init(), currentShader.shaders[gl.id] = shader), this.renderSession.shaderManager.setShader(shader), 
                                    shader.dirty && shader.syncUniforms();
                                    var projection = this.renderSession.projection;
                                    gl.uniform2f(shader.projectionVector, projection.x, projection.y);
                                    var offsetVector = this.renderSession.offset;
                                    gl.uniform2f(shader.offsetVector, offsetVector.x, offsetVector.y);
                                }
                                batchSize++;
                            }
                            this.renderBatch(currentBaseTexture, batchSize, start), this.currentBatchSize = 0;
                        }
                    }, PIXI.WebGLSpriteBatch.prototype.renderBatch = function(texture, size, startIndex) {
                        if (0 !== size) {
                            var gl = this.gl;
                            texture._dirty[gl.id] ? this.renderSession.renderer.updateTexture(texture) : gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]), 
                            gl.drawElements(gl.TRIANGLES, 6 * size, gl.UNSIGNED_SHORT, 6 * startIndex * 2), 
                            this.renderSession.drawCount++;
                        }
                    }, PIXI.WebGLSpriteBatch.prototype.stop = function() {
                        this.flush(), this.dirty = !0;
                    }, PIXI.WebGLSpriteBatch.prototype.start = function() {
                        this.dirty = !0;
                    }, PIXI.WebGLSpriteBatch.prototype.destroy = function() {
                        this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), 
                        this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null;
                    }, PIXI.WebGLFastSpriteBatch = function(gl) {
                        this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
                        var numVerts = 4 * this.size * this.vertSize, numIndices = 6 * this.maxSize;
                        this.vertices = new PIXI.Float32Array(numVerts), this.indices = new PIXI.Uint16Array(numIndices), 
                        this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
                        for (var i = 0, j = 0; numIndices > i; i += 6, j += 4) this.indices[i + 0] = j + 0, 
                        this.indices[i + 1] = j + 1, this.indices[i + 2] = j + 2, this.indices[i + 3] = j + 0, 
                        this.indices[i + 4] = j + 2, this.indices[i + 5] = j + 3;
                        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, 
                        this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(gl);
                    }, PIXI.WebGLFastSpriteBatch.prototype.constructor = PIXI.WebGLFastSpriteBatch, 
                    PIXI.WebGLFastSpriteBatch.prototype.setContext = function(gl) {
                        this.gl = gl, this.vertexBuffer = gl.createBuffer(), this.indexBuffer = gl.createBuffer(), 
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW), 
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer), gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
                    }, PIXI.WebGLFastSpriteBatch.prototype.begin = function(spriteBatch, renderSession) {
                        this.renderSession = renderSession, this.shader = this.renderSession.shaderManager.fastShader, 
                        this.matrix = spriteBatch.worldTransform.toArray(!0), this.start();
                    }, PIXI.WebGLFastSpriteBatch.prototype.end = function() {
                        this.flush();
                    }, PIXI.WebGLFastSpriteBatch.prototype.render = function(spriteBatch) {
                        var children = spriteBatch.children, sprite = children[0];
                        if (sprite.texture._uvs) {
                            this.currentBaseTexture = sprite.texture.baseTexture, sprite.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), 
                            this.renderSession.blendModeManager.setBlendMode(sprite.blendMode));
                            for (var i = 0, j = children.length; j > i; i++) this.renderSprite(children[i]);
                            this.flush();
                        }
                    }, PIXI.WebGLFastSpriteBatch.prototype.renderSprite = function(sprite) {
                        if (sprite.visible && (sprite.texture.baseTexture === this.currentBaseTexture || (this.flush(), 
                        this.currentBaseTexture = sprite.texture.baseTexture, sprite.texture._uvs))) {
                            var uvs, width, height, w0, w1, h0, h1, index, vertices = this.vertices;
                            if (uvs = sprite.texture._uvs, width = sprite.texture.frame.width, height = sprite.texture.frame.height, 
                            sprite.texture.trim) {
                                var trim = sprite.texture.trim;
                                w1 = trim.x - sprite.anchor.x * trim.width, w0 = w1 + sprite.texture.crop.width, 
                                h1 = trim.y - sprite.anchor.y * trim.height, h0 = h1 + sprite.texture.crop.height;
                            } else w0 = sprite.texture.frame.width * (1 - sprite.anchor.x), w1 = sprite.texture.frame.width * -sprite.anchor.x, 
                            h0 = sprite.texture.frame.height * (1 - sprite.anchor.y), h1 = sprite.texture.frame.height * -sprite.anchor.y;
                            index = 4 * this.currentBatchSize * this.vertSize, vertices[index++] = w1, vertices[index++] = h1, 
                            vertices[index++] = sprite.position.x, vertices[index++] = sprite.position.y, vertices[index++] = sprite.scale.x, 
                            vertices[index++] = sprite.scale.y, vertices[index++] = sprite.rotation, vertices[index++] = uvs.x0, 
                            vertices[index++] = uvs.y1, vertices[index++] = sprite.alpha, vertices[index++] = w0, 
                            vertices[index++] = h1, vertices[index++] = sprite.position.x, vertices[index++] = sprite.position.y, 
                            vertices[index++] = sprite.scale.x, vertices[index++] = sprite.scale.y, vertices[index++] = sprite.rotation, 
                            vertices[index++] = uvs.x1, vertices[index++] = uvs.y1, vertices[index++] = sprite.alpha, 
                            vertices[index++] = w0, vertices[index++] = h0, vertices[index++] = sprite.position.x, 
                            vertices[index++] = sprite.position.y, vertices[index++] = sprite.scale.x, vertices[index++] = sprite.scale.y, 
                            vertices[index++] = sprite.rotation, vertices[index++] = uvs.x2, vertices[index++] = uvs.y2, 
                            vertices[index++] = sprite.alpha, vertices[index++] = w1, vertices[index++] = h0, 
                            vertices[index++] = sprite.position.x, vertices[index++] = sprite.position.y, vertices[index++] = sprite.scale.x, 
                            vertices[index++] = sprite.scale.y, vertices[index++] = sprite.rotation, vertices[index++] = uvs.x3, 
                            vertices[index++] = uvs.y3, vertices[index++] = sprite.alpha, this.currentBatchSize++, 
                            this.currentBatchSize >= this.size && this.flush();
                        }
                    }, PIXI.WebGLFastSpriteBatch.prototype.flush = function() {
                        if (0 !== this.currentBatchSize) {
                            var gl = this.gl;
                            if (this.currentBaseTexture._glTextures[gl.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, gl), 
                            gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]), this.currentBatchSize > .5 * this.size) gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices); else {
                                var view = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                                gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
                            }
                            gl.drawElements(gl.TRIANGLES, 6 * this.currentBatchSize, gl.UNSIGNED_SHORT, 0), 
                            this.currentBatchSize = 0, this.renderSession.drawCount++;
                        }
                    }, PIXI.WebGLFastSpriteBatch.prototype.stop = function() {
                        this.flush();
                    }, PIXI.WebGLFastSpriteBatch.prototype.start = function() {
                        var gl = this.gl;
                        gl.activeTexture(gl.TEXTURE0), gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer), 
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                        var projection = this.renderSession.projection;
                        gl.uniform2f(this.shader.projectionVector, projection.x, projection.y), gl.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
                        var stride = 4 * this.vertSize;
                        gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, !1, stride, 0), 
                        gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, !1, stride, 8), 
                        gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, !1, stride, 16), gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, !1, stride, 24), 
                        gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, !1, stride, 28), 
                        gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, !1, stride, 36);
                    }, PIXI.WebGLFilterManager = function() {
                        this.filterStack = [], this.offsetX = 0, this.offsetY = 0;
                    }, PIXI.WebGLFilterManager.prototype.constructor = PIXI.WebGLFilterManager, PIXI.WebGLFilterManager.prototype.setContext = function(gl) {
                        this.gl = gl, this.texturePool = [], this.initShaderBuffers();
                    }, PIXI.WebGLFilterManager.prototype.begin = function(renderSession, buffer) {
                        this.renderSession = renderSession, this.defaultShader = renderSession.shaderManager.defaultShader;
                        var projection = this.renderSession.projection;
                        this.width = 2 * projection.x, this.height = 2 * -projection.y, this.buffer = buffer;
                    }, PIXI.WebGLFilterManager.prototype.pushFilter = function(filterBlock) {
                        var gl = this.gl, projection = this.renderSession.projection, offset = this.renderSession.offset;
                        filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds(), 
                        this.filterStack.push(filterBlock);
                        var filter = filterBlock.filterPasses[0];
                        this.offsetX += filterBlock._filterArea.x, this.offsetY += filterBlock._filterArea.y;
                        var texture = this.texturePool.pop();
                        texture ? texture.resize(this.width, this.height) : texture = new PIXI.FilterTexture(this.gl, this.width, this.height), 
                        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
                        var filterArea = filterBlock._filterArea, padding = filter.padding;
                        filterArea.x -= padding, filterArea.y -= padding, filterArea.width += 2 * padding, 
                        filterArea.height += 2 * padding, filterArea.x < 0 && (filterArea.x = 0), filterArea.width > this.width && (filterArea.width = this.width), 
                        filterArea.y < 0 && (filterArea.y = 0), filterArea.height > this.height && (filterArea.height = this.height), 
                        gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer), gl.viewport(0, 0, filterArea.width, filterArea.height), 
                        projection.x = filterArea.width / 2, projection.y = -filterArea.height / 2, offset.x = -filterArea.x, 
                        offset.y = -filterArea.y, gl.colorMask(!0, !0, !0, !0), gl.clearColor(0, 0, 0, 0), 
                        gl.clear(gl.COLOR_BUFFER_BIT), filterBlock._glFilterTexture = texture;
                    }, PIXI.WebGLFilterManager.prototype.popFilter = function() {
                        var gl = this.gl, filterBlock = this.filterStack.pop(), filterArea = filterBlock._filterArea, texture = filterBlock._glFilterTexture, projection = this.renderSession.projection, offset = this.renderSession.offset;
                        if (filterBlock.filterPasses.length > 1) {
                            gl.viewport(0, 0, filterArea.width, filterArea.height), gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer), 
                            this.vertexArray[0] = 0, this.vertexArray[1] = filterArea.height, this.vertexArray[2] = filterArea.width, 
                            this.vertexArray[3] = filterArea.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, 
                            this.vertexArray[6] = filterArea.width, this.vertexArray[7] = 0, gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray), 
                            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = filterArea.width / this.width, 
                            this.uvArray[5] = filterArea.height / this.height, this.uvArray[6] = filterArea.width / this.width, 
                            this.uvArray[7] = filterArea.height / this.height, gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);
                            var inputTexture = texture, outputTexture = this.texturePool.pop();
                            outputTexture || (outputTexture = new PIXI.FilterTexture(this.gl, this.width, this.height)), 
                            outputTexture.resize(this.width, this.height), gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer), 
                            gl.clear(gl.COLOR_BUFFER_BIT), gl.disable(gl.BLEND);
                            for (var i = 0; i < filterBlock.filterPasses.length - 1; i++) {
                                var filterPass = filterBlock.filterPasses[i];
                                gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer), gl.activeTexture(gl.TEXTURE0), 
                                gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture), this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height);
                                var temp = inputTexture;
                                inputTexture = outputTexture, outputTexture = temp;
                            }
                            gl.enable(gl.BLEND), texture = inputTexture, this.texturePool.push(outputTexture);
                        }
                        var filter = filterBlock.filterPasses[filterBlock.filterPasses.length - 1];
                        this.offsetX -= filterArea.x, this.offsetY -= filterArea.y;
                        var sizeX = this.width, sizeY = this.height, offsetX = 0, offsetY = 0, buffer = this.buffer;
                        if (0 === this.filterStack.length) gl.colorMask(!0, !0, !0, !0); else {
                            var currentFilter = this.filterStack[this.filterStack.length - 1];
                            filterArea = currentFilter._filterArea, sizeX = filterArea.width, sizeY = filterArea.height, 
                            offsetX = filterArea.x, offsetY = filterArea.y, buffer = currentFilter._glFilterTexture.frameBuffer;
                        }
                        projection.x = sizeX / 2, projection.y = -sizeY / 2, offset.x = offsetX, offset.y = offsetY, 
                        filterArea = filterBlock._filterArea;
                        var x = filterArea.x - offsetX, y = filterArea.y - offsetY;
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = x, this.vertexArray[1] = y + filterArea.height, 
                        this.vertexArray[2] = x + filterArea.width, this.vertexArray[3] = y + filterArea.height, 
                        this.vertexArray[4] = x, this.vertexArray[5] = y, this.vertexArray[6] = x + filterArea.width, 
                        this.vertexArray[7] = y, gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray), 
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = filterArea.width / this.width, 
                        this.uvArray[5] = filterArea.height / this.height, this.uvArray[6] = filterArea.width / this.width, 
                        this.uvArray[7] = filterArea.height / this.height, gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray), 
                        gl.viewport(0, 0, sizeX, sizeY), gl.bindFramebuffer(gl.FRAMEBUFFER, buffer), gl.activeTexture(gl.TEXTURE0), 
                        gl.bindTexture(gl.TEXTURE_2D, texture.texture), this.applyFilterPass(filter, filterArea, sizeX, sizeY), 
                        this.texturePool.push(texture), filterBlock._glFilterTexture = null;
                    }, PIXI.WebGLFilterManager.prototype.applyFilterPass = function(filter, filterArea, width, height) {
                        var gl = this.gl, shader = filter.shaders[gl.id];
                        shader || (shader = new PIXI.PixiShader(gl), shader.fragmentSrc = filter.fragmentSrc, 
                        shader.uniforms = filter.uniforms, shader.init(), filter.shaders[gl.id] = shader), 
                        this.renderSession.shaderManager.setShader(shader), gl.uniform2f(shader.projectionVector, width / 2, -height / 2), 
                        gl.uniform2f(shader.offsetVector, 0, 0), filter.uniforms.dimensions && (filter.uniforms.dimensions.value[0] = this.width, 
                        filter.uniforms.dimensions.value[1] = this.height, filter.uniforms.dimensions.value[2] = this.vertexArray[0], 
                        filter.uniforms.dimensions.value[3] = this.vertexArray[5]), shader.syncUniforms(), 
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer), gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, !1, 0, 0), 
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer), gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, !1, 0, 0), 
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer), gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, !1, 0, 0), 
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer), gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0), 
                        this.renderSession.drawCount++;
                    }, PIXI.WebGLFilterManager.prototype.initShaderBuffers = function() {
                        var gl = this.gl;
                        this.vertexBuffer = gl.createBuffer(), this.uvBuffer = gl.createBuffer(), this.colorBuffer = gl.createBuffer(), 
                        this.indexBuffer = gl.createBuffer(), this.vertexArray = new PIXI.Float32Array([ 0, 0, 1, 0, 0, 1, 1, 1 ]), 
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer), gl.bufferData(gl.ARRAY_BUFFER, this.vertexArray, gl.STATIC_DRAW), 
                        this.uvArray = new PIXI.Float32Array([ 0, 0, 1, 0, 0, 1, 1, 1 ]), gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer), 
                        gl.bufferData(gl.ARRAY_BUFFER, this.uvArray, gl.STATIC_DRAW), this.colorArray = new PIXI.Float32Array([ 1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215 ]), 
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer), gl.bufferData(gl.ARRAY_BUFFER, this.colorArray, gl.STATIC_DRAW), 
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([ 0, 1, 2, 1, 3, 2 ]), gl.STATIC_DRAW);
                    }, PIXI.WebGLFilterManager.prototype.destroy = function() {
                        var gl = this.gl;
                        this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
                        for (var i = 0; i < this.texturePool.length; i++) this.texturePool[i].destroy();
                        this.texturePool = null, gl.deleteBuffer(this.vertexBuffer), gl.deleteBuffer(this.uvBuffer), 
                        gl.deleteBuffer(this.colorBuffer), gl.deleteBuffer(this.indexBuffer);
                    }, PIXI.FilterTexture = function(gl, width, height, scaleMode) {
                        this.gl = gl, this.frameBuffer = gl.createFramebuffer(), this.texture = gl.createTexture(), 
                        scaleMode = scaleMode || PIXI.scaleModes.DEFAULT, gl.bindTexture(gl.TEXTURE_2D, this.texture), 
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST), 
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST), 
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), 
                        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer), gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer), 
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0), 
                        this.renderBuffer = gl.createRenderbuffer(), gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer), 
                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer), 
                        this.resize(width, height);
                    }, PIXI.FilterTexture.prototype.constructor = PIXI.FilterTexture, PIXI.FilterTexture.prototype.clear = function() {
                        var gl = this.gl;
                        gl.clearColor(0, 0, 0, 0), gl.clear(gl.COLOR_BUFFER_BIT);
                    }, PIXI.FilterTexture.prototype.resize = function(width, height) {
                        if (this.width !== width || this.height !== height) {
                            this.width = width, this.height = height;
                            var gl = this.gl;
                            gl.bindTexture(gl.TEXTURE_2D, this.texture), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null), 
                            gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer), gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
                        }
                    }, PIXI.FilterTexture.prototype.destroy = function() {
                        var gl = this.gl;
                        gl.deleteFramebuffer(this.frameBuffer), gl.deleteTexture(this.texture), this.frameBuffer = null, 
                        this.texture = null;
                    }, PIXI.CanvasBuffer = function(width, height) {
                        this.width = width, this.height = height, this.canvas = document.createElement("canvas"), 
                        this.context = this.canvas.getContext("2d"), this.canvas.width = width, this.canvas.height = height;
                    }, PIXI.CanvasBuffer.prototype.constructor = PIXI.CanvasBuffer, PIXI.CanvasBuffer.prototype.clear = function() {
                        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height);
                    }, PIXI.CanvasBuffer.prototype.resize = function(width, height) {
                        this.width = this.canvas.width = width, this.height = this.canvas.height = height;
                    }, PIXI.CanvasMaskManager = function() {}, PIXI.CanvasMaskManager.prototype.constructor = PIXI.CanvasMaskManager, 
                    PIXI.CanvasMaskManager.prototype.pushMask = function(maskData, renderSession) {
                        var context = renderSession.context;
                        context.save();
                        var cacheAlpha = maskData.alpha, transform = maskData.worldTransform, resolution = renderSession.resolution;
                        context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution), 
                        PIXI.CanvasGraphics.renderGraphicsMask(maskData, context), context.clip(), maskData.worldAlpha = cacheAlpha;
                    }, PIXI.CanvasMaskManager.prototype.popMask = function(renderSession) {
                        renderSession.context.restore();
                    }, PIXI.CanvasTinter = function() {}, PIXI.CanvasTinter.getTintedTexture = function(sprite, color) {
                        var texture = sprite.texture;
                        color = PIXI.CanvasTinter.roundColor(color);
                        var stringColor = "#" + ("00000" + (0 | color).toString(16)).substr(-6);
                        if (texture.tintCache = texture.tintCache || {}, texture.tintCache[stringColor]) return texture.tintCache[stringColor];
                        var canvas = PIXI.CanvasTinter.canvas || document.createElement("canvas");
                        if (PIXI.CanvasTinter.tintMethod(texture, color, canvas), PIXI.CanvasTinter.convertTintToImage) {
                            var tintImage = new Image();
                            tintImage.src = canvas.toDataURL(), texture.tintCache[stringColor] = tintImage;
                        } else texture.tintCache[stringColor] = canvas, PIXI.CanvasTinter.canvas = null;
                        return canvas;
                    }, PIXI.CanvasTinter.tintWithMultiply = function(texture, color, canvas) {
                        var context = canvas.getContext("2d"), crop = texture.crop;
                        canvas.width = crop.width, canvas.height = crop.height, context.fillStyle = "#" + ("00000" + (0 | color).toString(16)).substr(-6), 
                        context.fillRect(0, 0, crop.width, crop.height), context.globalCompositeOperation = "multiply", 
                        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height), 
                        context.globalCompositeOperation = "destination-atop", context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
                    }, PIXI.CanvasTinter.tintWithOverlay = function(texture, color, canvas) {
                        var context = canvas.getContext("2d"), crop = texture.crop;
                        canvas.width = crop.width, canvas.height = crop.height, context.globalCompositeOperation = "copy", 
                        context.fillStyle = "#" + ("00000" + (0 | color).toString(16)).substr(-6), context.fillRect(0, 0, crop.width, crop.height), 
                        context.globalCompositeOperation = "destination-atop", context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
                    }, PIXI.CanvasTinter.tintWithPerPixel = function(texture, color, canvas) {
                        var context = canvas.getContext("2d"), crop = texture.crop;
                        canvas.width = crop.width, canvas.height = crop.height, context.globalCompositeOperation = "copy", 
                        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
                        for (var rgbValues = PIXI.hex2rgb(color), r = rgbValues[0], g = rgbValues[1], b = rgbValues[2], pixelData = context.getImageData(0, 0, crop.width, crop.height), pixels = pixelData.data, i = 0; i < pixels.length; i += 4) if (pixels[i + 0] *= r, 
                        pixels[i + 1] *= g, pixels[i + 2] *= b, !PIXI.CanvasTinter.canHandleAlpha) {
                            var alpha = pixels[i + 3];
                            pixels[i + 0] /= 255 / alpha, pixels[i + 1] /= 255 / alpha, pixels[i + 2] /= 255 / alpha;
                        }
                        context.putImageData(pixelData, 0, 0);
                    }, PIXI.CanvasTinter.roundColor = function(color) {
                        var step = PIXI.CanvasTinter.cacheStepsPerColorChannel, rgbValues = PIXI.hex2rgb(color);
                        return rgbValues[0] = Math.min(255, rgbValues[0] / step * step), rgbValues[1] = Math.min(255, rgbValues[1] / step * step), 
                        rgbValues[2] = Math.min(255, rgbValues[2] / step * step), PIXI.rgb2hex(rgbValues);
                    }, PIXI.CanvasTinter.checkInverseAlpha = function() {
                        var canvas = new PIXI.CanvasBuffer(2, 1);
                        canvas.context.fillStyle = "rgba(10, 20, 30, 0.5)", canvas.context.fillRect(0, 0, 1, 1);
                        var s1 = canvas.context.getImageData(0, 0, 1, 1);
                        canvas.context.putImageData(s1, 1, 0);
                        var s2 = canvas.context.getImageData(1, 0, 1, 1);
                        return s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3];
                    }, PIXI.CanvasTinter.cacheStepsPerColorChannel = 8, PIXI.CanvasTinter.convertTintToImage = !1, 
                    PIXI.CanvasTinter.canHandleAlpha = PIXI.CanvasTinter.checkInverseAlpha(), PIXI.CanvasTinter.canUseMultiply = PIXI.canUseNewCanvasBlendModes(), 
                    PIXI.CanvasTinter.tintMethod = PIXI.CanvasTinter.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply : PIXI.CanvasTinter.tintWithPerPixel, 
                    PIXI.CanvasRenderer = function(width, height, options) {
                        if (options) for (var i in PIXI.defaultRenderOptions) "undefined" == typeof options[i] && (options[i] = PIXI.defaultRenderOptions[i]); else options = PIXI.defaultRenderOptions;
                        PIXI.defaultRenderer || (PIXI.sayHello("Canvas"), PIXI.defaultRenderer = this), 
                        this.type = PIXI.CANVAS_RENDERER, this.resolution = options.resolution, this.clearBeforeRender = options.clearBeforeRender, 
                        this.transparent = options.transparent, this.autoResize = options.autoResize || !1, 
                        this.width = width || 800, this.height = height || 600, this.width *= this.resolution, 
                        this.height *= this.resolution, this.view = options.view || document.createElement("canvas"), 
                        this.context = this.view.getContext("2d", {
                            alpha: this.transparent
                        }), this.refresh = !0, this.view.width = this.width * this.resolution, this.view.height = this.height * this.resolution, 
                        this.count = 0, this.maskManager = new PIXI.CanvasMaskManager(), this.renderSession = {
                            context: this.context,
                            maskManager: this.maskManager,
                            scaleMode: null,
                            smoothProperty: null,
                            roundPixels: !1
                        }, this.mapBlendModes(), this.resize(width, height), "imageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "imageSmoothingEnabled" : "webkitImageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "webkitImageSmoothingEnabled" : "mozImageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "mozImageSmoothingEnabled" : "oImageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "oImageSmoothingEnabled" : "msImageSmoothingEnabled" in this.context && (this.renderSession.smoothProperty = "msImageSmoothingEnabled");
                    }, PIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer, PIXI.CanvasRenderer.prototype.render = function(stage) {
                        stage.updateTransform(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, 
                        this.renderSession.currentBlendMode = PIXI.blendModes.NORMAL, this.context.globalCompositeOperation = PIXI.blendModesCanvas[PIXI.blendModes.NORMAL], 
                        navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", 
                        this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : (this.context.fillStyle = stage.backgroundColorString, 
                        this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(stage), 
                        stage.interactive && (stage._interactiveEventsAdded || (stage._interactiveEventsAdded = !0, 
                        stage.interactionManager.setTarget(this)));
                    }, PIXI.CanvasRenderer.prototype.destroy = function(removeView) {
                        "undefined" == typeof removeView && (removeView = !0), removeView && this.view.parent && this.view.parent.removeChild(this.view), 
                        this.view = null, this.context = null, this.maskManager = null, this.renderSession = null;
                    }, PIXI.CanvasRenderer.prototype.resize = function(width, height) {
                        this.width = width * this.resolution, this.height = height * this.resolution, this.view.width = this.width, 
                        this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", 
                        this.view.style.height = this.height / this.resolution + "px");
                    }, PIXI.CanvasRenderer.prototype.renderDisplayObject = function(displayObject, context) {
                        this.renderSession.context = context || this.context, this.renderSession.resolution = this.resolution, 
                        displayObject._renderCanvas(this.renderSession);
                    }, PIXI.CanvasRenderer.prototype.mapBlendModes = function() {
                        PIXI.blendModesCanvas || (PIXI.blendModesCanvas = [], PIXI.canUseNewCanvasBlendModes() ? (PIXI.blendModesCanvas[PIXI.blendModes.NORMAL] = "source-over", 
                        PIXI.blendModesCanvas[PIXI.blendModes.ADD] = "lighter", PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "multiply", 
                        PIXI.blendModesCanvas[PIXI.blendModes.SCREEN] = "screen", PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY] = "overlay", 
                        PIXI.blendModesCanvas[PIXI.blendModes.DARKEN] = "darken", PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN] = "lighten", 
                        PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "color-dodge", PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "color-burn", 
                        PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "hard-light", PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "soft-light", 
                        PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "difference", PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "exclusion", 
                        PIXI.blendModesCanvas[PIXI.blendModes.HUE] = "hue", PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "saturation", 
                        PIXI.blendModesCanvas[PIXI.blendModes.COLOR] = "color", PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "luminosity") : (PIXI.blendModesCanvas[PIXI.blendModes.NORMAL] = "source-over", 
                        PIXI.blendModesCanvas[PIXI.blendModes.ADD] = "lighter", PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "source-over", 
                        PIXI.blendModesCanvas[PIXI.blendModes.SCREEN] = "source-over", PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY] = "source-over", 
                        PIXI.blendModesCanvas[PIXI.blendModes.DARKEN] = "source-over", PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN] = "source-over", 
                        PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "source-over", PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "source-over", 
                        PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "source-over", PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "source-over", 
                        PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "source-over", PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "source-over", 
                        PIXI.blendModesCanvas[PIXI.blendModes.HUE] = "source-over", PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "source-over", 
                        PIXI.blendModesCanvas[PIXI.blendModes.COLOR] = "source-over", PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "source-over"));
                    }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(graphics, context) {
                        var worldAlpha = graphics.worldAlpha;
                        graphics.dirty && (this.updateGraphicsTint(graphics), graphics.dirty = !1);
                        for (var i = 0; i < graphics.graphicsData.length; i++) {
                            var data = graphics.graphicsData[i], shape = data.shape, fillColor = data._fillTint, lineColor = data._lineTint;
                            if (context.lineWidth = data.lineWidth, data.type === PIXI.Graphics.POLY) {
                                context.beginPath();
                                var points = shape.points;
                                context.moveTo(points[0], points[1]);
                                for (var j = 1; j < points.length / 2; j++) context.lineTo(points[2 * j], points[2 * j + 1]);
                                shape.closed && context.lineTo(points[0], points[1]), points[0] === points[points.length - 2] && points[1] === points[points.length - 1] && context.closePath(), 
                                data.fill && (context.globalAlpha = data.fillAlpha * worldAlpha, context.fillStyle = "#" + ("00000" + (0 | fillColor).toString(16)).substr(-6), 
                                context.fill()), data.lineWidth && (context.globalAlpha = data.lineAlpha * worldAlpha, 
                                context.strokeStyle = "#" + ("00000" + (0 | lineColor).toString(16)).substr(-6), 
                                context.stroke());
                            } else if (data.type === PIXI.Graphics.RECT) (data.fillColor || 0 === data.fillColor) && (context.globalAlpha = data.fillAlpha * worldAlpha, 
                            context.fillStyle = "#" + ("00000" + (0 | fillColor).toString(16)).substr(-6), context.fillRect(shape.x, shape.y, shape.width, shape.height)), 
                            data.lineWidth && (context.globalAlpha = data.lineAlpha * worldAlpha, context.strokeStyle = "#" + ("00000" + (0 | lineColor).toString(16)).substr(-6), 
                            context.strokeRect(shape.x, shape.y, shape.width, shape.height)); else if (data.type === PIXI.Graphics.CIRC) context.beginPath(), 
                            context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI), context.closePath(), 
                            data.fill && (context.globalAlpha = data.fillAlpha * worldAlpha, context.fillStyle = "#" + ("00000" + (0 | fillColor).toString(16)).substr(-6), 
                            context.fill()), data.lineWidth && (context.globalAlpha = data.lineAlpha * worldAlpha, 
                            context.strokeStyle = "#" + ("00000" + (0 | lineColor).toString(16)).substr(-6), 
                            context.stroke()); else if (data.type === PIXI.Graphics.ELIP) {
                                var w = 2 * shape.width, h = 2 * shape.height, x = shape.x - w / 2, y = shape.y - h / 2;
                                context.beginPath();
                                var kappa = .5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
                                context.moveTo(x, ym), context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y), context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym), 
                                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye), context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym), 
                                context.closePath(), data.fill && (context.globalAlpha = data.fillAlpha * worldAlpha, 
                                context.fillStyle = "#" + ("00000" + (0 | fillColor).toString(16)).substr(-6), context.fill()), 
                                data.lineWidth && (context.globalAlpha = data.lineAlpha * worldAlpha, context.strokeStyle = "#" + ("00000" + (0 | lineColor).toString(16)).substr(-6), 
                                context.stroke());
                            } else if (data.type === PIXI.Graphics.RREC) {
                                var rx = shape.x, ry = shape.y, width = shape.width, height = shape.height, radius = shape.radius, maxRadius = Math.min(width, height) / 2 | 0;
                                radius = radius > maxRadius ? maxRadius : radius, context.beginPath(), context.moveTo(rx, ry + radius), 
                                context.lineTo(rx, ry + height - radius), context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height), 
                                context.lineTo(rx + width - radius, ry + height), context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius), 
                                context.lineTo(rx + width, ry + radius), context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry), 
                                context.lineTo(rx + radius, ry), context.quadraticCurveTo(rx, ry, rx, ry + radius), 
                                context.closePath(), (data.fillColor || 0 === data.fillColor) && (context.globalAlpha = data.fillAlpha * worldAlpha, 
                                context.fillStyle = "#" + ("00000" + (0 | fillColor).toString(16)).substr(-6), context.fill()), 
                                data.lineWidth && (context.globalAlpha = data.lineAlpha * worldAlpha, context.strokeStyle = "#" + ("00000" + (0 | lineColor).toString(16)).substr(-6), 
                                context.stroke());
                            }
                        }
                    }, PIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context) {
                        var len = graphics.graphicsData.length;
                        if (0 !== len) {
                            len > 1 && (len = 1, window.console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object"));
                            for (var i = 0; 1 > i; i++) {
                                var data = graphics.graphicsData[i], shape = data.shape;
                                if (data.type === PIXI.Graphics.POLY) {
                                    context.beginPath();
                                    var points = shape.points;
                                    context.moveTo(points[0], points[1]);
                                    for (var j = 1; j < points.length / 2; j++) context.lineTo(points[2 * j], points[2 * j + 1]);
                                    points[0] === points[points.length - 2] && points[1] === points[points.length - 1] && context.closePath();
                                } else if (data.type === PIXI.Graphics.RECT) context.beginPath(), context.rect(shape.x, shape.y, shape.width, shape.height), 
                                context.closePath(); else if (data.type === PIXI.Graphics.CIRC) context.beginPath(), 
                                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI), context.closePath(); else if (data.type === PIXI.Graphics.ELIP) {
                                    var w = 2 * shape.width, h = 2 * shape.height, x = shape.x - w / 2, y = shape.y - h / 2;
                                    context.beginPath();
                                    var kappa = .5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
                                    context.moveTo(x, ym), context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y), context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym), 
                                    context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye), context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym), 
                                    context.closePath();
                                } else if (data.type === PIXI.Graphics.RREC) {
                                    var pts = shape.points, rx = pts[0], ry = pts[1], width = pts[2], height = pts[3], radius = pts[4], maxRadius = Math.min(width, height) / 2 | 0;
                                    radius = radius > maxRadius ? maxRadius : radius, context.beginPath(), context.moveTo(rx, ry + radius), 
                                    context.lineTo(rx, ry + height - radius), context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height), 
                                    context.lineTo(rx + width - radius, ry + height), context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius), 
                                    context.lineTo(rx + width, ry + radius), context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry), 
                                    context.lineTo(rx + radius, ry), context.quadraticCurveTo(rx, ry, rx, ry + radius), 
                                    context.closePath();
                                }
                            }
                        }
                    }, PIXI.CanvasGraphics.updateGraphicsTint = function(graphics) {
                        if (16777215 !== graphics.tint) for (var tintR = (graphics.tint >> 16 & 255) / 255, tintG = (graphics.tint >> 8 & 255) / 255, tintB = (255 & graphics.tint) / 255, i = 0; i < graphics.graphicsData.length; i++) {
                            var data = graphics.graphicsData[i], fillColor = 0 | data.fillColor, lineColor = 0 | data.lineColor;
                            data._fillTint = ((fillColor >> 16 & 255) / 255 * tintR * 255 << 16) + ((fillColor >> 8 & 255) / 255 * tintG * 255 << 8) + (255 & fillColor) / 255 * tintB * 255, 
                            data._lineTint = ((lineColor >> 16 & 255) / 255 * tintR * 255 << 16) + ((lineColor >> 8 & 255) / 255 * tintG * 255 << 8) + (255 & lineColor) / 255 * tintB * 255;
                        }
                    }, PIXI.Strip = function(texture) {
                        PIXI.DisplayObjectContainer.call(this), this.texture = texture, this.uvs = new PIXI.Float32Array([ 0, 1, 1, 1, 1, 0, 0, 1 ]), 
                        this.vertices = new PIXI.Float32Array([ 0, 0, 100, 0, 100, 100, 0, 100 ]), this.colors = new PIXI.Float32Array([ 1, 1, 1, 1 ]), 
                        this.indices = new PIXI.Uint16Array([ 0, 1, 2, 3 ]), this.dirty = !0, this.blendMode = PIXI.blendModes.NORMAL, 
                        this.canvasPadding = 0, this.drawMode = PIXI.Strip.DrawModes.TRIANGLE_STRIP;
                    }, PIXI.Strip.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), 
                    PIXI.Strip.prototype.constructor = PIXI.Strip, PIXI.Strip.prototype._renderWebGL = function(renderSession) {
                        !this.visible || this.alpha <= 0 || (renderSession.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(renderSession), 
                        renderSession.shaderManager.setShader(renderSession.shaderManager.stripShader), 
                        this._renderStrip(renderSession), renderSession.spriteBatch.start());
                    }, PIXI.Strip.prototype._initWebGL = function(renderSession) {
                        var gl = renderSession.gl;
                        this._vertexBuffer = gl.createBuffer(), this._indexBuffer = gl.createBuffer(), this._uvBuffer = gl.createBuffer(), 
                        this._colorBuffer = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer), 
                        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW), gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer), 
                        gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW), gl.bindBuffer(gl.ARRAY_BUFFER, this._colorBuffer), 
                        gl.bufferData(gl.ARRAY_BUFFER, this.colors, gl.STATIC_DRAW), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer), 
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
                    }, PIXI.Strip.prototype._renderStrip = function(renderSession) {
                        var gl = renderSession.gl, projection = renderSession.projection, offset = renderSession.offset, shader = renderSession.shaderManager.stripShader, drawMode = this.drawMode === PIXI.Strip.DrawModes.TRIANGLE_STRIP ? gl.TRIANGLE_STRIP : gl.TRIANGLES;
                        renderSession.blendModeManager.setBlendMode(this.blendMode), gl.uniformMatrix3fv(shader.translationMatrix, !1, this.worldTransform.toArray(!0)), 
                        gl.uniform2f(shader.projectionVector, projection.x, -projection.y), gl.uniform2f(shader.offsetVector, -offset.x, -offset.y), 
                        gl.uniform1f(shader.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer), 
                        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW), gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, !1, 0, 0), 
                        gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer), gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW), 
                        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, !1, 0, 0), gl.activeTexture(gl.TEXTURE0), 
                        this.texture.baseTexture._dirty[gl.id] ? renderSession.renderer.updateTexture(this.texture.baseTexture) : gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id]), 
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW)) : (gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer), 
                        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices), gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, !1, 0, 0), 
                        gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer), gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, !1, 0, 0), 
                        gl.activeTexture(gl.TEXTURE0), this.texture.baseTexture._dirty[gl.id] ? renderSession.renderer.updateTexture(this.texture.baseTexture) : gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id]), 
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), gl.drawElements(drawMode, this.indices.length, gl.UNSIGNED_SHORT, 0);
                    }, PIXI.Strip.prototype._renderCanvas = function(renderSession) {
                        var context = renderSession.context, transform = this.worldTransform;
                        renderSession.roundPixels ? context.setTransform(transform.a, transform.b, transform.c, transform.d, 0 | transform.tx, 0 | transform.ty) : context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty), 
                        this.drawMode === PIXI.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(context) : this._renderCanvasTriangles(context);
                    }, PIXI.Strip.prototype._renderCanvasTriangleStrip = function(context) {
                        var vertices = this.vertices, uvs = this.uvs, length = vertices.length / 2;
                        this.count++;
                        for (var i = 0; length - 2 > i; i++) {
                            var index = 2 * i;
                            this._renderCanvasDrawTriangle(context, vertices, uvs, index, index + 2, index + 4);
                        }
                    }, PIXI.Strip.prototype._renderCanvasTriangles = function(context) {
                        var vertices = this.vertices, uvs = this.uvs, indices = this.indices, length = indices.length;
                        this.count++;
                        for (var i = 0; length > i; i += 3) {
                            var index0 = 2 * indices[i], index1 = 2 * indices[i + 1], index2 = 2 * indices[i + 2];
                            this._renderCanvasDrawTriangle(context, vertices, uvs, index0, index1, index2);
                        }
                    }, PIXI.Strip.prototype._renderCanvasDrawTriangle = function(context, vertices, uvs, index0, index1, index2) {
                        var textureSource = this.texture.baseTexture.source, textureWidth = this.texture.width, textureHeight = this.texture.height, x0 = vertices[index0], x1 = vertices[index1], x2 = vertices[index2], y0 = vertices[index0 + 1], y1 = vertices[index1 + 1], y2 = vertices[index2 + 1], u0 = uvs[index0] * textureWidth, u1 = uvs[index1] * textureWidth, u2 = uvs[index2] * textureWidth, v0 = uvs[index0 + 1] * textureHeight, v1 = uvs[index1 + 1] * textureHeight, v2 = uvs[index2 + 1] * textureHeight;
                        if (this.canvasPadding > 0) {
                            var paddingX = this.canvasPadding / this.worldTransform.a, paddingY = this.canvasPadding / this.worldTransform.d, centerX = (x0 + x1 + x2) / 3, centerY = (y0 + y1 + y2) / 3, normX = x0 - centerX, normY = y0 - centerY, dist = Math.sqrt(normX * normX + normY * normY);
                            x0 = centerX + normX / dist * (dist + paddingX), y0 = centerY + normY / dist * (dist + paddingY), 
                            normX = x1 - centerX, normY = y1 - centerY, dist = Math.sqrt(normX * normX + normY * normY), 
                            x1 = centerX + normX / dist * (dist + paddingX), y1 = centerY + normY / dist * (dist + paddingY), 
                            normX = x2 - centerX, normY = y2 - centerY, dist = Math.sqrt(normX * normX + normY * normY), 
                            x2 = centerX + normX / dist * (dist + paddingX), y2 = centerY + normY / dist * (dist + paddingY);
                        }
                        context.save(), context.beginPath(), context.moveTo(x0, y0), context.lineTo(x1, y1), 
                        context.lineTo(x2, y2), context.closePath(), context.clip();
                        var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2, deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2, deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2, deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2, deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2, deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2, deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;
                        context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta), 
                        context.drawImage(textureSource, 0, 0), context.restore();
                    }, PIXI.Strip.prototype.renderStripFlat = function(strip) {
                        var context = this.context, vertices = strip.vertices, length = vertices.length / 2;
                        this.count++, context.beginPath();
                        for (var i = 1; length - 2 > i; i++) {
                            var index = 2 * i, x0 = vertices[index], x1 = vertices[index + 2], x2 = vertices[index + 4], y0 = vertices[index + 1], y1 = vertices[index + 3], y2 = vertices[index + 5];
                            context.moveTo(x0, y0), context.lineTo(x1, y1), context.lineTo(x2, y2);
                        }
                        context.fillStyle = "#FF0000", context.fill(), context.closePath();
                    }, PIXI.Strip.prototype.onTextureUpdate = function() {
                        this.updateFrame = !0;
                    }, PIXI.Strip.prototype.getBounds = function(matrix) {
                        for (var worldTransform = matrix || this.worldTransform, a = worldTransform.a, b = worldTransform.b, c = worldTransform.c, d = worldTransform.d, tx = worldTransform.tx, ty = worldTransform.ty, maxX = -(1 / 0), maxY = -(1 / 0), minX = 1 / 0, minY = 1 / 0, vertices = this.vertices, i = 0, n = vertices.length; n > i; i += 2) {
                            var rawX = vertices[i], rawY = vertices[i + 1], x = a * rawX + c * rawY + tx, y = d * rawY + b * rawX + ty;
                            minX = minX > x ? x : minX, minY = minY > y ? y : minY, maxX = x > maxX ? x : maxX, 
                            maxY = y > maxY ? y : maxY;
                        }
                        if (minX === -(1 / 0) || maxY === 1 / 0) return PIXI.EmptyRectangle;
                        var bounds = this._bounds;
                        return bounds.x = minX, bounds.width = maxX - minX, bounds.y = minY, bounds.height = maxY - minY, 
                        this._currentBounds = bounds, bounds;
                    }, PIXI.Strip.DrawModes = {
                        TRIANGLE_STRIP: 0,
                        TRIANGLES: 1
                    }, PIXI.Rope = function(texture, points) {
                        PIXI.Strip.call(this, texture), this.points = points, this.vertices = new PIXI.Float32Array(4 * points.length), 
                        this.uvs = new PIXI.Float32Array(4 * points.length), this.colors = new PIXI.Float32Array(2 * points.length), 
                        this.indices = new PIXI.Uint16Array(2 * points.length), this.refresh();
                    }, PIXI.Rope.prototype = Object.create(PIXI.Strip.prototype), PIXI.Rope.prototype.constructor = PIXI.Rope, 
                    PIXI.Rope.prototype.refresh = function() {
                        var points = this.points;
                        if (!(points.length < 1)) {
                            var uvs = this.uvs, lastPoint = points[0], indices = this.indices, colors = this.colors;
                            this.count -= .2, uvs[0] = 0, uvs[1] = 0, uvs[2] = 0, uvs[3] = 1, colors[0] = 1, 
                            colors[1] = 1, indices[0] = 0, indices[1] = 1;
                            for (var point, index, amount, total = points.length, i = 1; total > i; i++) point = points[i], 
                            index = 4 * i, amount = i / (total - 1), i % 2 ? (uvs[index] = amount, uvs[index + 1] = 0, 
                            uvs[index + 2] = amount, uvs[index + 3] = 1) : (uvs[index] = amount, uvs[index + 1] = 0, 
                            uvs[index + 2] = amount, uvs[index + 3] = 1), index = 2 * i, colors[index] = 1, 
                            colors[index + 1] = 1, index = 2 * i, indices[index] = index, indices[index + 1] = index + 1, 
                            lastPoint = point;
                        }
                    }, PIXI.Rope.prototype.updateTransform = function() {
                        var points = this.points;
                        if (!(points.length < 1)) {
                            var nextPoint, lastPoint = points[0], perp = {
                                x: 0,
                                y: 0
                            };
                            this.count -= .2;
                            for (var point, index, ratio, perpLength, num, vertices = this.vertices, total = points.length, i = 0; total > i; i++) point = points[i], 
                            index = 4 * i, nextPoint = i < points.length - 1 ? points[i + 1] : point, perp.y = -(nextPoint.x - lastPoint.x), 
                            perp.x = nextPoint.y - lastPoint.y, ratio = 10 * (1 - i / (total - 1)), ratio > 1 && (ratio = 1), 
                            perpLength = Math.sqrt(perp.x * perp.x + perp.y * perp.y), num = this.texture.height / 2, 
                            perp.x /= perpLength, perp.y /= perpLength, perp.x *= num, perp.y *= num, vertices[index] = point.x + perp.x, 
                            vertices[index + 1] = point.y + perp.y, vertices[index + 2] = point.x - perp.x, 
                            vertices[index + 3] = point.y - perp.y, lastPoint = point;
                            PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
                        }
                    }, PIXI.Rope.prototype.setTexture = function(texture) {
                        this.texture = texture;
                    }, PIXI.TilingSprite = function(texture, width, height) {
                        PIXI.Sprite.call(this, texture), this._width = width || 100, this._height = height || 100, 
                        this.tileScale = new PIXI.Point(1, 1), this.tileScaleOffset = new PIXI.Point(1, 1), 
                        this.tilePosition = new PIXI.Point(0, 0), this.renderable = !0, this.tint = 16777215, 
                        this.blendMode = PIXI.blendModes.NORMAL;
                    }, PIXI.TilingSprite.prototype = Object.create(PIXI.Sprite.prototype), PIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite, 
                    Object.defineProperty(PIXI.TilingSprite.prototype, "width", {
                        get: function() {
                            return this._width;
                        },
                        set: function(value) {
                            this._width = value;
                        }
                    }), Object.defineProperty(PIXI.TilingSprite.prototype, "height", {
                        get: function() {
                            return this._height;
                        },
                        set: function(value) {
                            this._height = value;
                        }
                    }), PIXI.TilingSprite.prototype.setTexture = function(texture) {
                        this.texture !== texture && (this.texture = texture, this.refreshTexture = !0, this.cachedTint = 16777215);
                    }, PIXI.TilingSprite.prototype._renderWebGL = function(renderSession) {
                        if (this.visible !== !1 && 0 !== this.alpha) {
                            var i, j;
                            for (this._mask && (renderSession.spriteBatch.stop(), renderSession.maskManager.pushMask(this.mask, renderSession), 
                            renderSession.spriteBatch.start()), this._filters && (renderSession.spriteBatch.flush(), 
                            renderSession.filterManager.pushFilter(this._filterBlock)), !this.tilingTexture || this.refreshTexture ? (this.generateTilingTexture(!0), 
                            this.tilingTexture && this.tilingTexture.needsUpdate && (renderSession.renderer.updateTexture(this.tilingTexture.baseTexture), 
                            this.tilingTexture.needsUpdate = !1)) : renderSession.spriteBatch.renderTilingSprite(this), 
                            i = 0, j = this.children.length; j > i; i++) this.children[i]._renderWebGL(renderSession);
                            renderSession.spriteBatch.stop(), this._filters && renderSession.filterManager.popFilter(), 
                            this._mask && renderSession.maskManager.popMask(this._mask, renderSession), renderSession.spriteBatch.start();
                        }
                    }, PIXI.TilingSprite.prototype._renderCanvas = function(renderSession) {
                        if (this.visible !== !1 && 0 !== this.alpha) {
                            var context = renderSession.context;
                            this._mask && renderSession.maskManager.pushMask(this._mask, context), context.globalAlpha = this.worldAlpha;
                            var i, j, transform = this.worldTransform, resolution = renderSession.resolution;
                            if (context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution), 
                            !this.__tilePattern || this.refreshTexture) {
                                if (this.generateTilingTexture(!1), !this.tilingTexture) return;
                                this.__tilePattern = context.createPattern(this.tilingTexture.baseTexture.source, "repeat");
                            }
                            this.blendMode !== renderSession.currentBlendMode && (renderSession.currentBlendMode = this.blendMode, 
                            context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode]);
                            var tilePosition = this.tilePosition, tileScale = this.tileScale;
                            for (tilePosition.x %= this.tilingTexture.baseTexture.width, tilePosition.y %= this.tilingTexture.baseTexture.height, 
                            context.scale(tileScale.x, tileScale.y), context.translate(tilePosition.x + this.anchor.x * -this._width, tilePosition.y + this.anchor.y * -this._height), 
                            context.fillStyle = this.__tilePattern, context.fillRect(-tilePosition.x, -tilePosition.y, this._width / tileScale.x, this._height / tileScale.y), 
                            context.scale(1 / tileScale.x, 1 / tileScale.y), context.translate(-tilePosition.x + this.anchor.x * this._width, -tilePosition.y + this.anchor.y * this._height), 
                            this._mask && renderSession.maskManager.popMask(renderSession.context), i = 0, j = this.children.length; j > i; i++) this.children[i]._renderCanvas(renderSession);
                        }
                    }, PIXI.TilingSprite.prototype.getBounds = function() {
                        var width = this._width, height = this._height, w0 = width * (1 - this.anchor.x), w1 = width * -this.anchor.x, h0 = height * (1 - this.anchor.y), h1 = height * -this.anchor.y, worldTransform = this.worldTransform, a = worldTransform.a, b = worldTransform.b, c = worldTransform.c, d = worldTransform.d, tx = worldTransform.tx, ty = worldTransform.ty, x1 = a * w1 + c * h1 + tx, y1 = d * h1 + b * w1 + ty, x2 = a * w0 + c * h1 + tx, y2 = d * h1 + b * w0 + ty, x3 = a * w0 + c * h0 + tx, y3 = d * h0 + b * w0 + ty, x4 = a * w1 + c * h0 + tx, y4 = d * h0 + b * w1 + ty, maxX = -(1 / 0), maxY = -(1 / 0), minX = 1 / 0, minY = 1 / 0;
                        minX = minX > x1 ? x1 : minX, minX = minX > x2 ? x2 : minX, minX = minX > x3 ? x3 : minX, 
                        minX = minX > x4 ? x4 : minX, minY = minY > y1 ? y1 : minY, minY = minY > y2 ? y2 : minY, 
                        minY = minY > y3 ? y3 : minY, minY = minY > y4 ? y4 : minY, maxX = x1 > maxX ? x1 : maxX, 
                        maxX = x2 > maxX ? x2 : maxX, maxX = x3 > maxX ? x3 : maxX, maxX = x4 > maxX ? x4 : maxX, 
                        maxY = y1 > maxY ? y1 : maxY, maxY = y2 > maxY ? y2 : maxY, maxY = y3 > maxY ? y3 : maxY, 
                        maxY = y4 > maxY ? y4 : maxY;
                        var bounds = this._bounds;
                        return bounds.x = minX, bounds.width = maxX - minX, bounds.y = minY, bounds.height = maxY - minY, 
                        this._currentBounds = bounds, bounds;
                    }, PIXI.TilingSprite.prototype.onTextureUpdate = function() {}, PIXI.TilingSprite.prototype.generateTilingTexture = function(forcePowerOfTwo) {
                        if (this.texture.baseTexture.hasLoaded) {
                            var targetWidth, targetHeight, texture = this.originalTexture || this.texture, frame = texture.frame, isFrame = frame.width !== texture.baseTexture.width || frame.height !== texture.baseTexture.height, newTextureRequired = !1;
                            if (forcePowerOfTwo ? (targetWidth = PIXI.getNextPowerOfTwo(frame.width), targetHeight = PIXI.getNextPowerOfTwo(frame.height), 
                            (frame.width !== targetWidth || frame.height !== targetHeight || texture.baseTexture.width !== targetWidth || texture.baseTexture.height || targetHeight) && (newTextureRequired = !0)) : isFrame && (targetWidth = frame.width, 
                            targetHeight = frame.height, newTextureRequired = !0), newTextureRequired) {
                                var canvasBuffer;
                                this.tilingTexture && this.tilingTexture.isTiling ? (canvasBuffer = this.tilingTexture.canvasBuffer, 
                                canvasBuffer.resize(targetWidth, targetHeight), this.tilingTexture.baseTexture.width = targetWidth, 
                                this.tilingTexture.baseTexture.height = targetHeight, this.tilingTexture.needsUpdate = !0) : (canvasBuffer = new PIXI.CanvasBuffer(targetWidth, targetHeight), 
                                this.tilingTexture = PIXI.Texture.fromCanvas(canvasBuffer.canvas), this.tilingTexture.canvasBuffer = canvasBuffer, 
                                this.tilingTexture.isTiling = !0), canvasBuffer.context.drawImage(texture.baseTexture.source, texture.crop.x, texture.crop.y, texture.crop.width, texture.crop.height, 0, 0, targetWidth, targetHeight), 
                                this.tileScaleOffset.x = frame.width / targetWidth, this.tileScaleOffset.y = frame.height / targetHeight;
                            } else this.tilingTexture && this.tilingTexture.isTiling && this.tilingTexture.destroy(!0), 
                            this.tileScaleOffset.x = 1, this.tileScaleOffset.y = 1, this.tilingTexture = texture;
                            this.refreshTexture = !1, this.originalTexture = this.texture, this.texture = this.tilingTexture, 
                            this.tilingTexture.baseTexture._powerOf2 = !0;
                        }
                    }, PIXI.BaseTextureCache = {}, PIXI.BaseTextureCacheIdGenerator = 0, PIXI.BaseTexture = function(source, scaleMode) {
                        if (this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT, 
                        this.hasLoaded = !1, this.source = source, this._UID = PIXI._UID++, this.premultipliedAlpha = !0, 
                        this._glTextures = [], this.mipmap = !1, this._dirty = [ !0, !0, !0, !0 ], source) {
                            if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) this.hasLoaded = !0, 
                            this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, 
                            this.dirty(); else {
                                var scope = this;
                                this.source.onload = function() {
                                    scope.hasLoaded = !0, scope.width = scope.source.naturalWidth || scope.source.width, 
                                    scope.height = scope.source.naturalHeight || scope.source.height, scope.dirty(), 
                                    scope.dispatchEvent({
                                        type: "loaded",
                                        content: scope
                                    });
                                }, this.source.onerror = function() {
                                    scope.dispatchEvent({
                                        type: "error",
                                        content: scope
                                    });
                                };
                            }
                            this.imageUrl = null, this._powerOf2 = !1;
                        }
                    }, PIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture, PIXI.EventTarget.mixin(PIXI.BaseTexture.prototype), 
                    PIXI.BaseTexture.prototype.destroy = function() {
                        this.imageUrl ? (delete PIXI.BaseTextureCache[this.imageUrl], delete PIXI.TextureCache[this.imageUrl], 
                        this.imageUrl = null, navigator.isCocoonJS || (this.source.src = "")) : this.source && this.source._pixiId && delete PIXI.BaseTextureCache[this.source._pixiId], 
                        this.source = null, this.unloadFromGPU();
                    }, PIXI.BaseTexture.prototype.updateSourceImage = function(newSrc) {
                        this.hasLoaded = !1, this.source.src = null, this.source.src = newSrc;
                    }, PIXI.BaseTexture.prototype.dirty = function() {
                        for (var i = 0; i < this._glTextures.length; i++) this._dirty[i] = !0;
                    }, PIXI.BaseTexture.prototype.unloadFromGPU = function() {
                        this.dirty();
                        for (var i = this._glTextures.length - 1; i >= 0; i--) {
                            var glTexture = this._glTextures[i], gl = PIXI.glContexts[i];
                            gl && glTexture && gl.deleteTexture(glTexture);
                        }
                        this._glTextures.length = 0, this.dirty();
                    }, PIXI.BaseTexture.fromImage = function(imageUrl, crossorigin, scaleMode) {
                        var baseTexture = PIXI.BaseTextureCache[imageUrl];
                        if (void 0 === crossorigin && -1 === imageUrl.indexOf("data:") && (crossorigin = !0), 
                        !baseTexture) {
                            var image = new Image();
                            crossorigin && (image.crossOrigin = ""), image.src = imageUrl, baseTexture = new PIXI.BaseTexture(image, scaleMode), 
                            baseTexture.imageUrl = imageUrl, PIXI.BaseTextureCache[imageUrl] = baseTexture, 
                            -1 !== imageUrl.indexOf(PIXI.RETINA_PREFIX + ".") && (baseTexture.resolution = 2);
                        }
                        return baseTexture;
                    }, PIXI.BaseTexture.fromCanvas = function(canvas, scaleMode) {
                        canvas._pixiId || (canvas._pixiId = "canvas_" + PIXI.TextureCacheIdGenerator++);
                        var baseTexture = PIXI.BaseTextureCache[canvas._pixiId];
                        return baseTexture || (baseTexture = new PIXI.BaseTexture(canvas, scaleMode), PIXI.BaseTextureCache[canvas._pixiId] = baseTexture), 
                        baseTexture;
                    }, PIXI.TextureCache = {}, PIXI.FrameCache = {}, PIXI.TextureCacheIdGenerator = 0, 
                    PIXI.Texture = function(baseTexture, frame, crop, trim) {
                        this.noFrame = !1, frame || (this.noFrame = !0, frame = new PIXI.Rectangle(0, 0, 1, 1)), 
                        baseTexture instanceof PIXI.Texture && (baseTexture = baseTexture.baseTexture), 
                        this.baseTexture = baseTexture, this.frame = frame, this.trim = trim, this.valid = !1, 
                        this.requiresUpdate = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = crop || new PIXI.Rectangle(0, 0, 1, 1), 
                        baseTexture.hasLoaded ? (this.noFrame && (frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height)), 
                        this.setFrame(frame)) : baseTexture.addEventListener("loaded", this.onBaseTextureLoaded.bind(this));
                    }, PIXI.Texture.prototype.constructor = PIXI.Texture, PIXI.EventTarget.mixin(PIXI.Texture.prototype), 
                    PIXI.Texture.prototype.onBaseTextureLoaded = function() {
                        var baseTexture = this.baseTexture;
                        baseTexture.removeEventListener("loaded", this.onLoaded), this.noFrame && (this.frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height)), 
                        this.setFrame(this.frame), this.dispatchEvent({
                            type: "update",
                            content: this
                        });
                    }, PIXI.Texture.prototype.destroy = function(destroyBase) {
                        destroyBase && this.baseTexture.destroy(), this.valid = !1;
                    }, PIXI.Texture.prototype.setFrame = function(frame) {
                        if (this.noFrame = !1, this.frame = frame, this.width = frame.width, this.height = frame.height, 
                        this.crop.x = frame.x, this.crop.y = frame.y, this.crop.width = frame.width, this.crop.height = frame.height, 
                        !this.trim && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height)) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                        this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded, 
                        this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, 
                        this.frame.height = this.trim.height), this.valid && this._updateUvs();
                    }, PIXI.Texture.prototype._updateUvs = function() {
                        this._uvs || (this._uvs = new PIXI.TextureUvs());
                        var frame = this.crop, tw = this.baseTexture.width, th = this.baseTexture.height;
                        this._uvs.x0 = frame.x / tw, this._uvs.y0 = frame.y / th, this._uvs.x1 = (frame.x + frame.width) / tw, 
                        this._uvs.y1 = frame.y / th, this._uvs.x2 = (frame.x + frame.width) / tw, this._uvs.y2 = (frame.y + frame.height) / th, 
                        this._uvs.x3 = frame.x / tw, this._uvs.y3 = (frame.y + frame.height) / th;
                    }, PIXI.Texture.fromImage = function(imageUrl, crossorigin, scaleMode) {
                        var texture = PIXI.TextureCache[imageUrl];
                        return texture || (texture = new PIXI.Texture(PIXI.BaseTexture.fromImage(imageUrl, crossorigin, scaleMode)), 
                        PIXI.TextureCache[imageUrl] = texture), texture;
                    }, PIXI.Texture.fromFrame = function(frameId) {
                        var texture = PIXI.TextureCache[frameId];
                        if (!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ');
                        return texture;
                    }, PIXI.Texture.fromCanvas = function(canvas, scaleMode) {
                        var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode);
                        return new PIXI.Texture(baseTexture);
                    }, PIXI.Texture.addTextureToCache = function(texture, id) {
                        PIXI.TextureCache[id] = texture;
                    }, PIXI.Texture.removeTextureFromCache = function(id) {
                        var texture = PIXI.TextureCache[id];
                        return delete PIXI.TextureCache[id], delete PIXI.BaseTextureCache[id], texture;
                    }, PIXI.TextureUvs = function() {
                        this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, 
                        this.y3 = 0;
                    }, PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture()), PIXI.RenderTexture = function(width, height, renderer, scaleMode, resolution) {
                        if (this.width = width || 100, this.height = height || 100, this.resolution = resolution || 1, 
                        this.frame = new PIXI.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), 
                        this.crop = new PIXI.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), 
                        this.baseTexture = new PIXI.BaseTexture(), this.baseTexture.width = this.width * this.resolution, 
                        this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], 
                        this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT, 
                        this.baseTexture.hasLoaded = !0, PIXI.Texture.call(this, this.baseTexture, new PIXI.Rectangle(0, 0, this.width, this.height)), 
                        this.renderer = renderer || PIXI.defaultRenderer, this.renderer.type === PIXI.WEBGL_RENDERER) {
                            var gl = this.renderer.gl;
                            this.baseTexture._dirty[gl.id] = !1, this.textureBuffer = new PIXI.FilterTexture(gl, this.width * this.resolution, this.height * this.resolution, this.baseTexture.scaleMode), 
                            this.baseTexture._glTextures[gl.id] = this.textureBuffer.texture, this.render = this.renderWebGL, 
                            this.projection = new PIXI.Point(.5 * this.width, .5 * -this.height);
                        } else this.render = this.renderCanvas, this.textureBuffer = new PIXI.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), 
                        this.baseTexture.source = this.textureBuffer.canvas;
                        this.valid = !0, this._updateUvs();
                    }, PIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype), PIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture, 
                    PIXI.RenderTexture.prototype.resize = function(width, height, updateBase) {
                        (width !== this.width || height !== this.height) && (this.valid = width > 0 && height > 0, 
                        this.width = this.frame.width = this.crop.width = width, this.height = this.frame.height = this.crop.height = height, 
                        updateBase && (this.baseTexture.width = this.width, this.baseTexture.height = this.height), 
                        this.renderer.type === PIXI.WEBGL_RENDERER && (this.projection.x = this.width / 2, 
                        this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width * this.resolution, this.height * this.resolution));
                    }, PIXI.RenderTexture.prototype.clear = function() {
                        this.valid && (this.renderer.type === PIXI.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), 
                        this.textureBuffer.clear());
                    }, PIXI.RenderTexture.prototype.renderWebGL = function(displayObject, matrix, clear) {
                        if (this.valid) {
                            var wt = displayObject.worldTransform;
                            wt.identity(), wt.translate(0, 2 * this.projection.y), matrix && wt.append(matrix), 
                            wt.scale(1, -1), displayObject.worldAlpha = 1;
                            for (var children = displayObject.children, i = 0, j = children.length; j > i; i++) children[i].updateTransform();
                            var gl = this.renderer.gl;
                            gl.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), 
                            gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), clear && this.textureBuffer.clear(), 
                            this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(displayObject, this.projection, this.textureBuffer.frameBuffer), 
                            this.renderer.spriteBatch.dirty = !0;
                        }
                    }, PIXI.RenderTexture.prototype.renderCanvas = function(displayObject, matrix, clear) {
                        if (this.valid) {
                            var wt = displayObject.worldTransform;
                            wt.identity(), matrix && wt.append(matrix), displayObject.worldAlpha = 1;
                            for (var children = displayObject.children, i = 0, j = children.length; j > i; i++) children[i].updateTransform();
                            clear && this.textureBuffer.clear();
                            var context = this.textureBuffer.context, realResolution = this.renderer.resolution;
                            this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(displayObject, context), 
                            this.renderer.resolution = realResolution;
                        }
                    }, PIXI.RenderTexture.prototype.getImage = function() {
                        var image = new Image();
                        return image.src = this.getBase64(), image;
                    }, PIXI.RenderTexture.prototype.getBase64 = function() {
                        return this.getCanvas().toDataURL();
                    }, PIXI.RenderTexture.prototype.getCanvas = function() {
                        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
                            var gl = this.renderer.gl, width = this.textureBuffer.width, height = this.textureBuffer.height, webGLPixels = new Uint8Array(4 * width * height);
                            gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels), 
                            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                            var tempCanvas = new PIXI.CanvasBuffer(width, height), canvasData = tempCanvas.context.getImageData(0, 0, width, height);
                            return canvasData.data.set(webGLPixels), tempCanvas.context.putImageData(canvasData, 0, 0), 
                            tempCanvas.canvas;
                        }
                        return this.textureBuffer.canvas;
                    }, PIXI.RenderTexture.tempMatrix = new PIXI.Matrix(), PIXI.AbstractFilter = function(fragmentSrc, uniforms) {
                        this.passes = [ this ], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = uniforms || {}, 
                        this.fragmentSrc = fragmentSrc || [];
                    }, PIXI.AbstractFilter.prototype.constructor = PIXI.AbstractFilter, PIXI.AbstractFilter.prototype.syncUniforms = function() {
                        for (var i = 0, j = this.shaders.length; j > i; i++) this.shaders[i].dirty = !0;
                    }, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = PIXI), 
                    exports.PIXI = PIXI) : "undefined" != typeof define && define.amd ? define("PIXI", function() {
                        return root.PIXI = PIXI;
                    }()) : root.PIXI = PIXI;
                }).call(this), function() {
                    function WheelEventProxy(scaleFactor, deltaMode) {
                        this._scaleFactor = scaleFactor, this._deltaMode = deltaMode, this.originalEvent = null;
                    }
                    var root = this, Phaser = Phaser || {
                        VERSION: "2.2.2",
                        GAMES: [],
                        AUTO: 0,
                        CANVAS: 1,
                        WEBGL: 2,
                        HEADLESS: 3,
                        NONE: 0,
                        LEFT: 1,
                        RIGHT: 2,
                        UP: 3,
                        DOWN: 4,
                        SPRITE: 0,
                        BUTTON: 1,
                        IMAGE: 2,
                        GRAPHICS: 3,
                        TEXT: 4,
                        TILESPRITE: 5,
                        BITMAPTEXT: 6,
                        GROUP: 7,
                        RENDERTEXTURE: 8,
                        TILEMAP: 9,
                        TILEMAPLAYER: 10,
                        EMITTER: 11,
                        POLYGON: 12,
                        BITMAPDATA: 13,
                        CANVAS_FILTER: 14,
                        WEBGL_FILTER: 15,
                        ELLIPSE: 16,
                        SPRITEBATCH: 17,
                        RETROFONT: 18,
                        POINTER: 19,
                        ROPE: 20,
                        blendModes: {
                            NORMAL: 0,
                            ADD: 1,
                            MULTIPLY: 2,
                            SCREEN: 3,
                            OVERLAY: 4,
                            DARKEN: 5,
                            LIGHTEN: 6,
                            COLOR_DODGE: 7,
                            COLOR_BURN: 8,
                            HARD_LIGHT: 9,
                            SOFT_LIGHT: 10,
                            DIFFERENCE: 11,
                            EXCLUSION: 12,
                            HUE: 13,
                            SATURATION: 14,
                            COLOR: 15,
                            LUMINOSITY: 16
                        },
                        scaleModes: {
                            DEFAULT: 0,
                            LINEAR: 0,
                            NEAREST: 1
                        }
                    };
                    if (PIXI.InteractionManager = PIXI.InteractionManager || function() {}, PIXI.dontSayHello = !0, 
                    Math.trunc || (Math.trunc = function(x) {
                        return 0 > x ? Math.ceil(x) : Math.floor(x);
                    }), Function.prototype.bind || (Function.prototype.bind = function() {
                        var slice = Array.prototype.slice;
                        return function(thisArg) {
                            function bound() {
                                var args = boundArgs.concat(slice.call(arguments));
                                target.apply(this instanceof bound ? this : thisArg, args);
                            }
                            var target = this, boundArgs = slice.call(arguments, 1);
                            if ("function" != typeof target) throw new TypeError();
                            return bound.prototype = function F(proto) {
                                return proto && (F.prototype = proto), this instanceof F ? void 0 : new F();
                            }(target.prototype), bound;
                        };
                    }()), Array.isArray || (Array.isArray = function(arg) {
                        return "[object Array]" == Object.prototype.toString.call(arg);
                    }), Array.prototype.forEach || (Array.prototype.forEach = function(fun) {
                        "use strict";
                        if (void 0 === this || null === this) throw new TypeError();
                        var t = Object(this), len = t.length >>> 0;
                        if ("function" != typeof fun) throw new TypeError();
                        for (var thisArg = arguments.length >= 2 ? arguments[1] : void 0, i = 0; len > i; i++) i in t && fun.call(thisArg, t[i], i, t);
                    }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
                        var CheapArray = function(type) {
                            var proto = new Array();
                            window[type] = function(arg) {
                                if ("number" == typeof arg) {
                                    Array.call(this, arg), this.length = arg;
                                    for (var i = 0; i < this.length; i++) this[i] = 0;
                                } else {
                                    Array.call(this, arg.length), this.length = arg.length;
                                    for (var i = 0; i < this.length; i++) this[i] = arg[i];
                                }
                            }, window[type].prototype = proto, window[type].constructor = window[type];
                        };
                        CheapArray("Uint32Array"), CheapArray("Int16Array");
                    }
                    window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, 
                    window.console.warn = window.console.assert = function() {}), Phaser.Utils = {
                        getProperty: function(obj, prop) {
                            for (var parts = prop.split("."), last = parts.pop(), l = parts.length, i = 1, current = parts[0]; l > i && (obj = obj[current]); ) current = parts[i], 
                            i++;
                            return obj ? obj[last] : null;
                        },
                        setProperty: function(obj, prop, value) {
                            for (var parts = prop.split("."), last = parts.pop(), l = parts.length, i = 1, current = parts[0]; l > i && (obj = obj[current]); ) current = parts[i], 
                            i++;
                            return obj && (obj[last] = value), obj;
                        },
                        chanceRoll: function(chance) {
                            return "undefined" == typeof chance && (chance = 50), chance > 0 && 100 * Math.random() <= chance;
                        },
                        randomChoice: function(choice1, choice2) {
                            return Math.random() < .5 ? choice1 : choice2;
                        },
                        transposeArray: function(array) {
                            return Phaser.ArrayUtils.transposeMatrix(array);
                        },
                        rotateArray: function(matrix, direction) {
                            return Phaser.ArrayUtils.rotateMatrix(matrix, direction);
                        },
                        shuffle: function(array) {
                            return Phaser.ArrayUtils.shuffle(array);
                        },
                        parseDimension: function(size, dimension) {
                            var f = 0, px = 0;
                            return "string" == typeof size ? "%" === size.substr(-1) ? (f = parseInt(size, 10) / 100, 
                            px = 0 === dimension ? window.innerWidth * f : window.innerHeight * f) : px = parseInt(size, 10) : px = size, 
                            px;
                        },
                        pad: function(str, len, pad, dir) {
                            if ("undefined" == typeof len) var len = 0;
                            if ("undefined" == typeof pad) var pad = " ";
                            if ("undefined" == typeof dir) var dir = 3;
                            var padlen = 0;
                            if (len + 1 >= str.length) switch (dir) {
                              case 1:
                                str = new Array(len + 1 - str.length).join(pad) + str;
                                break;

                              case 3:
                                var right = Math.ceil((padlen = len - str.length) / 2), left = padlen - right;
                                str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);
                                break;

                              default:
                                str += new Array(len + 1 - str.length).join(pad);
                            }
                            return str;
                        },
                        isPlainObject: function(obj) {
                            if ("object" != typeof obj || obj.nodeType || obj === obj.window) return !1;
                            try {
                                if (obj.constructor && !{}.hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) return !1;
                            } catch (e) {
                                return !1;
                            }
                            return !0;
                        },
                        extend: function() {
                            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1;
                            for ("boolean" == typeof target && (deep = target, target = arguments[1] || {}, 
                            i = 2), length === i && (target = this, --i); length > i; i++) if (null != (options = arguments[i])) for (name in options) src = target[name], 
                            copy = options[name], target !== copy && (deep && copy && (Phaser.Utils.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, 
                            clone = src && Array.isArray(src) ? src : []) : clone = src && Phaser.Utils.isPlainObject(src) ? src : {}, 
                            target[name] = Phaser.Utils.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
                            return target;
                        },
                        mixin: function(from, to) {
                            if (!from || "object" != typeof from) return to;
                            for (var key in from) {
                                var o = from[key];
                                if (!o.childNodes && !o.cloneNode) {
                                    var type = typeof from[key];
                                    to[key] = from[key] && "object" === type ? typeof to[key] === type ? Phaser.Utils.mixin(from[key], to[key]) : Phaser.Utils.mixin(from[key], new o.constructor()) : from[key];
                                }
                            }
                            return to;
                        }
                    }, Phaser.Circle = function(x, y, diameter) {
                        x = x || 0, y = y || 0, diameter = diameter || 0, this.x = x, this.y = y, this._diameter = diameter, 
                        this._radius = diameter > 0 ? .5 * diameter : 0;
                    }, Phaser.Circle.prototype = {
                        type: null,
                        circumference: function() {
                            return 2 * Math.PI * this._radius;
                        },
                        getBounds: function() {
                            return new Phaser.Rectangle(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius);
                        },
                        setTo: function(x, y, diameter) {
                            return this.x = x, this.y = y, this._diameter = diameter, this._radius = .5 * diameter, 
                            this;
                        },
                        copyFrom: function(source) {
                            return this.setTo(source.x, source.y, source.diameter);
                        },
                        copyTo: function(dest) {
                            return dest.x = this.x, dest.y = this.y, dest.diameter = this._diameter, dest;
                        },
                        distance: function(dest, round) {
                            var distance = Phaser.Math.distance(this.x, this.y, dest.x, dest.y);
                            return round ? Math.round(distance) : distance;
                        },
                        clone: function(output) {
                            return "undefined" == typeof output || null === output ? output = new Phaser.Circle(this.x, this.y, this.diameter) : output.setTo(this.x, this.y, this.diameter), 
                            output;
                        },
                        contains: function(x, y) {
                            return Phaser.Circle.contains(this, x, y);
                        },
                        circumferencePoint: function(angle, asDegrees, out) {
                            return Phaser.Circle.circumferencePoint(this, angle, asDegrees, out);
                        },
                        offset: function(dx, dy) {
                            return this.x += dx, this.y += dy, this;
                        },
                        offsetPoint: function(point) {
                            return this.offset(point.x, point.y);
                        },
                        toString: function() {
                            return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]";
                        }
                    }, Phaser.Circle.prototype.constructor = Phaser.Circle, Object.defineProperty(Phaser.Circle.prototype, "diameter", {
                        get: function() {
                            return this._diameter;
                        },
                        set: function(value) {
                            value > 0 && (this._diameter = value, this._radius = .5 * value);
                        }
                    }), Object.defineProperty(Phaser.Circle.prototype, "radius", {
                        get: function() {
                            return this._radius;
                        },
                        set: function(value) {
                            value > 0 && (this._radius = value, this._diameter = 2 * value);
                        }
                    }), Object.defineProperty(Phaser.Circle.prototype, "left", {
                        get: function() {
                            return this.x - this._radius;
                        },
                        set: function(value) {
                            value > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - value;
                        }
                    }), Object.defineProperty(Phaser.Circle.prototype, "right", {
                        get: function() {
                            return this.x + this._radius;
                        },
                        set: function(value) {
                            value < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = value - this.x;
                        }
                    }), Object.defineProperty(Phaser.Circle.prototype, "top", {
                        get: function() {
                            return this.y - this._radius;
                        },
                        set: function(value) {
                            value > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - value;
                        }
                    }), Object.defineProperty(Phaser.Circle.prototype, "bottom", {
                        get: function() {
                            return this.y + this._radius;
                        },
                        set: function(value) {
                            value < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = value - this.y;
                        }
                    }), Object.defineProperty(Phaser.Circle.prototype, "area", {
                        get: function() {
                            return this._radius > 0 ? Math.PI * this._radius * this._radius : 0;
                        }
                    }), Object.defineProperty(Phaser.Circle.prototype, "empty", {
                        get: function() {
                            return 0 === this._diameter;
                        },
                        set: function(value) {
                            value === !0 && this.setTo(0, 0, 0);
                        }
                    }), Phaser.Circle.contains = function(a, x, y) {
                        if (a.radius > 0 && x >= a.left && x <= a.right && y >= a.top && y <= a.bottom) {
                            var dx = (a.x - x) * (a.x - x), dy = (a.y - y) * (a.y - y);
                            return dx + dy <= a.radius * a.radius;
                        }
                        return !1;
                    }, Phaser.Circle.equals = function(a, b) {
                        return a.x == b.x && a.y == b.y && a.diameter == b.diameter;
                    }, Phaser.Circle.intersects = function(a, b) {
                        return Phaser.Math.distance(a.x, a.y, b.x, b.y) <= a.radius + b.radius;
                    }, Phaser.Circle.circumferencePoint = function(a, angle, asDegrees, out) {
                        return "undefined" == typeof asDegrees && (asDegrees = !1), "undefined" == typeof out && (out = new Phaser.Point()), 
                        asDegrees === !0 && (angle = Phaser.Math.degToRad(angle)), out.x = a.x + a.radius * Math.cos(angle), 
                        out.y = a.y + a.radius * Math.sin(angle), out;
                    }, Phaser.Circle.intersectsRectangle = function(c, r) {
                        var cx = Math.abs(c.x - r.x - r.halfWidth), xDist = r.halfWidth + c.radius;
                        if (cx > xDist) return !1;
                        var cy = Math.abs(c.y - r.y - r.halfHeight), yDist = r.halfHeight + c.radius;
                        if (cy > yDist) return !1;
                        if (cx <= r.halfWidth || cy <= r.halfHeight) return !0;
                        var xCornerDist = cx - r.halfWidth, yCornerDist = cy - r.halfHeight, xCornerDistSq = xCornerDist * xCornerDist, yCornerDistSq = yCornerDist * yCornerDist, maxCornerDistSq = c.radius * c.radius;
                        return maxCornerDistSq >= xCornerDistSq + yCornerDistSq;
                    }, PIXI.Circle = Phaser.Circle, Phaser.Point = function(x, y) {
                        x = x || 0, y = y || 0, this.x = x, this.y = y;
                    }, Phaser.Point.prototype = {
                        copyFrom: function(source) {
                            return this.setTo(source.x, source.y);
                        },
                        invert: function() {
                            return this.setTo(this.y, this.x);
                        },
                        setTo: function(x, y) {
                            return this.x = x || 0, this.y = y || (0 !== y ? this.x : 0), this;
                        },
                        set: function(x, y) {
                            return this.x = x || 0, this.y = y || (0 !== y ? this.x : 0), this;
                        },
                        add: function(x, y) {
                            return this.x += x, this.y += y, this;
                        },
                        subtract: function(x, y) {
                            return this.x -= x, this.y -= y, this;
                        },
                        multiply: function(x, y) {
                            return this.x *= x, this.y *= y, this;
                        },
                        divide: function(x, y) {
                            return this.x /= x, this.y /= y, this;
                        },
                        clampX: function(min, max) {
                            return this.x = Phaser.Math.clamp(this.x, min, max), this;
                        },
                        clampY: function(min, max) {
                            return this.y = Phaser.Math.clamp(this.y, min, max), this;
                        },
                        clamp: function(min, max) {
                            return this.x = Phaser.Math.clamp(this.x, min, max), this.y = Phaser.Math.clamp(this.y, min, max), 
                            this;
                        },
                        clone: function(output) {
                            return "undefined" == typeof output || null === output ? output = new Phaser.Point(this.x, this.y) : output.setTo(this.x, this.y), 
                            output;
                        },
                        copyTo: function(dest) {
                            return dest.x = this.x, dest.y = this.y, dest;
                        },
                        distance: function(dest, round) {
                            return Phaser.Point.distance(this, dest, round);
                        },
                        equals: function(a) {
                            return a.x === this.x && a.y === this.y;
                        },
                        angle: function(a, asDegrees) {
                            return "undefined" == typeof asDegrees && (asDegrees = !1), asDegrees ? Phaser.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x)) : Math.atan2(a.y - this.y, a.x - this.x);
                        },
                        rotate: function(x, y, angle, asDegrees, distance) {
                            return Phaser.Point.rotate(this, x, y, angle, asDegrees, distance);
                        },
                        getMagnitude: function() {
                            return Math.sqrt(this.x * this.x + this.y * this.y);
                        },
                        getMagnitudeSq: function() {
                            return this.x * this.x + this.y * this.y;
                        },
                        setMagnitude: function(magnitude) {
                            return this.normalize().multiply(magnitude, magnitude);
                        },
                        normalize: function() {
                            if (!this.isZero()) {
                                var m = this.getMagnitude();
                                this.x /= m, this.y /= m;
                            }
                            return this;
                        },
                        isZero: function() {
                            return 0 === this.x && 0 === this.y;
                        },
                        dot: function(a) {
                            return this.x * a.x + this.y * a.y;
                        },
                        cross: function(a) {
                            return this.x * a.y - this.y * a.x;
                        },
                        perp: function() {
                            return this.setTo(-this.y, this.x);
                        },
                        rperp: function() {
                            return this.setTo(this.y, -this.x);
                        },
                        normalRightHand: function() {
                            return this.setTo(-1 * this.y, this.x);
                        },
                        floor: function() {
                            return this.setTo(Math.floor(this.x), Math.floor(this.y));
                        },
                        ceil: function() {
                            return this.setTo(Math.ceil(this.x), Math.ceil(this.y));
                        },
                        toString: function() {
                            return "[{Point (x=" + this.x + " y=" + this.y + ")}]";
                        }
                    }, Phaser.Point.prototype.constructor = Phaser.Point, Phaser.Point.add = function(a, b, out) {
                        return "undefined" == typeof out && (out = new Phaser.Point()), out.x = a.x + b.x, 
                        out.y = a.y + b.y, out;
                    }, Phaser.Point.subtract = function(a, b, out) {
                        return "undefined" == typeof out && (out = new Phaser.Point()), out.x = a.x - b.x, 
                        out.y = a.y - b.y, out;
                    }, Phaser.Point.multiply = function(a, b, out) {
                        return "undefined" == typeof out && (out = new Phaser.Point()), out.x = a.x * b.x, 
                        out.y = a.y * b.y, out;
                    }, Phaser.Point.divide = function(a, b, out) {
                        return "undefined" == typeof out && (out = new Phaser.Point()), out.x = a.x / b.x, 
                        out.y = a.y / b.y, out;
                    }, Phaser.Point.equals = function(a, b) {
                        return a.x === b.x && a.y === b.y;
                    }, Phaser.Point.angle = function(a, b) {
                        return Math.atan2(a.y - b.y, a.x - b.x);
                    }, Phaser.Point.negative = function(a, out) {
                        return "undefined" == typeof out && (out = new Phaser.Point()), out.setTo(-a.x, -a.y);
                    }, Phaser.Point.multiplyAdd = function(a, b, s, out) {
                        return "undefined" == typeof out && (out = new Phaser.Point()), out.setTo(a.x + b.x * s, a.y + b.y * s);
                    }, Phaser.Point.interpolate = function(a, b, f, out) {
                        return "undefined" == typeof out && (out = new Phaser.Point()), out.setTo(a.x + (b.x - a.x) * f, a.y + (b.y - a.y) * f);
                    }, Phaser.Point.perp = function(a, out) {
                        return "undefined" == typeof out && (out = new Phaser.Point()), out.setTo(-a.y, a.x);
                    }, Phaser.Point.rperp = function(a, out) {
                        return "undefined" == typeof out && (out = new Phaser.Point()), out.setTo(a.y, -a.x);
                    }, Phaser.Point.distance = function(a, b, round) {
                        var distance = Phaser.Math.distance(a.x, a.y, b.x, b.y);
                        return round ? Math.round(distance) : distance;
                    }, Phaser.Point.project = function(a, b, out) {
                        "undefined" == typeof out && (out = new Phaser.Point());
                        var amt = a.dot(b) / b.getMagnitudeSq();
                        return 0 !== amt && out.setTo(amt * b.x, amt * b.y), out;
                    }, Phaser.Point.projectUnit = function(a, b, out) {
                        "undefined" == typeof out && (out = new Phaser.Point());
                        var amt = a.dot(b);
                        return 0 !== amt && out.setTo(amt * b.x, amt * b.y), out;
                    }, Phaser.Point.normalRightHand = function(a, out) {
                        return "undefined" == typeof out && (out = new Phaser.Point()), out.setTo(-1 * a.y, a.x);
                    }, Phaser.Point.normalize = function(a, out) {
                        "undefined" == typeof out && (out = new Phaser.Point());
                        var m = a.getMagnitude();
                        return 0 !== m && out.setTo(a.x / m, a.y / m), out;
                    }, Phaser.Point.rotate = function(a, x, y, angle, asDegrees, distance) {
                        asDegrees = asDegrees || !1, distance = distance || null, asDegrees && (angle = Phaser.Math.degToRad(angle)), 
                        null === distance && (distance = Math.sqrt((x - a.x) * (x - a.x) + (y - a.y) * (y - a.y)));
                        var requiredAngle = angle + Math.atan2(a.y - y, a.x - x);
                        return a.setTo(x + distance * Math.cos(requiredAngle), y + distance * Math.sin(requiredAngle));
                    }, Phaser.Point.centroid = function(points, out) {
                        if ("undefined" == typeof out && (out = new Phaser.Point()), "[object Array]" !== Object.prototype.toString.call(points)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
                        var pointslength = points.length;
                        if (1 > pointslength) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
                        if (1 === pointslength) return out.copyFrom(points[0]), out;
                        for (var i = 0; pointslength > i; i++) Phaser.Point.add(out, points[i], out);
                        return out.divide(pointslength, pointslength), out;
                    }, Phaser.Point.parse = function(obj, xProp, yProp) {
                        xProp = xProp || "x", yProp = yProp || "y";
                        var point = new Phaser.Point();
                        return obj[xProp] && (point.x = parseInt(obj[xProp], 10)), obj[yProp] && (point.y = parseInt(obj[yProp], 10)), 
                        point;
                    }, PIXI.Point = Phaser.Point, Phaser.Rectangle = function(x, y, width, height) {
                        x = x || 0, y = y || 0, width = width || 0, height = height || 0, this.x = x, this.y = y, 
                        this.width = width, this.height = height;
                    }, Phaser.Rectangle.prototype = {
                        offset: function(dx, dy) {
                            return this.x += dx, this.y += dy, this;
                        },
                        offsetPoint: function(point) {
                            return this.offset(point.x, point.y);
                        },
                        setTo: function(x, y, width, height) {
                            return this.x = x, this.y = y, this.width = width, this.height = height, this;
                        },
                        scale: function(x, y) {
                            return "undefined" == typeof y && (y = x), this.width *= x, this.height *= y, this;
                        },
                        centerOn: function(x, y) {
                            return this.centerX = x, this.centerY = y, this;
                        },
                        floor: function() {
                            this.x = Math.floor(this.x), this.y = Math.floor(this.y);
                        },
                        floorAll: function() {
                            this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), 
                            this.height = Math.floor(this.height);
                        },
                        copyFrom: function(source) {
                            return this.setTo(source.x, source.y, source.width, source.height);
                        },
                        copyTo: function(dest) {
                            return dest.x = this.x, dest.y = this.y, dest.width = this.width, dest.height = this.height, 
                            dest;
                        },
                        inflate: function(dx, dy) {
                            return Phaser.Rectangle.inflate(this, dx, dy);
                        },
                        size: function(output) {
                            return Phaser.Rectangle.size(this, output);
                        },
                        clone: function(output) {
                            return Phaser.Rectangle.clone(this, output);
                        },
                        contains: function(x, y) {
                            return Phaser.Rectangle.contains(this, x, y);
                        },
                        containsRect: function(b) {
                            return Phaser.Rectangle.containsRect(b, this);
                        },
                        equals: function(b) {
                            return Phaser.Rectangle.equals(this, b);
                        },
                        intersection: function(b, out) {
                            return Phaser.Rectangle.intersection(this, b, out);
                        },
                        intersects: function(b) {
                            return Phaser.Rectangle.intersects(this, b);
                        },
                        intersectsRaw: function(left, right, top, bottom, tolerance) {
                            return Phaser.Rectangle.intersectsRaw(this, left, right, top, bottom, tolerance);
                        },
                        union: function(b, out) {
                            return Phaser.Rectangle.union(this, b, out);
                        },
                        toString: function() {
                            return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]";
                        }
                    }, Object.defineProperty(Phaser.Rectangle.prototype, "halfWidth", {
                        get: function() {
                            return Math.round(this.width / 2);
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "halfHeight", {
                        get: function() {
                            return Math.round(this.height / 2);
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "bottom", {
                        get: function() {
                            return this.y + this.height;
                        },
                        set: function(value) {
                            this.height = value <= this.y ? 0 : value - this.y;
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "bottomRight", {
                        get: function() {
                            return new Phaser.Point(this.right, this.bottom);
                        },
                        set: function(value) {
                            this.right = value.x, this.bottom = value.y;
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "left", {
                        get: function() {
                            return this.x;
                        },
                        set: function(value) {
                            this.width = value >= this.right ? 0 : this.right - value, this.x = value;
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "right", {
                        get: function() {
                            return this.x + this.width;
                        },
                        set: function(value) {
                            this.width = value <= this.x ? 0 : value - this.x;
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "volume", {
                        get: function() {
                            return this.width * this.height;
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "perimeter", {
                        get: function() {
                            return 2 * this.width + 2 * this.height;
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "centerX", {
                        get: function() {
                            return this.x + this.halfWidth;
                        },
                        set: function(value) {
                            this.x = value - this.halfWidth;
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "centerY", {
                        get: function() {
                            return this.y + this.halfHeight;
                        },
                        set: function(value) {
                            this.y = value - this.halfHeight;
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "randomX", {
                        get: function() {
                            return this.x + Math.random() * this.width;
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "randomY", {
                        get: function() {
                            return this.y + Math.random() * this.height;
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "top", {
                        get: function() {
                            return this.y;
                        },
                        set: function(value) {
                            value >= this.bottom ? (this.height = 0, this.y = value) : this.height = this.bottom - value;
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "topLeft", {
                        get: function() {
                            return new Phaser.Point(this.x, this.y);
                        },
                        set: function(value) {
                            this.x = value.x, this.y = value.y;
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "topRight", {
                        get: function() {
                            return new Phaser.Point(this.x + this.width, this.y);
                        },
                        set: function(value) {
                            this.right = value.x, this.y = value.y;
                        }
                    }), Object.defineProperty(Phaser.Rectangle.prototype, "empty", {
                        get: function() {
                            return !this.width || !this.height;
                        },
                        set: function(value) {
                            value === !0 && this.setTo(0, 0, 0, 0);
                        }
                    }), Phaser.Rectangle.prototype.constructor = Phaser.Rectangle, Phaser.Rectangle.inflate = function(a, dx, dy) {
                        return a.x -= dx, a.width += 2 * dx, a.y -= dy, a.height += 2 * dy, a;
                    }, Phaser.Rectangle.inflatePoint = function(a, point) {
                        return Phaser.Rectangle.inflate(a, point.x, point.y);
                    }, Phaser.Rectangle.size = function(a, output) {
                        return "undefined" == typeof output || null === output ? output = new Phaser.Point(a.width, a.height) : output.setTo(a.width, a.height), 
                        output;
                    }, Phaser.Rectangle.clone = function(a, output) {
                        return "undefined" == typeof output || null === output ? output = new Phaser.Rectangle(a.x, a.y, a.width, a.height) : output.setTo(a.x, a.y, a.width, a.height), 
                        output;
                    }, Phaser.Rectangle.contains = function(a, x, y) {
                        return a.width <= 0 || a.height <= 0 ? !1 : x >= a.x && x < a.right && y >= a.y && y < a.bottom;
                    }, Phaser.Rectangle.containsRaw = function(rx, ry, rw, rh, x, y) {
                        return x >= rx && rx + rw > x && y >= ry && ry + rh > y;
                    }, Phaser.Rectangle.containsPoint = function(a, point) {
                        return Phaser.Rectangle.contains(a, point.x, point.y);
                    }, Phaser.Rectangle.containsRect = function(a, b) {
                        return a.volume > b.volume ? !1 : a.x >= b.x && a.y >= b.y && a.right < b.right && a.bottom < b.bottom;
                    }, Phaser.Rectangle.equals = function(a, b) {
                        return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height;
                    }, Phaser.Rectangle.sameDimensions = function(a, b) {
                        return a.width === b.width && a.height === b.height;
                    }, Phaser.Rectangle.intersection = function(a, b, output) {
                        return "undefined" == typeof output && (output = new Phaser.Rectangle()), Phaser.Rectangle.intersects(a, b) && (output.x = Math.max(a.x, b.x), 
                        output.y = Math.max(a.y, b.y), output.width = Math.min(a.right, b.right) - output.x, 
                        output.height = Math.min(a.bottom, b.bottom) - output.y), output;
                    }, Phaser.Rectangle.intersects = function(a, b) {
                        return a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0 ? !1 : !(a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom);
                    }, Phaser.Rectangle.intersectsRaw = function(a, left, right, top, bottom, tolerance) {
                        return "undefined" == typeof tolerance && (tolerance = 0), !(left > a.right + tolerance || right < a.left - tolerance || top > a.bottom + tolerance || bottom < a.top - tolerance);
                    }, Phaser.Rectangle.union = function(a, b, output) {
                        return "undefined" == typeof output && (output = new Phaser.Rectangle()), output.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top));
                    }, Phaser.Rectangle.aabb = function(points, out) {
                        "undefined" == typeof out && (out = new Phaser.Rectangle());
                        var xMax = Number.MIN_VALUE, xMin = Number.MAX_VALUE, yMax = Number.MIN_VALUE, yMin = Number.MAX_VALUE;
                        return points.forEach(function(point) {
                            point.x > xMax && (xMax = point.x), point.x < xMin && (xMin = point.x), point.y > yMax && (yMax = point.y), 
                            point.y < yMin && (yMin = point.y);
                        }), out.setTo(xMin, yMin, xMax - xMin, yMax - yMin), out;
                    }, PIXI.Rectangle = Phaser.Rectangle, PIXI.EmptyRectangle = new Phaser.Rectangle(0, 0, 0, 0), 
                    Phaser.Line = function(x1, y1, x2, y2) {
                        x1 = x1 || 0, y1 = y1 || 0, x2 = x2 || 0, y2 = y2 || 0, this.start = new Phaser.Point(x1, y1), 
                        this.end = new Phaser.Point(x2, y2);
                    }, Phaser.Line.prototype = {
                        setTo: function(x1, y1, x2, y2) {
                            return this.start.setTo(x1, y1), this.end.setTo(x2, y2), this;
                        },
                        fromSprite: function(startSprite, endSprite, useCenter) {
                            return "undefined" == typeof useCenter && (useCenter = !1), useCenter ? this.setTo(startSprite.center.x, startSprite.center.y, endSprite.center.x, endSprite.center.y) : this.setTo(startSprite.x, startSprite.y, endSprite.x, endSprite.y);
                        },
                        fromAngle: function(x, y, angle, length) {
                            return this.start.setTo(x, y), this.end.setTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length), 
                            this;
                        },
                        intersects: function(line, asSegment, result) {
                            return Phaser.Line.intersectsPoints(this.start, this.end, line.start, line.end, asSegment, result);
                        },
                        reflect: function(line) {
                            return Phaser.Line.reflect(this, line);
                        },
                        pointOnLine: function(x, y) {
                            return (x - this.start.x) * (this.end.y - this.start.y) === (this.end.x - this.start.x) * (y - this.start.y);
                        },
                        pointOnSegment: function(x, y) {
                            var xMin = Math.min(this.start.x, this.end.x), xMax = Math.max(this.start.x, this.end.x), yMin = Math.min(this.start.y, this.end.y), yMax = Math.max(this.start.y, this.end.y);
                            return this.pointOnLine(x, y) && x >= xMin && xMax >= x && y >= yMin && yMax >= y;
                        },
                        coordinatesOnLine: function(stepRate, results) {
                            "undefined" == typeof stepRate && (stepRate = 1), "undefined" == typeof results && (results = []);
                            var x1 = Math.round(this.start.x), y1 = Math.round(this.start.y), x2 = Math.round(this.end.x), y2 = Math.round(this.end.y), dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1), sx = x2 > x1 ? 1 : -1, sy = y2 > y1 ? 1 : -1, err = dx - dy;
                            results.push([ x1, y1 ]);
                            for (var i = 1; x1 != x2 || y1 != y2; ) {
                                var e2 = err << 1;
                                e2 > -dy && (err -= dy, x1 += sx), dx > e2 && (err += dx, y1 += sy), i % stepRate === 0 && results.push([ x1, y1 ]), 
                                i++;
                            }
                            return results;
                        },
                        clone: function(output) {
                            return "undefined" == typeof output || null === output ? output = new Phaser.Line(this.start.x, this.start.y, this.end.x, this.end.y) : output.setTo(this.start.x, this.start.y, this.end.x, this.end.y), 
                            output;
                        }
                    }, Object.defineProperty(Phaser.Line.prototype, "length", {
                        get: function() {
                            return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y));
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "angle", {
                        get: function() {
                            return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x);
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "slope", {
                        get: function() {
                            return (this.end.y - this.start.y) / (this.end.x - this.start.x);
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "perpSlope", {
                        get: function() {
                            return -((this.end.x - this.start.x) / (this.end.y - this.start.y));
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "x", {
                        get: function() {
                            return Math.min(this.start.x, this.end.x);
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "y", {
                        get: function() {
                            return Math.min(this.start.y, this.end.y);
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "left", {
                        get: function() {
                            return Math.min(this.start.x, this.end.x);
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "right", {
                        get: function() {
                            return Math.max(this.start.x, this.end.x);
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "top", {
                        get: function() {
                            return Math.min(this.start.y, this.end.y);
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "bottom", {
                        get: function() {
                            return Math.max(this.start.y, this.end.y);
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "width", {
                        get: function() {
                            return Math.abs(this.start.x - this.end.x);
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "height", {
                        get: function() {
                            return Math.abs(this.start.y - this.end.y);
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "normalX", {
                        get: function() {
                            return Math.cos(this.angle - 1.5707963267948966);
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "normalY", {
                        get: function() {
                            return Math.sin(this.angle - 1.5707963267948966);
                        }
                    }), Object.defineProperty(Phaser.Line.prototype, "normalAngle", {
                        get: function() {
                            return Phaser.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI);
                        }
                    }), Phaser.Line.intersectsPoints = function(a, b, e, f, asSegment, result) {
                        "undefined" == typeof asSegment && (asSegment = !0), "undefined" == typeof result && (result = new Phaser.Point());
                        var a1 = b.y - a.y, a2 = f.y - e.y, b1 = a.x - b.x, b2 = e.x - f.x, c1 = b.x * a.y - a.x * b.y, c2 = f.x * e.y - e.x * f.y, denom = a1 * b2 - a2 * b1;
                        if (0 === denom) return null;
                        if (result.x = (b1 * c2 - b2 * c1) / denom, result.y = (a2 * c1 - a1 * c2) / denom, 
                        asSegment) {
                            var uc = (f.y - e.y) * (b.x - a.x) - (f.x - e.x) * (b.y - a.y), ua = ((f.x - e.x) * (a.y - e.y) - (f.y - e.y) * (a.x - e.x)) / uc, ub = ((b.x - a.x) * (a.y - e.y) - (b.y - a.y) * (a.x - e.x)) / uc;
                            return ua >= 0 && 1 >= ua && ub >= 0 && 1 >= ub ? result : null;
                        }
                        return result;
                    }, Phaser.Line.intersects = function(a, b, asSegment, result) {
                        return Phaser.Line.intersectsPoints(a.start, a.end, b.start, b.end, asSegment, result);
                    }, Phaser.Line.reflect = function(a, b) {
                        return 2 * b.normalAngle - 3.141592653589793 - a.angle;
                    }, Phaser.Ellipse = function(x, y, width, height) {
                        this.type = Phaser.ELLIPSE, x = x || 0, y = y || 0, width = width || 0, height = height || 0, 
                        this.x = x, this.y = y, this.width = width, this.height = height;
                    }, Phaser.Ellipse.prototype = {
                        setTo: function(x, y, width, height) {
                            return this.x = x, this.y = y, this.width = width, this.height = height, this;
                        },
                        getBounds: function() {
                            return new Phaser.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
                        },
                        copyFrom: function(source) {
                            return this.setTo(source.x, source.y, source.width, source.height);
                        },
                        copyTo: function(dest) {
                            return dest.x = this.x, dest.y = this.y, dest.width = this.width, dest.height = this.height, 
                            dest;
                        },
                        clone: function(output) {
                            return "undefined" == typeof output || null === output ? output = new Phaser.Ellipse(this.x, this.y, this.width, this.height) : output.setTo(this.x, this.y, this.width, this.height), 
                            output;
                        },
                        contains: function(x, y) {
                            return Phaser.Ellipse.contains(this, x, y);
                        },
                        toString: function() {
                            return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]";
                        }
                    }, Phaser.Ellipse.prototype.constructor = Phaser.Ellipse, Object.defineProperty(Phaser.Ellipse.prototype, "left", {
                        get: function() {
                            return this.x;
                        },
                        set: function(value) {
                            this.x = value;
                        }
                    }), Object.defineProperty(Phaser.Ellipse.prototype, "right", {
                        get: function() {
                            return this.x + this.width;
                        },
                        set: function(value) {
                            this.width = value < this.x ? 0 : value - this.x;
                        }
                    }), Object.defineProperty(Phaser.Ellipse.prototype, "top", {
                        get: function() {
                            return this.y;
                        },
                        set: function(value) {
                            this.y = value;
                        }
                    }), Object.defineProperty(Phaser.Ellipse.prototype, "bottom", {
                        get: function() {
                            return this.y + this.height;
                        },
                        set: function(value) {
                            this.height = value < this.y ? 0 : value - this.y;
                        }
                    }), Object.defineProperty(Phaser.Ellipse.prototype, "empty", {
                        get: function() {
                            return 0 === this.width || 0 === this.height;
                        },
                        set: function(value) {
                            value === !0 && this.setTo(0, 0, 0, 0);
                        }
                    }), Phaser.Ellipse.contains = function(a, x, y) {
                        if (a.width <= 0 || a.height <= 0) return !1;
                        var normx = (x - a.x) / a.width, normy = (y - a.y) / a.height;
                        return normx *= normx, normy *= normy, 1 >= normx + normy;
                    }, PIXI.Ellipse = Phaser.Ellipse, Phaser.Polygon = function() {
                        this.type = Phaser.POLYGON, this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), 
                        this.closed = !0;
                    }, Phaser.Polygon.prototype = {
                        clone: function(output) {
                            var points = this._points.slice();
                            return "undefined" == typeof output || null === output ? output = new Phaser.Polygon(points) : output.setTo(points), 
                            output;
                        },
                        contains: function(x, y) {
                            for (var length = this._points.length, inside = !1, i = -1, j = length - 1; ++i < length; j = i) {
                                var ix = this._points[i].x, iy = this._points[i].y, jx = this._points[j].x, jy = this._points[j].y;
                                (y >= iy && jy > y || y >= jy && iy > y) && (jx - ix) * (y - iy) / (jy - iy) + ix > x && (inside = !inside);
                            }
                            return inside;
                        },
                        setTo: function(points) {
                            if (this.area = 0, this._points = [], arguments.length > 0) {
                                Array.isArray(points) || (points = Array.prototype.slice.call(arguments));
                                for (var y0 = Number.MAX_VALUE, i = 0, len = points.length; len > i; i++) {
                                    if ("number" == typeof points[i]) {
                                        var p = new Phaser.Point(points[i], points[i + 1]);
                                        i++;
                                    } else var p = new Phaser.Point(points[i].x, points[i].y);
                                    this._points.push(p), p.y < y0 && (y0 = p.y);
                                }
                                this.calculateArea(y0);
                            }
                            return this;
                        },
                        calculateArea: function(y0) {
                            for (var p1, p2, avgHeight, width, i = 0, len = this._points.length; len > i; i++) p1 = this._points[i], 
                            p2 = i === len - 1 ? this._points[0] : this._points[i + 1], avgHeight = (p1.y - y0 + (p2.y - y0)) / 2, 
                            width = p1.x - p2.x, this.area += avgHeight * width;
                            return this.area;
                        }
                    }, Phaser.Polygon.prototype.constructor = Phaser.Polygon, Object.defineProperty(Phaser.Polygon.prototype, "points", {
                        get: function() {
                            return this._points;
                        },
                        set: function(points) {
                            null != points ? this.setTo(points) : this.setTo();
                        }
                    }), PIXI.Graphics = function() {
                        PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, 
                        this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, 
                        this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], 
                        this.isMask = !1, this.boundsPadding = 0, this._localBounds = new PIXI.Rectangle(0, 0, 1, 1), 
                        this.dirty = !0, this.webGLDirty = !1, this.cachedSpriteDirty = !1;
                    }, PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), 
                    PIXI.Graphics.prototype.constructor = PIXI.Graphics, Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
                        get: function() {
                            return this._cacheAsBitmap;
                        },
                        set: function(value) {
                            this._cacheAsBitmap = value, this._cacheAsBitmap ? this._generateCachedSprite() : (this.destroyCachedSprite(), 
                            this.dirty = !0);
                        }
                    }), PIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha) {
                        if (this.lineWidth = lineWidth || 0, this.lineColor = color || 0, this.lineAlpha = arguments.length < 3 ? 1 : alpha, 
                        this.currentPath) {
                            if (this.currentPath.shape.points.length) return this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))), 
                            this;
                            this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, 
                            this.currentPath.lineAlpha = this.lineAlpha;
                        }
                        return this;
                    }, PIXI.Graphics.prototype.moveTo = function(x, y) {
                        return this.drawShape(new PIXI.Polygon([ x, y ])), this;
                    }, PIXI.Graphics.prototype.lineTo = function(x, y) {
                        return this.currentPath.shape.points.push(x, y), this.dirty = !0, this;
                    }, PIXI.Graphics.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
                        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [ 0, 0 ]) : this.moveTo(0, 0);
                        var xa, ya, n = 20, points = this.currentPath.shape.points;
                        0 === points.length && this.moveTo(0, 0);
                        for (var fromX = points[points.length - 2], fromY = points[points.length - 1], j = 0, i = 1; n >= i; i++) j = i / n, 
                        xa = fromX + (cpX - fromX) * j, ya = fromY + (cpY - fromY) * j, points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
                        return this.dirty = !0, this;
                    }, PIXI.Graphics.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
                        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [ 0, 0 ]) : this.moveTo(0, 0);
                        for (var dt, dt2, dt3, t2, t3, n = 20, points = this.currentPath.shape.points, fromX = points[points.length - 2], fromY = points[points.length - 1], j = 0, i = 1; n >= i; i++) j = i / n, 
                        dt = 1 - j, dt2 = dt * dt, dt3 = dt2 * dt, t2 = j * j, t3 = t2 * j, points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
                        return this.dirty = !0, this;
                    }, PIXI.Graphics.prototype.arcTo = function(x1, y1, x2, y2, radius) {
                        this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(x1, y1) : this.moveTo(x1, y1);
                        var points = this.currentPath.shape.points, fromX = points[points.length - 2], fromY = points[points.length - 1], a1 = fromY - y1, b1 = fromX - x1, a2 = y2 - y1, b2 = x2 - x1, mm = Math.abs(a1 * b2 - b1 * a2);
                        if (1e-8 > mm || 0 === radius) (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) && points.push(x1, y1); else {
                            var dd = a1 * a1 + b1 * b1, cc = a2 * a2 + b2 * b2, tt = a1 * a2 + b1 * b2, k1 = radius * Math.sqrt(dd) / mm, k2 = radius * Math.sqrt(cc) / mm, j1 = k1 * tt / dd, j2 = k2 * tt / cc, cx = k1 * b2 + k2 * b1, cy = k1 * a2 + k2 * a1, px = b1 * (k2 + j1), py = a1 * (k2 + j1), qx = b2 * (k1 + j2), qy = a2 * (k1 + j2), startAngle = Math.atan2(py - cy, px - cx), endAngle = Math.atan2(qy - cy, qx - cx);
                            this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
                        }
                        return this.dirty = !0, this;
                    }, PIXI.Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
                        var points, startX = cx + Math.cos(startAngle) * radius, startY = cy + Math.sin(startAngle) * radius;
                        if (this.currentPath ? (points = this.currentPath.shape.points, 0 === points.length ? points.push(startX, startY) : (points[points.length - 2] !== startX || points[points.length - 1] !== startY) && points.push(startX, startY)) : (this.moveTo(startX, startY), 
                        points = this.currentPath.shape.points), startAngle === endAngle) return this;
                        !anticlockwise && startAngle >= endAngle ? endAngle += 2 * Math.PI : anticlockwise && endAngle >= startAngle && (startAngle += 2 * Math.PI);
                        var sweep = anticlockwise ? -1 * (startAngle - endAngle) : endAngle - startAngle, segs = Math.abs(sweep) / (2 * Math.PI) * 40;
                        if (0 === sweep) return this;
                        for (var theta = sweep / (2 * segs), theta2 = 2 * theta, cTheta = Math.cos(theta), sTheta = Math.sin(theta), segMinus = segs - 1, remainder = segMinus % 1 / segMinus, i = 0; segMinus >= i; i++) {
                            var real = i + remainder * i, angle = theta + startAngle + theta2 * real, c = Math.cos(angle), s = -Math.sin(angle);
                            points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
                        }
                        return this.dirty = !0, this;
                    }, PIXI.Graphics.prototype.beginFill = function(color, alpha) {
                        return this.filling = !0, this.fillColor = color || 0, this.fillAlpha = void 0 === alpha ? 1 : alpha, 
                        this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, 
                        this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), 
                        this;
                    }, PIXI.Graphics.prototype.endFill = function() {
                        return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this;
                    }, PIXI.Graphics.prototype.drawRect = function(x, y, width, height) {
                        return this.drawShape(new PIXI.Rectangle(x, y, width, height)), this;
                    }, PIXI.Graphics.prototype.drawRoundedRect = function(x, y, width, height, radius) {
                        return this.drawShape(new PIXI.RoundedRectangle(x, y, width, height, radius)), this;
                    }, PIXI.Graphics.prototype.drawCircle = function(x, y, radius) {
                        return this.drawShape(new PIXI.Circle(x, y, radius)), this;
                    }, PIXI.Graphics.prototype.drawEllipse = function(x, y, width, height) {
                        return this.drawShape(new PIXI.Ellipse(x, y, width, height)), this;
                    }, PIXI.Graphics.prototype.drawPolygon = function(path) {
                        return path instanceof Array || (path = Array.prototype.slice.call(arguments)), 
                        this.drawShape(new PIXI.Polygon(path)), this;
                    }, PIXI.Graphics.prototype.clear = function() {
                        return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this.clearDirty = !0, 
                        this.graphicsData = [], this;
                    }, PIXI.Graphics.prototype.generateTexture = function(resolution, scaleMode) {
                        resolution = resolution || 1;
                        var bounds = this.getBounds(), canvasBuffer = new PIXI.CanvasBuffer(bounds.width * resolution, bounds.height * resolution), texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas, scaleMode);
                        return texture.baseTexture.resolution = resolution, canvasBuffer.context.scale(resolution, resolution), 
                        canvasBuffer.context.translate(-bounds.x, -bounds.y), PIXI.CanvasGraphics.renderGraphics(this, canvasBuffer.context), 
                        texture;
                    }, PIXI.Graphics.prototype._renderWebGL = function(renderSession) {
                        if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
                            if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), 
                            this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), 
                            this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);
                            if (renderSession.spriteBatch.stop(), renderSession.blendModeManager.setBlendMode(this.blendMode), 
                            this._mask && renderSession.maskManager.pushMask(this._mask, renderSession), this._filters && renderSession.filterManager.pushFilter(this._filterBlock), 
                            this.blendMode !== renderSession.spriteBatch.currentBlendMode) {
                                renderSession.spriteBatch.currentBlendMode = this.blendMode;
                                var blendModeWebGL = PIXI.blendModesWebGL[renderSession.spriteBatch.currentBlendMode];
                                renderSession.spriteBatch.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
                            }
                            if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, renderSession), 
                            this.children.length) {
                                renderSession.spriteBatch.start();
                                for (var i = 0, j = this.children.length; j > i; i++) this.children[i]._renderWebGL(renderSession);
                                renderSession.spriteBatch.stop();
                            }
                            this._filters && renderSession.filterManager.popFilter(), this._mask && renderSession.maskManager.popMask(this.mask, renderSession), 
                            renderSession.drawCount++, renderSession.spriteBatch.start();
                        }
                    }, PIXI.Graphics.prototype._renderCanvas = function(renderSession) {
                        if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
                            if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), 
                            this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), 
                            this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);
                            var context = renderSession.context, transform = this.worldTransform;
                            this.blendMode !== renderSession.currentBlendMode && (renderSession.currentBlendMode = this.blendMode, 
                            context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode]), 
                            this._mask && renderSession.maskManager.pushMask(this._mask, renderSession);
                            var resolution = renderSession.resolution;
                            context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution), 
                            PIXI.CanvasGraphics.renderGraphics(this, context);
                            for (var i = 0, j = this.children.length; j > i; i++) this.children[i]._renderCanvas(renderSession);
                            this._mask && renderSession.maskManager.popMask(renderSession);
                        }
                    }, PIXI.Graphics.prototype.getBounds = function(matrix) {
                        if (this.isMask) return PIXI.EmptyRectangle;
                        this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, 
                        this.dirty = !1);
                        var bounds = this._localBounds, w0 = bounds.x, w1 = bounds.width + bounds.x, h0 = bounds.y, h1 = bounds.height + bounds.y, worldTransform = matrix || this.worldTransform, a = worldTransform.a, b = worldTransform.b, c = worldTransform.c, d = worldTransform.d, tx = worldTransform.tx, ty = worldTransform.ty, x1 = a * w1 + c * h1 + tx, y1 = d * h1 + b * w1 + ty, x2 = a * w0 + c * h1 + tx, y2 = d * h1 + b * w0 + ty, x3 = a * w0 + c * h0 + tx, y3 = d * h0 + b * w0 + ty, x4 = a * w1 + c * h0 + tx, y4 = d * h0 + b * w1 + ty, maxX = x1, maxY = y1, minX = x1, minY = y1;
                        return minX = minX > x2 ? x2 : minX, minX = minX > x3 ? x3 : minX, minX = minX > x4 ? x4 : minX, 
                        minY = minY > y2 ? y2 : minY, minY = minY > y3 ? y3 : minY, minY = minY > y4 ? y4 : minY, 
                        maxX = x2 > maxX ? x2 : maxX, maxX = x3 > maxX ? x3 : maxX, maxX = x4 > maxX ? x4 : maxX, 
                        maxY = y2 > maxY ? y2 : maxY, maxY = y3 > maxY ? y3 : maxY, maxY = y4 > maxY ? y4 : maxY, 
                        this._bounds.x = minX, this._bounds.width = maxX - minX, this._bounds.y = minY, 
                        this._bounds.height = maxY - minY, this._bounds;
                    }, PIXI.Graphics.prototype.updateLocalBounds = function() {
                        var minX = 1 / 0, maxX = -(1 / 0), minY = 1 / 0, maxY = -(1 / 0);
                        if (this.graphicsData.length) for (var shape, points, x, y, w, h, i = 0; i < this.graphicsData.length; i++) {
                            var data = this.graphicsData[i], type = data.type, lineWidth = data.lineWidth;
                            if (shape = data.shape, type === PIXI.Graphics.RECT || type === PIXI.Graphics.RREC) x = shape.x - lineWidth / 2, 
                            y = shape.y - lineWidth / 2, w = shape.width + lineWidth, h = shape.height + lineWidth, 
                            minX = minX > x ? x : minX, maxX = x + w > maxX ? x + w : maxX, minY = minY > y ? y : minY, 
                            maxY = y + h > maxY ? y + h : maxY; else if (type === PIXI.Graphics.CIRC) x = shape.x, 
                            y = shape.y, w = shape.radius + lineWidth / 2, h = shape.radius + lineWidth / 2, 
                            minX = minX > x - w ? x - w : minX, maxX = x + w > maxX ? x + w : maxX, minY = minY > y - h ? y - h : minY, 
                            maxY = y + h > maxY ? y + h : maxY; else if (type === PIXI.Graphics.ELIP) x = shape.x, 
                            y = shape.y, w = shape.width + lineWidth / 2, h = shape.height + lineWidth / 2, 
                            minX = minX > x - w ? x - w : minX, maxX = x + w > maxX ? x + w : maxX, minY = minY > y - h ? y - h : minY, 
                            maxY = y + h > maxY ? y + h : maxY; else {
                                points = shape.points;
                                for (var j = 0; j < points.length; j += 2) x = points[j], y = points[j + 1], minX = minX > x - lineWidth ? x - lineWidth : minX, 
                                maxX = x + lineWidth > maxX ? x + lineWidth : maxX, minY = minY > y - lineWidth ? y - lineWidth : minY, 
                                maxY = y + lineWidth > maxY ? y + lineWidth : maxY;
                            }
                        } else minX = 0, maxX = 0, minY = 0, maxY = 0;
                        var padding = this.boundsPadding;
                        this._localBounds.x = minX - padding, this._localBounds.width = maxX - minX + 2 * padding, 
                        this._localBounds.y = minY - padding, this._localBounds.height = maxY - minY + 2 * padding;
                    }, PIXI.Graphics.prototype._generateCachedSprite = function() {
                        var bounds = this.getLocalBounds();
                        if (this._cachedSprite) this._cachedSprite.buffer.resize(bounds.width, bounds.height); else {
                            var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height), texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
                            this._cachedSprite = new PIXI.Sprite(texture), this._cachedSprite.buffer = canvasBuffer, 
                            this._cachedSprite.worldTransform = this.worldTransform;
                        }
                        this._cachedSprite.anchor.x = -(bounds.x / bounds.width), this._cachedSprite.anchor.y = -(bounds.y / bounds.height), 
                        this._cachedSprite.buffer.context.translate(-bounds.x, -bounds.y), this.worldAlpha = 1, 
                        PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha;
                    }, PIXI.Graphics.prototype.updateCachedSpriteTexture = function() {
                        var cachedSprite = this._cachedSprite, texture = cachedSprite.texture, canvas = cachedSprite.buffer.canvas;
                        texture.baseTexture.width = canvas.width, texture.baseTexture.height = canvas.height, 
                        texture.crop.width = texture.frame.width = canvas.width, texture.crop.height = texture.frame.height = canvas.height, 
                        cachedSprite._width = canvas.width, cachedSprite._height = canvas.height, texture.baseTexture.dirty();
                    }, PIXI.Graphics.prototype.destroyCachedSprite = function() {
                        this._cachedSprite.texture.destroy(!0), this._cachedSprite = null;
                    }, PIXI.Graphics.prototype.drawShape = function(shape) {
                        this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), 
                        this.currentPath = null;
                        var data = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);
                        return this.graphicsData.push(data), data.type === PIXI.Graphics.POLY && (data.shape.closed = this.filling, 
                        this.currentPath = data), this.dirty = !0, data;
                    }, PIXI.GraphicsData = function(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape) {
                        this.lineWidth = lineWidth, this.lineColor = lineColor, this.lineAlpha = lineAlpha, 
                        this._lineTint = lineColor, this.fillColor = fillColor, this.fillAlpha = fillAlpha, 
                        this._fillTint = fillColor, this.fill = fill, this.shape = shape, this.type = shape.type;
                    }, PIXI.Graphics.POLY = 0, PIXI.Graphics.RECT = 1, PIXI.Graphics.CIRC = 2, PIXI.Graphics.ELIP = 3, 
                    PIXI.Graphics.RREC = 4, PIXI.Polygon.prototype.type = PIXI.Graphics.POLY, PIXI.Rectangle.prototype.type = PIXI.Graphics.RECT, 
                    PIXI.Circle.prototype.type = PIXI.Graphics.CIRC, PIXI.Ellipse.prototype.type = PIXI.Graphics.ELIP, 
                    PIXI.RoundedRectangle.prototype.type = PIXI.Graphics.RREC, Phaser.Camera = function(game, id, x, y, width, height) {
                        this.game = game, this.world = game.world, this.id = 0, this.view = new Phaser.Rectangle(x, y, width, height), 
                        this.screenView = new Phaser.Rectangle(x, y, width, height), this.bounds = new Phaser.Rectangle(x, y, width, height), 
                        this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
                            x: !1,
                            y: !1
                        }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, 
                        this._targetPosition = new Phaser.Point(), this._edge = 0, this._position = new Phaser.Point();
                    }, Phaser.Camera.FOLLOW_LOCKON = 0, Phaser.Camera.FOLLOW_PLATFORMER = 1, Phaser.Camera.FOLLOW_TOPDOWN = 2, 
                    Phaser.Camera.FOLLOW_TOPDOWN_TIGHT = 3, Phaser.Camera.prototype = {
                        preUpdate: function() {
                            this.totalInView = 0;
                        },
                        follow: function(target, style) {
                            "undefined" == typeof style && (style = Phaser.Camera.FOLLOW_LOCKON), this.target = target;
                            var helper;
                            switch (style) {
                              case Phaser.Camera.FOLLOW_PLATFORMER:
                                var w = this.width / 8, h = this.height / 3;
                                this.deadzone = new Phaser.Rectangle((this.width - w) / 2, (this.height - h) / 2 - .25 * h, w, h);
                                break;

                              case Phaser.Camera.FOLLOW_TOPDOWN:
                                helper = Math.max(this.width, this.height) / 4, this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);
                                break;

                              case Phaser.Camera.FOLLOW_TOPDOWN_TIGHT:
                                helper = Math.max(this.width, this.height) / 8, this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);
                                break;

                              case Phaser.Camera.FOLLOW_LOCKON:
                                this.deadzone = null;
                                break;

                              default:
                                this.deadzone = null;
                            }
                        },
                        unfollow: function() {
                            this.target = null;
                        },
                        focusOn: function(displayObject) {
                            this.setPosition(Math.round(displayObject.x - this.view.halfWidth), Math.round(displayObject.y - this.view.halfHeight));
                        },
                        focusOnXY: function(x, y) {
                            this.setPosition(Math.round(x - this.view.halfWidth), Math.round(y - this.view.halfHeight));
                        },
                        update: function() {
                            this.target && this.updateTarget(), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), 
                            this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y;
                        },
                        updateTarget: function() {
                            this._targetPosition.copyFrom(this.target), this.target.parent && this._targetPosition.multiply(this.target.parent.worldTransform.a, this.target.parent.worldTransform.d), 
                            this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this._targetPosition.x - this.deadzone.left : this._edge > this.deadzone.right && (this.view.x = this._targetPosition.x - this.deadzone.right), 
                            this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this._targetPosition.y - this.deadzone.top : this._edge > this.deadzone.bottom && (this.view.y = this._targetPosition.y - this.deadzone.bottom)) : (this.view.x = this._targetPosition.x - this.view.halfWidth, 
                            this.view.y = this._targetPosition.y - this.view.halfHeight);
                        },
                        setBoundsToWorld: function() {
                            this.bounds && this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height);
                        },
                        checkBounds: function() {
                            this.atLimit.x = !1, this.atLimit.y = !1, this.view.x <= this.bounds.x && (this.atLimit.x = !0, 
                            this.view.x = this.bounds.x), this.view.right >= this.bounds.right && (this.atLimit.x = !0, 
                            this.view.x = this.bounds.right - this.width), this.view.y <= this.bounds.top && (this.atLimit.y = !0, 
                            this.view.y = this.bounds.top), this.view.bottom >= this.bounds.bottom && (this.atLimit.y = !0, 
                            this.view.y = this.bounds.bottom - this.height);
                        },
                        setPosition: function(x, y) {
                            this.view.x = x, this.view.y = y, this.bounds && this.checkBounds();
                        },
                        setSize: function(width, height) {
                            this.view.width = width, this.view.height = height;
                        },
                        reset: function() {
                            this.target = null, this.view.x = 0, this.view.y = 0;
                        }
                    }, Phaser.Camera.prototype.constructor = Phaser.Camera, Object.defineProperty(Phaser.Camera.prototype, "x", {
                        get: function() {
                            return this.view.x;
                        },
                        set: function(value) {
                            this.view.x = value, this.bounds && this.checkBounds();
                        }
                    }), Object.defineProperty(Phaser.Camera.prototype, "y", {
                        get: function() {
                            return this.view.y;
                        },
                        set: function(value) {
                            this.view.y = value, this.bounds && this.checkBounds();
                        }
                    }), Object.defineProperty(Phaser.Camera.prototype, "position", {
                        get: function() {
                            return this._position.set(this.view.centerX, this.view.centerY), this._position;
                        },
                        set: function(value) {
                            "undefined" != typeof value.x && (this.view.x = value.x), "undefined" != typeof value.y && (this.view.y = value.y), 
                            this.bounds && this.checkBounds();
                        }
                    }), Object.defineProperty(Phaser.Camera.prototype, "width", {
                        get: function() {
                            return this.view.width;
                        },
                        set: function(value) {
                            this.view.width = value;
                        }
                    }), Object.defineProperty(Phaser.Camera.prototype, "height", {
                        get: function() {
                            return this.view.height;
                        },
                        set: function(value) {
                            this.view.height = value;
                        }
                    }), Phaser.State = function() {
                        this.game = null, this.add = null, this.make = null, this.camera = null, this.cache = null, 
                        this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, 
                        this.stage = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, 
                        this.physics = null, this.rnd = null;
                    }, Phaser.State.prototype = {
                        init: function() {},
                        preload: function() {},
                        loadUpdate: function() {},
                        loadRender: function() {},
                        create: function() {},
                        update: function() {},
                        render: function() {},
                        resize: function() {},
                        paused: function() {},
                        pauseUpdate: function() {},
                        shutdown: function() {}
                    }, Phaser.State.prototype.constructor = Phaser.State, Phaser.StateManager = function(game, pendingState) {
                        this.game = game, this.states = {}, this._pendingState = null, "undefined" != typeof pendingState && null !== pendingState && (this._pendingState = pendingState), 
                        this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], 
                        this.current = "", this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, 
                        this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, 
                        this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, 
                        this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, 
                        this.onShutDownCallback = null;
                    }, Phaser.StateManager.prototype = {
                        boot: function() {
                            this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), 
                            this.game.load.onLoadComplete.add(this.loadComplete, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0);
                        },
                        add: function(key, state, autoStart) {
                            "undefined" == typeof autoStart && (autoStart = !1);
                            var newState;
                            return state instanceof Phaser.State ? newState = state : "object" == typeof state ? (newState = state, 
                            newState.game = this.game) : "function" == typeof state && (newState = new state(this.game)), 
                            this.states[key] = newState, autoStart && (this.game.isBooted ? this.start(key) : this._pendingState = key), 
                            newState;
                        },
                        remove: function(key) {
                            this.current === key && (this.callbackContext = null, this.onInitCallback = null, 
                            this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, 
                            this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, 
                            this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, 
                            this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), 
                            delete this.states[key];
                        },
                        start: function(key, clearWorld, clearCache) {
                            "undefined" == typeof clearWorld && (clearWorld = !0), "undefined" == typeof clearCache && (clearCache = !1), 
                            this.checkState(key) && (this._pendingState = key, this._clearWorld = clearWorld, 
                            this._clearCache = clearCache, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)));
                        },
                        restart: function(clearWorld, clearCache) {
                            "undefined" == typeof clearWorld && (clearWorld = !0), "undefined" == typeof clearCache && (clearCache = !1), 
                            this._pendingState = this.current, this._clearWorld = clearWorld, this._clearCache = clearCache, 
                            arguments.length > 2 && (this._args = Array.prototype.splice.call(arguments, 2));
                        },
                        dummy: function() {},
                        preUpdate: function() {
                            if (this._pendingState && this.game.isBooted) {
                                if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.current !== this._pendingState) return;
                                this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(), this.onPreloadCallback.call(this.callbackContext, this.game), 
                                0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete();
                            }
                        },
                        clearCurrentState: function() {
                            this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), 
                            this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), 
                            this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), 
                            this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), 
                            this._clearCache === !0 && this.game.cache.destroy()));
                        },
                        checkState: function(key) {
                            if (this.states[key]) {
                                var valid = !1;
                                return (this.states[key].preload || this.states[key].create || this.states[key].update || this.states[key].render) && (valid = !0), 
                                valid === !1 ? (console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render"), 
                                !1) : !0;
                            }
                            return console.warn("Phaser.StateManager - No state found with the key: " + key), 
                            !1;
                        },
                        link: function(key) {
                            this.states[key].game = this.game, this.states[key].add = this.game.add, this.states[key].make = this.game.make, 
                            this.states[key].camera = this.game.camera, this.states[key].cache = this.game.cache, 
                            this.states[key].input = this.game.input, this.states[key].load = this.game.load, 
                            this.states[key].math = this.game.math, this.states[key].sound = this.game.sound, 
                            this.states[key].scale = this.game.scale, this.states[key].state = this, this.states[key].stage = this.game.stage, 
                            this.states[key].time = this.game.time, this.states[key].tweens = this.game.tweens, 
                            this.states[key].world = this.game.world, this.states[key].particles = this.game.particles, 
                            this.states[key].rnd = this.game.rnd, this.states[key].physics = this.game.physics;
                        },
                        unlink: function(key) {
                            this.states[key] && (this.states[key].game = null, this.states[key].add = null, 
                            this.states[key].make = null, this.states[key].camera = null, this.states[key].cache = null, 
                            this.states[key].input = null, this.states[key].load = null, this.states[key].math = null, 
                            this.states[key].sound = null, this.states[key].scale = null, this.states[key].state = null, 
                            this.states[key].stage = null, this.states[key].time = null, this.states[key].tweens = null, 
                            this.states[key].world = null, this.states[key].particles = null, this.states[key].rnd = null, 
                            this.states[key].physics = null);
                        },
                        setCurrentState: function(key) {
                            this.callbackContext = this.states[key], this.link(key), this.onInitCallback = this.states[key].init || this.dummy, 
                            this.onPreloadCallback = this.states[key].preload || null, this.onLoadRenderCallback = this.states[key].loadRender || null, 
                            this.onLoadUpdateCallback = this.states[key].loadUpdate || null, this.onCreateCallback = this.states[key].create || null, 
                            this.onUpdateCallback = this.states[key].update || null, this.onPreRenderCallback = this.states[key].preRender || null, 
                            this.onRenderCallback = this.states[key].render || null, this.onResizeCallback = this.states[key].resize || null, 
                            this.onPausedCallback = this.states[key].paused || null, this.onResumedCallback = this.states[key].resumed || null, 
                            this.onPauseUpdateCallback = this.states[key].pauseUpdate || null, this.onShutDownCallback = this.states[key].shutdown || this.dummy, 
                            this.current = key, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), 
                            key === this._pendingState && (this._args = []);
                        },
                        getCurrentState: function() {
                            return this.states[this.current];
                        },
                        loadComplete: function() {
                            this._created === !1 && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0;
                        },
                        pause: function() {
                            this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game);
                        },
                        resume: function() {
                            this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game);
                        },
                        update: function() {
                            this._created && this.onUpdateCallback ? this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game);
                        },
                        pauseUpdate: function() {
                            this._created && this.onPauseUpdateCallback ? this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game);
                        },
                        preRender: function(elapsedTime) {
                            this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, elapsedTime);
                        },
                        resize: function(width, height) {
                            this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, width, height);
                        },
                        render: function() {
                            this._created && this.onRenderCallback ? (this.game.renderType === Phaser.CANVAS && (this.game.context.save(), 
                            this.game.context.setTransform(1, 0, 0, 1, 0, 0)), this.onRenderCallback.call(this.callbackContext, this.game), 
                            this.game.renderType === Phaser.CANVAS && this.game.context.restore()) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game);
                        },
                        destroy: function() {
                            this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, 
                            this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, 
                            this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, 
                            this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, 
                            this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null;
                        }
                    }, Phaser.StateManager.prototype.constructor = Phaser.StateManager, Phaser.Signal = function() {}, 
                    Phaser.Signal.prototype = {
                        _bindings: null,
                        _prevParams: null,
                        memorize: !1,
                        _shouldPropagate: !0,
                        active: !0,
                        _boundDispatch: !0,
                        validateListener: function(listener, fnName) {
                            if ("function" != typeof listener) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", fnName));
                        },
                        _registerListener: function(listener, isOnce, listenerContext, priority) {
                            var binding, prevIndex = this._indexOfListener(listener, listenerContext);
                            if (-1 !== prevIndex) {
                                if (binding = this._bindings[prevIndex], binding.isOnce() !== isOnce) throw new Error("You cannot add" + (isOnce ? "" : "Once") + "() then add" + (isOnce ? "Once" : "") + "() the same listener without removing the relationship first.");
                            } else binding = new Phaser.SignalBinding(this, listener, isOnce, listenerContext, priority), 
                            this._addBinding(binding);
                            return this.memorize && this._prevParams && binding.execute(this._prevParams), binding;
                        },
                        _addBinding: function(binding) {
                            this._bindings || (this._bindings = []);
                            var n = this._bindings.length;
                            do n--; while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
                            this._bindings.splice(n + 1, 0, binding);
                        },
                        _indexOfListener: function(listener, context) {
                            if (!this._bindings) return -1;
                            "undefined" == typeof context && (context = null);
                            for (var cur, n = this._bindings.length; n--; ) if (cur = this._bindings[n], cur._listener === listener && cur.context === context) return n;
                            return -1;
                        },
                        has: function(listener, context) {
                            return -1 !== this._indexOfListener(listener, context);
                        },
                        add: function(listener, listenerContext, priority) {
                            return this.validateListener(listener, "add"), this._registerListener(listener, !1, listenerContext, priority);
                        },
                        addOnce: function(listener, listenerContext, priority) {
                            return this.validateListener(listener, "addOnce"), this._registerListener(listener, !0, listenerContext, priority);
                        },
                        remove: function(listener, context) {
                            this.validateListener(listener, "remove");
                            var i = this._indexOfListener(listener, context);
                            return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), 
                            listener;
                        },
                        removeAll: function(context) {
                            if ("undefined" == typeof context && (context = null), this._bindings) {
                                for (var n = this._bindings.length; n--; ) context ? this._bindings[n].context === context && (this._bindings[n]._destroy(), 
                                this._bindings.splice(n, 1)) : this._bindings[n]._destroy();
                                context || (this._bindings.length = 0);
                            }
                        },
                        getNumListeners: function() {
                            return this._bindings ? this._bindings.length : 0;
                        },
                        halt: function() {
                            this._shouldPropagate = !1;
                        },
                        dispatch: function() {
                            if (this.active && this._bindings) {
                                var bindings, paramsArr = Array.prototype.slice.call(arguments), n = this._bindings.length;
                                if (this.memorize && (this._prevParams = paramsArr), n) {
                                    bindings = this._bindings.slice(), this._shouldPropagate = !0;
                                    do n--; while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== !1);
                                }
                            }
                        },
                        forget: function() {
                            this._prevParams && (this._prevParams = null);
                        },
                        dispose: function() {
                            this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null);
                        },
                        toString: function() {
                            return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
                        }
                    }, Object.defineProperty(Phaser.Signal.prototype, "boundDispatch", {
                        get: function() {
                            var _this = this;
                            return this._boundDispatch || (this._boundDispatch = function() {
                                return _this.dispatch.apply(_this, arguments);
                            });
                        }
                    }), Phaser.Signal.prototype.constructor = Phaser.Signal, Phaser.SignalBinding = function(signal, listener, isOnce, listenerContext, priority) {
                        this._listener = listener, isOnce && (this._isOnce = !0), null != listenerContext && (this.context = listenerContext), 
                        this._signal = signal, priority && (this._priority = priority);
                    }, Phaser.SignalBinding.prototype = {
                        context: null,
                        _isOnce: !1,
                        _priority: 0,
                        callCount: 0,
                        active: !0,
                        params: null,
                        execute: function(paramsArr) {
                            var handlerReturn, params;
                            return this.active && this._listener && (params = this.params ? this.params.concat(paramsArr) : paramsArr, 
                            handlerReturn = this._listener.apply(this.context, params), this.callCount++, this._isOnce && this.detach()), 
                            handlerReturn;
                        },
                        detach: function() {
                            return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
                        },
                        isBound: function() {
                            return !!this._signal && !!this._listener;
                        },
                        isOnce: function() {
                            return this._isOnce;
                        },
                        getListener: function() {
                            return this._listener;
                        },
                        getSignal: function() {
                            return this._signal;
                        },
                        _destroy: function() {
                            delete this._signal, delete this._listener, delete this.context;
                        },
                        toString: function() {
                            return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
                        }
                    }, Phaser.SignalBinding.prototype.constructor = Phaser.SignalBinding, Phaser.Filter = function(game, uniforms, fragmentSrc) {
                        this.game = game, this.type = Phaser.WEBGL_FILTER, this.passes = [ this ], this.shaders = [], 
                        this.dirty = !0, this.padding = 0, this.prevPoint = new Phaser.Point();
                        var d = new Date();
                        if (this.uniforms = {
                            resolution: {
                                type: "2f",
                                value: {
                                    x: 256,
                                    y: 256
                                }
                            },
                            time: {
                                type: "1f",
                                value: 0
                            },
                            mouse: {
                                type: "2f",
                                value: {
                                    x: 0,
                                    y: 0
                                }
                            },
                            date: {
                                type: "4fv",
                                value: [ d.getFullYear(), d.getMonth(), d.getDate(), 60 * d.getHours() * 60 + 60 * d.getMinutes() + d.getSeconds() ]
                            },
                            sampleRate: {
                                type: "1f",
                                value: 44100
                            },
                            iChannel0: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel1: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel2: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel3: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            }
                        }, uniforms) for (var key in uniforms) this.uniforms[key] = uniforms[key];
                        this.fragmentSrc = fragmentSrc || [];
                    }, Phaser.Filter.prototype = {
                        init: function() {},
                        setResolution: function(width, height) {
                            this.uniforms.resolution.value.x = width, this.uniforms.resolution.value.y = height;
                        },
                        update: function(pointer) {
                            if ("undefined" != typeof pointer) {
                                var x = pointer.x / this.game.width, y = 1 - pointer.y / this.game.height;
                                (x !== this.prevPoint.x || y !== this.prevPoint.y) && (this.uniforms.mouse.value.x = x.toFixed(2), 
                                this.uniforms.mouse.value.y = y.toFixed(2), this.prevPoint.set(x, y));
                            }
                            this.uniforms.time.value = this.game.time.totalElapsedSeconds();
                        },
                        destroy: function() {
                            this.game = null;
                        }
                    }, Phaser.Filter.prototype.constructor = Phaser.Filter, Object.defineProperty(Phaser.Filter.prototype, "width", {
                        get: function() {
                            return this.uniforms.resolution.value.x;
                        },
                        set: function(value) {
                            this.uniforms.resolution.value.x = value;
                        }
                    }), Object.defineProperty(Phaser.Filter.prototype, "height", {
                        get: function() {
                            return this.uniforms.resolution.value.y;
                        },
                        set: function(value) {
                            this.uniforms.resolution.value.y = value;
                        }
                    }), Phaser.Plugin = function(game, parent) {
                        "undefined" == typeof parent && (parent = null), this.game = game, this.parent = parent, 
                        this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, 
                        this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1;
                    }, Phaser.Plugin.prototype = {
                        preUpdate: function() {},
                        update: function() {},
                        render: function() {},
                        postRender: function() {},
                        destroy: function() {
                            this.game = null, this.parent = null, this.active = !1, this.visible = !1;
                        }
                    }, Phaser.Plugin.prototype.constructor = Phaser.Plugin, Phaser.PluginManager = function(game) {
                        this.game = game, this.plugins = [], this._len = 0, this._i = 0;
                    }, Phaser.PluginManager.prototype = {
                        add: function(plugin) {
                            var args = Array.prototype.splice.call(arguments, 1), result = !1;
                            return "function" == typeof plugin ? plugin = new plugin(this.game, this) : (plugin.game = this.game, 
                            plugin.parent = this), "function" == typeof plugin.preUpdate && (plugin.hasPreUpdate = !0, 
                            result = !0), "function" == typeof plugin.update && (plugin.hasUpdate = !0, result = !0), 
                            "function" == typeof plugin.postUpdate && (plugin.hasPostUpdate = !0, result = !0), 
                            "function" == typeof plugin.render && (plugin.hasRender = !0, result = !0), "function" == typeof plugin.postRender && (plugin.hasPostRender = !0, 
                            result = !0), result ? ((plugin.hasPreUpdate || plugin.hasUpdate || plugin.hasPostUpdate) && (plugin.active = !0), 
                            (plugin.hasRender || plugin.hasPostRender) && (plugin.visible = !0), this._len = this.plugins.push(plugin), 
                            "function" == typeof plugin.init && plugin.init.apply(plugin, args), plugin) : null;
                        },
                        remove: function(plugin) {
                            for (this._i = this._len; this._i--; ) if (this.plugins[this._i] === plugin) return plugin.destroy(), 
                            this.plugins.splice(this._i, 1), void this._len--;
                        },
                        removeAll: function() {
                            for (this._i = this._len; this._i--; ) this.plugins[this._i].destroy();
                            this.plugins.length = 0, this._len = 0;
                        },
                        preUpdate: function() {
                            for (this._i = this._len; this._i--; ) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate();
                        },
                        update: function() {
                            for (this._i = this._len; this._i--; ) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update();
                        },
                        postUpdate: function() {
                            for (this._i = this._len; this._i--; ) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate();
                        },
                        render: function() {
                            for (this._i = this._len; this._i--; ) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render();
                        },
                        postRender: function() {
                            for (this._i = this._len; this._i--; ) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender();
                        },
                        destroy: function() {
                            this.removeAll(), this.game = null;
                        }
                    }, Phaser.PluginManager.prototype.constructor = Phaser.PluginManager, Phaser.Stage = function(game) {
                        this.game = game, PIXI.Stage.call(this, 0), this.name = "_stage_root", this.interactive = !1, 
                        this.disableVisibilityChange = !1, this.exists = !0, this.currentRenderOrderID = 0, 
                        this._hiddenVar = "hidden", this._backgroundColor = 0, game.config && this.parseConfig(game.config);
                    }, Phaser.Stage.prototype = Object.create(PIXI.Stage.prototype), Phaser.Stage.prototype.constructor = Phaser.Stage, 
                    Phaser.Stage.prototype.parseConfig = function(config) {
                        config.disableVisibilityChange && (this.disableVisibilityChange = config.disableVisibilityChange), 
                        config.backgroundColor && (this.backgroundColor = config.backgroundColor);
                    }, Phaser.Stage.prototype.boot = function() {
                        Phaser.DOM.getOffset(this.game.canvas, this.offset);
                        var _this = this;
                        this._onChange = function(event) {
                            return _this.visibilityChange(event);
                        }, Phaser.Canvas.setUserSelect(this.game.canvas, "none"), Phaser.Canvas.setTouchAction(this.game.canvas, "none"), 
                        this.checkVisibility();
                    }, Phaser.Stage.prototype.preUpdate = function() {
                        this.currentRenderOrderID = 0;
                        for (var i = 0, len = this.children.length; len > i; i++) this.children[i].preUpdate();
                    }, Phaser.Stage.prototype.update = function() {
                        for (var i = this.children.length; i--; ) this.children[i].update();
                    }, Phaser.Stage.prototype.postUpdate = function() {
                        if (this.game.world.camera.target) {
                            this.game.world.camera.target.postUpdate(), this.game.world.camera.update();
                            for (var i = this.children.length; i--; ) this.children[i] !== this.game.world.camera.target && this.children[i].postUpdate();
                        } else {
                            this.game.world.camera.update();
                            for (var i = this.children.length; i--; ) this.children[i].postUpdate();
                        }
                    }, Phaser.Stage.prototype.updateTransform = function() {
                        this.worldAlpha = 1;
                        for (var i = 0, j = this.children.length; j > i; i++) this.children[i].updateTransform();
                    }, Phaser.Stage.prototype.checkVisibility = function() {
                        this._hiddenVar = void 0 !== document.webkitHidden ? "webkitvisibilitychange" : void 0 !== document.mozHidden ? "mozvisibilitychange" : void 0 !== document.msHidden ? "msvisibilitychange" : void 0 !== document.hidden ? "visibilitychange" : null, 
                        this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), 
                        window.onpagehide = this._onChange, window.onpageshow = this._onChange, window.onblur = this._onChange, 
                        window.onfocus = this._onChange;
                        var _this = this;
                        this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
                            Phaser.Stage.prototype.visibilityChange.call(_this, {
                                type: "pause"
                            });
                        }), CocoonJS.App.onActivated.addEventListener(function() {
                            Phaser.Stage.prototype.visibilityChange.call(_this, {
                                type: "resume"
                            });
                        }));
                    }, Phaser.Stage.prototype.visibilityChange = function(event) {
                        return "pagehide" === event.type || "blur" === event.type || "pageshow" === event.type || "focus" === event.type ? void ("pagehide" === event.type || "blur" === event.type ? this.game.focusLoss(event) : ("pageshow" === event.type || "focus" === event.type) && this.game.focusGain(event)) : void (this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === event.type ? this.game.gamePaused(event) : this.game.gameResumed(event)));
                    }, Phaser.Stage.prototype.setBackgroundColor = function(backgroundColor) {
                        var rgb = Phaser.Color.valueToColor(backgroundColor);
                        this._backgroundColor = Phaser.Color.getColor(rgb.r, rgb.g, rgb.b), this.backgroundColorSplit = [ rgb.r / 255, rgb.g / 255, rgb.b / 255 ], 
                        this.backgroundColorString = Phaser.Color.RGBtoString(rgb.r, rgb.g, rgb.b, 255, "#");
                    }, Phaser.Stage.prototype.destroy = function() {
                        this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), 
                        window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null;
                    }, Object.defineProperty(Phaser.Stage.prototype, "backgroundColor", {
                        get: function() {
                            return this._backgroundColor;
                        },
                        set: function(color) {
                            this.game.transparent || this.setBackgroundColor(color);
                        }
                    }), Object.defineProperty(Phaser.Stage.prototype, "smoothed", {
                        get: function() {
                            return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR;
                        },
                        set: function(value) {
                            PIXI.scaleModes.DEFAULT = value ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST;
                        }
                    }), Phaser.Group = function(game, parent, name, addToStage, enableBody, physicsBodyType) {
                        "undefined" == typeof addToStage && (addToStage = !1), "undefined" == typeof enableBody && (enableBody = !1), 
                        "undefined" == typeof physicsBodyType && (physicsBodyType = Phaser.Physics.ARCADE), 
                        this.game = game, "undefined" == typeof parent && (parent = game.world), this.name = name || "group", 
                        this.z = 0, PIXI.DisplayObjectContainer.call(this), addToStage ? (this.game.stage.addChild(this), 
                        this.z = this.game.stage.children.length) : parent && (parent.addChild(this), this.z = parent.children.length), 
                        this.type = Phaser.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, 
                        this.classType = Phaser.Sprite, this.scale = new Phaser.Point(1, 1), this.cursor = null, 
                        this.cameraOffset = new Phaser.Point(), this.enableBody = enableBody, this.enableBodyDebug = !1, 
                        this.physicsBodyType = physicsBodyType, this.onDestroy = new Phaser.Signal(), this._sortProperty = "z", 
                        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0 ];
                    }, Phaser.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), 
                    Phaser.Group.prototype.constructor = Phaser.Group, Phaser.Group.RETURN_NONE = 0, 
                    Phaser.Group.RETURN_TOTAL = 1, Phaser.Group.RETURN_CHILD = 2, Phaser.Group.SORT_ASCENDING = -1, 
                    Phaser.Group.SORT_DESCENDING = 1, Phaser.Group.prototype.add = function(child, silent) {
                        return "undefined" == typeof silent && (silent = !1), child.parent !== this && (this.enableBody && this.game.physics.enable(child, this.physicsBodyType), 
                        this.addChild(child), child.z = this.children.length, !silent && child.events && child.events.onAddedToGroup$dispatch(child, this), 
                        null === this.cursor && (this.cursor = child)), child;
                    }, Phaser.Group.prototype.addMultiple = function(children, silent) {
                        if (Array.isArray(children)) for (var i = 0; i < children.length; i++) this.add(children[i], silent);
                        return children;
                    }, Phaser.Group.prototype.addAt = function(child, index, silent) {
                        return "undefined" == typeof silent && (silent = !1), child.parent !== this && (this.enableBody && this.game.physics.enable(child, this.physicsBodyType), 
                        this.addChildAt(child, index), this.updateZ(), !silent && child.events && child.events.onAddedToGroup$dispatch(child, this), 
                        null === this.cursor && (this.cursor = child)), child;
                    }, Phaser.Group.prototype.getAt = function(index) {
                        return 0 > index || index >= this.children.length ? -1 : this.getChildAt(index);
                    }, Phaser.Group.prototype.create = function(x, y, key, frame, exists) {
                        "undefined" == typeof exists && (exists = !0);
                        var child = new this.classType(this.game, x, y, key, frame);
                        return this.enableBody && this.game.physics.enable(child, this.physicsBodyType, this.enableBodyDebug), 
                        child.exists = exists, child.visible = exists, child.alive = exists, this.addChild(child), 
                        child.z = this.children.length, child.events && child.events.onAddedToGroup$dispatch(child, this), 
                        null === this.cursor && (this.cursor = child), child;
                    }, Phaser.Group.prototype.createMultiple = function(quantity, key, frame, exists) {
                        "undefined" == typeof exists && (exists = !1);
                        for (var i = 0; quantity > i; i++) this.create(0, 0, key, frame, exists);
                    }, Phaser.Group.prototype.updateZ = function() {
                        for (var i = this.children.length; i--; ) this.children[i].z = i;
                    }, Phaser.Group.prototype.resetCursor = function(index) {
                        return "undefined" == typeof index && (index = 0), index > this.children.length - 1 && (index = 0), 
                        this.cursor ? (this._cache[8] = index, this.cursor = this.children[this._cache[8]], 
                        this.cursor) : void 0;
                    }, Phaser.Group.prototype.next = function() {
                        return this.cursor ? (this._cache[8] >= this.children.length - 1 ? this._cache[8] = 0 : this._cache[8]++, 
                        this.cursor = this.children[this._cache[8]], this.cursor) : void 0;
                    }, Phaser.Group.prototype.previous = function() {
                        return this.cursor ? (0 === this._cache[8] ? this._cache[8] = this.children.length - 1 : this._cache[8]--, 
                        this.cursor = this.children[this._cache[8]], this.cursor) : void 0;
                    }, Phaser.Group.prototype.swap = function(child1, child2) {
                        this.swapChildren(child1, child2), this.updateZ();
                    }, Phaser.Group.prototype.bringToTop = function(child) {
                        return child.parent === this && this.getIndex(child) < this.children.length && (this.remove(child, !1, !0), 
                        this.add(child, !0)), child;
                    }, Phaser.Group.prototype.sendToBack = function(child) {
                        return child.parent === this && this.getIndex(child) > 0 && (this.remove(child, !1, !0), 
                        this.addAt(child, 0, !0)), child;
                    }, Phaser.Group.prototype.moveUp = function(child) {
                        if (child.parent === this && this.getIndex(child) < this.children.length - 1) {
                            var a = this.getIndex(child), b = this.getAt(a + 1);
                            b && this.swap(child, b);
                        }
                        return child;
                    }, Phaser.Group.prototype.moveDown = function(child) {
                        if (child.parent === this && this.getIndex(child) > 0) {
                            var a = this.getIndex(child), b = this.getAt(a - 1);
                            b && this.swap(child, b);
                        }
                        return child;
                    }, Phaser.Group.prototype.xy = function(index, x, y) {
                        return 0 > index || index > this.children.length ? -1 : (this.getChildAt(index).x = x, 
                        void (this.getChildAt(index).y = y));
                    }, Phaser.Group.prototype.reverse = function() {
                        this.children.reverse(), this.updateZ();
                    }, Phaser.Group.prototype.getIndex = function(child) {
                        return this.children.indexOf(child);
                    }, Phaser.Group.prototype.replace = function(oldChild, newChild) {
                        var index = this.getIndex(oldChild);
                        return -1 !== index ? (newChild.parent && (newChild.parent instanceof Phaser.Group ? newChild.parent.remove(newChild) : newChild.parent.removeChild(newChild)), 
                        this.remove(oldChild), this.addAt(newChild, index), oldChild) : void 0;
                    }, Phaser.Group.prototype.hasProperty = function(child, key) {
                        var len = key.length;
                        return 1 === len && key[0] in child ? !0 : 2 === len && key[0] in child && key[1] in child[key[0]] ? !0 : 3 === len && key[0] in child && key[1] in child[key[0]] && key[2] in child[key[0]][key[1]] ? !0 : 4 === len && key[0] in child && key[1] in child[key[0]] && key[2] in child[key[0]][key[1]] && key[3] in child[key[0]][key[1]][key[2]] ? !0 : !1;
                    }, Phaser.Group.prototype.setProperty = function(child, key, value, operation, force) {
                        if ("undefined" == typeof force && (force = !1), operation = operation || 0, !this.hasProperty(child, key) && (!force || operation > 0)) return !1;
                        var len = key.length;
                        return 1 === len ? 0 === operation ? child[key[0]] = value : 1 == operation ? child[key[0]] += value : 2 == operation ? child[key[0]] -= value : 3 == operation ? child[key[0]] *= value : 4 == operation && (child[key[0]] /= value) : 2 === len ? 0 === operation ? child[key[0]][key[1]] = value : 1 == operation ? child[key[0]][key[1]] += value : 2 == operation ? child[key[0]][key[1]] -= value : 3 == operation ? child[key[0]][key[1]] *= value : 4 == operation && (child[key[0]][key[1]] /= value) : 3 === len ? 0 === operation ? child[key[0]][key[1]][key[2]] = value : 1 == operation ? child[key[0]][key[1]][key[2]] += value : 2 == operation ? child[key[0]][key[1]][key[2]] -= value : 3 == operation ? child[key[0]][key[1]][key[2]] *= value : 4 == operation && (child[key[0]][key[1]][key[2]] /= value) : 4 === len && (0 === operation ? child[key[0]][key[1]][key[2]][key[3]] = value : 1 == operation ? child[key[0]][key[1]][key[2]][key[3]] += value : 2 == operation ? child[key[0]][key[1]][key[2]][key[3]] -= value : 3 == operation ? child[key[0]][key[1]][key[2]][key[3]] *= value : 4 == operation && (child[key[0]][key[1]][key[2]][key[3]] /= value)), 
                        !0;
                    }, Phaser.Group.prototype.checkProperty = function(child, key, value, force) {
                        return "undefined" == typeof force && (force = !1), !Phaser.Utils.getProperty(child, key) && force ? !1 : Phaser.Utils.getProperty(child, key) !== value ? !1 : !0;
                    }, Phaser.Group.prototype.set = function(child, key, value, checkAlive, checkVisible, operation, force) {
                        return "undefined" == typeof force && (force = !1), key = key.split("."), "undefined" == typeof checkAlive && (checkAlive = !1), 
                        "undefined" == typeof checkVisible && (checkVisible = !1), (checkAlive === !1 || checkAlive && child.alive) && (checkVisible === !1 || checkVisible && child.visible) ? this.setProperty(child, key, value, operation, force) : void 0;
                    }, Phaser.Group.prototype.setAll = function(key, value, checkAlive, checkVisible, operation, force) {
                        "undefined" == typeof checkAlive && (checkAlive = !1), "undefined" == typeof checkVisible && (checkVisible = !1), 
                        "undefined" == typeof force && (force = !1), key = key.split("."), operation = operation || 0;
                        for (var i = 0, len = this.children.length; len > i; i++) (!checkAlive || checkAlive && this.children[i].alive) && (!checkVisible || checkVisible && this.children[i].visible) && this.setProperty(this.children[i], key, value, operation, force);
                    }, Phaser.Group.prototype.setAllChildren = function(key, value, checkAlive, checkVisible, operation, force) {
                        "undefined" == typeof checkAlive && (checkAlive = !1), "undefined" == typeof checkVisible && (checkVisible = !1), 
                        "undefined" == typeof force && (force = !1), operation = operation || 0;
                        for (var i = 0, len = this.children.length; len > i; i++) (!checkAlive || checkAlive && this.children[i].alive) && (!checkVisible || checkVisible && this.children[i].visible) && (this.children[i] instanceof Phaser.Group ? this.children[i].setAllChildren(key, value, checkAlive, checkVisible, operation, force) : this.setProperty(this.children[i], key.split("."), value, operation, force));
                    }, Phaser.Group.prototype.checkAll = function(key, value, checkAlive, checkVisible, force) {
                        "undefined" == typeof checkAlive && (checkAlive = !1), "undefined" == typeof checkVisible && (checkVisible = !1), 
                        "undefined" == typeof force && (force = !1);
                        for (var i = 0, len = this.children.length; len > i; i++) if ((!checkAlive || checkAlive && this.children[i].alive) && (!checkVisible || checkVisible && this.children[i].visible) && !this.checkProperty(this.children[i], key, value, force)) return !1;
                        return !0;
                    }, Phaser.Group.prototype.addAll = function(property, amount, checkAlive, checkVisible) {
                        this.setAll(property, amount, checkAlive, checkVisible, 1);
                    }, Phaser.Group.prototype.subAll = function(property, amount, checkAlive, checkVisible) {
                        this.setAll(property, amount, checkAlive, checkVisible, 2);
                    }, Phaser.Group.prototype.multiplyAll = function(property, amount, checkAlive, checkVisible) {
                        this.setAll(property, amount, checkAlive, checkVisible, 3);
                    }, Phaser.Group.prototype.divideAll = function(property, amount, checkAlive, checkVisible) {
                        this.setAll(property, amount, checkAlive, checkVisible, 4);
                    }, Phaser.Group.prototype.callAllExists = function(callback, existsValue) {
                        var args;
                        if (arguments.length > 2) {
                            args = [];
                            for (var i = 2; i < arguments.length; i++) args.push(arguments[i]);
                        }
                        for (var i = 0, len = this.children.length; len > i; i++) this.children[i].exists === existsValue && this.children[i][callback] && this.children[i][callback].apply(this.children[i], args);
                    }, Phaser.Group.prototype.callbackFromArray = function(child, callback, length) {
                        if (1 == length) {
                            if (child[callback[0]]) return child[callback[0]];
                        } else if (2 == length) {
                            if (child[callback[0]][callback[1]]) return child[callback[0]][callback[1]];
                        } else if (3 == length) {
                            if (child[callback[0]][callback[1]][callback[2]]) return child[callback[0]][callback[1]][callback[2]];
                        } else if (4 == length) {
                            if (child[callback[0]][callback[1]][callback[2]][callback[3]]) return child[callback[0]][callback[1]][callback[2]][callback[3]];
                        } else if (child[callback]) return child[callback];
                        return !1;
                    }, Phaser.Group.prototype.callAll = function(method, context) {
                        if ("undefined" != typeof method) {
                            method = method.split(".");
                            var methodLength = method.length;
                            if ("undefined" == typeof context || null === context || "" === context) context = null; else if ("string" == typeof context) {
                                context = context.split(".");
                                var contextLength = context.length;
                            }
                            var args;
                            if (arguments.length > 2) {
                                args = [];
                                for (var i = 2; i < arguments.length; i++) args.push(arguments[i]);
                            }
                            for (var callback = null, callbackContext = null, i = 0, len = this.children.length; len > i; i++) callback = this.callbackFromArray(this.children[i], method, methodLength), 
                            context && callback ? (callbackContext = this.callbackFromArray(this.children[i], context, contextLength), 
                            callback && callback.apply(callbackContext, args)) : callback && callback.apply(this.children[i], args);
                        }
                    }, Phaser.Group.prototype.preUpdate = function() {
                        if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                        for (var i = this.children.length; i--; ) this.children[i].preUpdate();
                        return !0;
                    }, Phaser.Group.prototype.update = function() {
                        for (var i = this.children.length; i--; ) this.children[i].update();
                    }, Phaser.Group.prototype.postUpdate = function() {
                        1 === this._cache[7] && (this.x = this.game.camera.view.x + this.cameraOffset.x, 
                        this.y = this.game.camera.view.y + this.cameraOffset.y);
                        for (var i = this.children.length; i--; ) this.children[i].postUpdate();
                    }, Phaser.Group.prototype.filter = function(predicate, checkExists) {
                        for (var index = -1, length = this.children.length, results = []; ++index < length; ) {
                            var child = this.children[index];
                            (!checkExists || checkExists && child.exists) && predicate(child, index, this.children) && results.push(child);
                        }
                        return new Phaser.ArraySet(results);
                    }, Phaser.Group.prototype.forEach = function(callback, callbackContext, checkExists) {
                        if ("undefined" == typeof checkExists && (checkExists = !1), arguments.length <= 3) for (var i = 0, len = this.children.length; len > i; i++) (!checkExists || checkExists && this.children[i].exists) && callback.call(callbackContext, this.children[i]); else {
                            for (var args = [ null ], i = 3; i < arguments.length; i++) args.push(arguments[i]);
                            for (var i = 0, len = this.children.length; len > i; i++) (!checkExists || checkExists && this.children[i].exists) && (args[0] = this.children[i], 
                            callback.apply(callbackContext, args));
                        }
                    }, Phaser.Group.prototype.forEachExists = function(callback, callbackContext) {
                        var args;
                        if (arguments.length > 2) {
                            args = [ null ];
                            for (var i = 2; i < arguments.length; i++) args.push(arguments[i]);
                        }
                        this.iterate("exists", !0, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);
                    }, Phaser.Group.prototype.forEachAlive = function(callback, callbackContext) {
                        var args;
                        if (arguments.length > 2) {
                            args = [ null ];
                            for (var i = 2; i < arguments.length; i++) args.push(arguments[i]);
                        }
                        this.iterate("alive", !0, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);
                    }, Phaser.Group.prototype.forEachDead = function(callback, callbackContext) {
                        var args;
                        if (arguments.length > 2) {
                            args = [ null ];
                            for (var i = 2; i < arguments.length; i++) args.push(arguments[i]);
                        }
                        this.iterate("alive", !1, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);
                    }, Phaser.Group.prototype.sort = function(key, order) {
                        this.children.length < 2 || ("undefined" == typeof key && (key = "z"), "undefined" == typeof order && (order = Phaser.Group.SORT_ASCENDING), 
                        this._sortProperty = key, this.children.sort(order === Phaser.Group.SORT_ASCENDING ? this.ascendingSortHandler.bind(this) : this.descendingSortHandler.bind(this)), 
                        this.updateZ());
                    }, Phaser.Group.prototype.customSort = function(sortHandler, context) {
                        this.children.length < 2 || (this.children.sort(sortHandler.bind(context)), this.updateZ());
                    }, Phaser.Group.prototype.ascendingSortHandler = function(a, b) {
                        return a[this._sortProperty] < b[this._sortProperty] ? -1 : a[this._sortProperty] > b[this._sortProperty] ? 1 : a.z < b.z ? -1 : 1;
                    }, Phaser.Group.prototype.descendingSortHandler = function(a, b) {
                        return a[this._sortProperty] < b[this._sortProperty] ? 1 : a[this._sortProperty] > b[this._sortProperty] ? -1 : 0;
                    }, Phaser.Group.prototype.iterate = function(key, value, returnType, callback, callbackContext, args) {
                        if (returnType === Phaser.Group.RETURN_TOTAL && 0 === this.children.length) return 0;
                        for (var total = 0, i = 0, len = this.children.length; len > i; i++) if (this.children[i][key] === value && (total++, 
                        callback && (args ? (args[0] = this.children[i], callback.apply(callbackContext, args)) : callback.call(callbackContext, this.children[i])), 
                        returnType === Phaser.Group.RETURN_CHILD)) return this.children[i];
                        return returnType === Phaser.Group.RETURN_TOTAL ? total : null;
                    }, Phaser.Group.prototype.getFirstExists = function(exists) {
                        return "boolean" != typeof exists && (exists = !0), this.iterate("exists", exists, Phaser.Group.RETURN_CHILD);
                    }, Phaser.Group.prototype.getFirstAlive = function() {
                        return this.iterate("alive", !0, Phaser.Group.RETURN_CHILD);
                    }, Phaser.Group.prototype.getFirstDead = function() {
                        return this.iterate("alive", !1, Phaser.Group.RETURN_CHILD);
                    }, Phaser.Group.prototype.getTop = function() {
                        return this.children.length > 0 ? this.children[this.children.length - 1] : void 0;
                    }, Phaser.Group.prototype.getBottom = function() {
                        return this.children.length > 0 ? this.children[0] : void 0;
                    }, Phaser.Group.prototype.countLiving = function() {
                        return this.iterate("alive", !0, Phaser.Group.RETURN_TOTAL);
                    }, Phaser.Group.prototype.countDead = function() {
                        return this.iterate("alive", !1, Phaser.Group.RETURN_TOTAL);
                    }, Phaser.Group.prototype.getRandom = function(startIndex, length) {
                        return 0 === this.children.length ? null : (startIndex = startIndex || 0, length = length || this.children.length, 
                        Phaser.ArrayUtils.getRandomItem(this.children, startIndex, length));
                    }, Phaser.Group.prototype.remove = function(child, destroy, silent) {
                        if ("undefined" == typeof destroy && (destroy = !1), "undefined" == typeof silent && (silent = !1), 
                        0 === this.children.length || -1 === this.children.indexOf(child)) return !1;
                        silent || !child.events || child.destroyPhase || child.events.onRemovedFromGroup$dispatch(child, this);
                        var removed = this.removeChild(child);
                        return this.updateZ(), this.cursor === child && this.next(), destroy && removed && removed.destroy(!0), 
                        !0;
                    }, Phaser.Group.prototype.removeAll = function(destroy, silent) {
                        if ("undefined" == typeof destroy && (destroy = !1), "undefined" == typeof silent && (silent = !1), 
                        0 !== this.children.length) {
                            do {
                                !silent && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                                var removed = this.removeChild(this.children[0]);
                                destroy && removed && removed.destroy(!0);
                            } while (this.children.length > 0);
                            this.cursor = null;
                        }
                    }, Phaser.Group.prototype.removeBetween = function(startIndex, endIndex, destroy, silent) {
                        if ("undefined" == typeof endIndex && (endIndex = this.children.length - 1), "undefined" == typeof destroy && (destroy = !1), 
                        "undefined" == typeof silent && (silent = !1), 0 !== this.children.length) {
                            if (startIndex > endIndex || 0 > startIndex || endIndex > this.children.length) return !1;
                            for (var i = endIndex; i >= startIndex; ) {
                                !silent && this.children[i].events && this.children[i].events.onRemovedFromGroup$dispatch(this.children[i], this);
                                var removed = this.removeChild(this.children[i]);
                                destroy && removed && removed.destroy(!0), this.cursor === this.children[i] && (this.cursor = null), 
                                i--;
                            }
                            this.updateZ();
                        }
                    }, Phaser.Group.prototype.destroy = function(destroyChildren, soft) {
                        null === this.game || this.ignoreDestroy || ("undefined" == typeof destroyChildren && (destroyChildren = !0), 
                        "undefined" == typeof soft && (soft = !1), this.onDestroy.dispatch(this, destroyChildren, soft), 
                        this.removeAll(destroyChildren), this.cursor = null, this.filters = null, soft || (this.parent && this.parent.removeChild(this), 
                        this.game = null, this.exists = !1));
                    }, Object.defineProperty(Phaser.Group.prototype, "total", {
                        get: function() {
                            return this.iterate("exists", !0, Phaser.Group.RETURN_TOTAL);
                        }
                    }), Object.defineProperty(Phaser.Group.prototype, "length", {
                        get: function() {
                            return this.children.length;
                        }
                    }), Object.defineProperty(Phaser.Group.prototype, "angle", {
                        get: function() {
                            return Phaser.Math.radToDeg(this.rotation);
                        },
                        set: function(value) {
                            this.rotation = Phaser.Math.degToRad(value);
                        }
                    }), Object.defineProperty(Phaser.Group.prototype, "fixedToCamera", {
                        get: function() {
                            return !!this._cache[7];
                        },
                        set: function(value) {
                            value ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0;
                        }
                    }), Phaser.World = function(game) {
                        Phaser.Group.call(this, game, null, "__world", !1), this.bounds = new Phaser.Rectangle(0, 0, game.width, game.height), 
                        this.camera = null, this._definedSize = !1, this._width = game.width, this._height = game.height;
                    }, Phaser.World.prototype = Object.create(Phaser.Group.prototype), Phaser.World.prototype.constructor = Phaser.World, 
                    Phaser.World.prototype.boot = function() {
                        this.camera = new Phaser.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), 
                        this.camera.displayObject = this, this.camera.scale = this.scale, this.game.camera = this.camera, 
                        this.game.stage.addChild(this);
                    }, Phaser.World.prototype.setBounds = function(x, y, width, height) {
                        this._definedSize = !0, this._width = width, this._height = height, this.bounds.setTo(x, y, width, height), 
                        this.camera.bounds && this.camera.bounds.setTo(x, y, Math.max(width, this.game.width), Math.max(height, this.game.height)), 
                        this.game.physics.setBoundsToWorld();
                    }, Phaser.World.prototype.resize = function(width, height) {
                        this._definedSize && (width < this._width && (width = this._width), height < this._height && (height = this._height)), 
                        this.bounds.width = width, this.bounds.height = height, this.game.camera.setBoundsToWorld(), 
                        this.game.physics.setBoundsToWorld();
                    }, Phaser.World.prototype.shutdown = function() {
                        this.destroy(!0, !0);
                    }, Phaser.World.prototype.wrap = function(sprite, padding, useBounds, horizontal, vertical) {
                        "undefined" == typeof padding && (padding = 0), "undefined" == typeof useBounds && (useBounds = !1), 
                        "undefined" == typeof horizontal && (horizontal = !0), "undefined" == typeof vertical && (vertical = !0), 
                        useBounds ? (sprite.getBounds(), horizontal && (sprite.x + sprite._currentBounds.width < this.bounds.x ? sprite.x = this.bounds.right : sprite.x > this.bounds.right && (sprite.x = this.bounds.left)), 
                        vertical && (sprite.y + sprite._currentBounds.height < this.bounds.top ? sprite.y = this.bounds.bottom : sprite.y > this.bounds.bottom && (sprite.y = this.bounds.top))) : (horizontal && sprite.x + padding < this.bounds.x ? sprite.x = this.bounds.right + padding : horizontal && sprite.x - padding > this.bounds.right && (sprite.x = this.bounds.left - padding), 
                        vertical && sprite.y + padding < this.bounds.top ? sprite.y = this.bounds.bottom + padding : vertical && sprite.y - padding > this.bounds.bottom && (sprite.y = this.bounds.top - padding));
                    }, Object.defineProperty(Phaser.World.prototype, "width", {
                        get: function() {
                            return this.bounds.width;
                        },
                        set: function(value) {
                            value < this.game.width && (value = this.game.width), this.bounds.width = value, 
                            this._width = value, this._definedSize = !0;
                        }
                    }), Object.defineProperty(Phaser.World.prototype, "height", {
                        get: function() {
                            return this.bounds.height;
                        },
                        set: function(value) {
                            value < this.game.height && (value = this.game.height), this.bounds.height = value, 
                            this._height = value, this._definedSize = !0;
                        }
                    }), Object.defineProperty(Phaser.World.prototype, "centerX", {
                        get: function() {
                            return this.bounds.halfWidth;
                        }
                    }), Object.defineProperty(Phaser.World.prototype, "centerY", {
                        get: function() {
                            return this.bounds.halfHeight;
                        }
                    }), Object.defineProperty(Phaser.World.prototype, "randomX", {
                        get: function() {
                            return this.bounds.x < 0 ? this.game.rnd.integerInRange(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.integerInRange(this.bounds.x, this.bounds.width);
                        }
                    }), Object.defineProperty(Phaser.World.prototype, "randomY", {
                        get: function() {
                            return this.bounds.y < 0 ? this.game.rnd.integerInRange(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.integerInRange(this.bounds.y, this.bounds.height);
                        }
                    }), Phaser.FlexGrid = function(manager, width, height) {
                        this.game = manager.game, this.manager = manager, this.width = width, this.height = height, 
                        this.boundsCustom = new Phaser.Rectangle(0, 0, width, height), this.boundsFluid = new Phaser.Rectangle(0, 0, width, height), 
                        this.boundsFull = new Phaser.Rectangle(0, 0, width, height), this.boundsNone = new Phaser.Rectangle(0, 0, width, height), 
                        this.positionCustom = new Phaser.Point(0, 0), this.positionFluid = new Phaser.Point(0, 0), 
                        this.positionFull = new Phaser.Point(0, 0), this.positionNone = new Phaser.Point(0, 0), 
                        this.scaleCustom = new Phaser.Point(1, 1), this.scaleFluid = new Phaser.Point(1, 1), 
                        this.scaleFluidInversed = new Phaser.Point(1, 1), this.scaleFull = new Phaser.Point(1, 1), 
                        this.scaleNone = new Phaser.Point(1, 1), this.customWidth = 0, this.customHeight = 0, 
                        this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = width / height, this.ratioV = height / width, 
                        this.multiplier = 0, this.layers = [];
                    }, Phaser.FlexGrid.prototype = {
                        setSize: function(width, height) {
                            this.width = width, this.height = height, this.ratioH = width / height, this.ratioV = height / width, 
                            this.scaleNone = new Phaser.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, 
                            this.refresh();
                        },
                        createCustomLayer: function(width, height, children, addToWorld) {
                            "undefined" == typeof addToWorld && (addToWorld = !0), this.customWidth = width, 
                            this.customHeight = height, this.boundsCustom.width = width, this.boundsCustom.height = height;
                            var layer = new Phaser.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
                            return addToWorld && this.game.world.add(layer), this.layers.push(layer), "undefined" != typeof children && null !== typeof children && layer.addMultiple(children), 
                            layer;
                        },
                        createFluidLayer: function(children, addToWorld) {
                            "undefined" == typeof addToWorld && (addToWorld = !0);
                            var layer = new Phaser.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
                            return addToWorld && this.game.world.add(layer), this.layers.push(layer), "undefined" != typeof children && null !== typeof children && layer.addMultiple(children), 
                            layer;
                        },
                        createFullLayer: function(children) {
                            var layer = new Phaser.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
                            return this.game.world.add(layer), this.layers.push(layer), "undefined" != typeof children && layer.addMultiple(children), 
                            layer;
                        },
                        createFixedLayer: function(children) {
                            var layer = new Phaser.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
                            return this.game.world.add(layer), this.layers.push(layer), "undefined" != typeof children && layer.addMultiple(children), 
                            layer;
                        },
                        reset: function() {
                            for (var i = this.layers.length; i--; ) this.layers[i].persist || (this.layers[i].position = null, 
                            this.layers[i].scale = null, this.layers.slice(i, 1));
                        },
                        onResize: function(width, height) {
                            this.ratioH = width / height, this.ratioV = height / width, this.refresh(width, height);
                        },
                        refresh: function() {
                            this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), 
                            this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), 
                            this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), 
                            this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), 
                            this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), 
                            this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), 
                            this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), 
                            this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), 
                            this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), 
                            this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y);
                        },
                        fitSprite: function(sprite) {
                            this.manager.scaleSprite(sprite), sprite.x = this.manager.bounds.centerX, sprite.y = this.manager.bounds.centerY;
                        },
                        debug: function() {
                            this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), 
                            this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1);
                        }
                    }, Phaser.FlexGrid.prototype.constructor = Phaser.FlexGrid, Phaser.FlexLayer = function(manager, position, bounds, scale) {
                        Phaser.Group.call(this, manager.game, null, "__flexLayer" + manager.game.rnd.uuid(), !1), 
                        this.manager = manager.manager, this.grid = manager, this.persist = !1, this.position = position, 
                        this.bounds = bounds, this.scale = scale, this.topLeft = bounds.topLeft, this.topMiddle = new Phaser.Point(bounds.halfWidth, 0), 
                        this.topRight = bounds.topRight, this.bottomLeft = bounds.bottomLeft, this.bottomMiddle = new Phaser.Point(bounds.halfWidth, bounds.bottom), 
                        this.bottomRight = bounds.bottomRight;
                    }, Phaser.FlexLayer.prototype = Object.create(Phaser.Group.prototype), Phaser.FlexLayer.prototype.constructor = Phaser.FlexLayer, 
                    Phaser.FlexLayer.prototype.resize = function() {}, Phaser.FlexLayer.prototype.debug = function() {
                        this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), 
                        this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), 
                        this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9");
                    }, Phaser.ScaleManager = function(game, width, height) {
                        this.game = game, this.dom = Phaser.DOM, this.grid = null, this.width = 0, this.height = 0, 
                        this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, 
                        this.offset = new Phaser.Point(), this.forceLandscape = !1, this.forcePortrait = !1, 
                        this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, 
                        this.maxIterations = 5, this.onOrientationChange = new Phaser.Signal(), this.enterLandscape = new Phaser.Signal(), 
                        this.enterPortrait = new Phaser.Signal(), this.enterIncorrectOrientation = new Phaser.Signal(), 
                        this.leaveIncorrectOrientation = new Phaser.Signal(), this.fullScreenTarget = null, 
                        this._createdFullScreenTarget = null, this.onFullScreenInit = new Phaser.Signal(), 
                        this.onFullScreenChange = new Phaser.Signal(), this.onFullScreenError = new Phaser.Signal(), 
                        this.enterFullScreen = new Phaser.Signal(), this.leaveFullScreen = new Phaser.Signal(), 
                        this.fullScreenFailed = this.onFullScreenError, this.screenOrientation = this.dom.getScreenOrientation(), 
                        this.scaleFactor = new Phaser.Point(1, 1), this.scaleFactorInversed = new Phaser.Point(1, 1), 
                        this.margin = {
                            left: 0,
                            top: 0,
                            right: 0,
                            bottom: 0,
                            x: 0,
                            y: 0
                        }, this.bounds = new Phaser.Rectangle(), this.aspectRatio = 0, this.sourceAspectRatio = 0, 
                        this.event = null, this.windowConstraints = {
                            right: "layout",
                            bottom: ""
                        }, this.compatibility = {
                            supportsFullScreen: !1,
                            orientationFallback: null,
                            noMargins: !1,
                            scrollTo: null,
                            forceMinimumDocumentHeight: !1,
                            canExpandParent: !0,
                            clickTrampoline: ""
                        }, this._scaleMode = Phaser.ScaleManager.NO_SCALE, this._fullScreenScaleMode = Phaser.ScaleManager.NO_SCALE, 
                        this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new Phaser.Point(1, 1), 
                        this.trackParentInterval = 2e3, this.onSizeChange = new Phaser.Signal(), this.onResize = null, 
                        this.onResizeContext = null, this._fullScreenRestore = null, this._gameSize = new Phaser.Rectangle(), 
                        this._userScaleFactor = new Phaser.Point(1, 1), this._userScaleTrim = new Phaser.Point(0, 0), 
                        this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, 
                        this._parentBounds = new Phaser.Rectangle(), this._tempBounds = new Phaser.Rectangle(), 
                        this._lastReportedCanvasSize = new Phaser.Rectangle(), this._lastReportedGameSize = new Phaser.Rectangle(), 
                        game.config && this.parseConfig(game.config), this.setupScale(width, height);
                    }, Phaser.ScaleManager.EXACT_FIT = 0, Phaser.ScaleManager.NO_SCALE = 1, Phaser.ScaleManager.SHOW_ALL = 2, 
                    Phaser.ScaleManager.RESIZE = 3, Phaser.ScaleManager.USER_SCALE = 4, Phaser.ScaleManager.prototype = {
                        boot: function() {
                            var compat = this.compatibility;
                            compat.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, 
                            this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (compat.scrollTo = this.game.device.android && !this.game.device.chrome ? new Phaser.Point(0, 1) : new Phaser.Point(0, 0)), 
                            this.game.device.desktop ? (compat.orientationFallback = "screen", compat.clickTrampoline = "when-not-mouse") : (compat.orientationFallback = "", 
                            compat.clickTrampoline = "");
                            var _this = this;
                            this._orientationChange = function(event) {
                                return _this.orientationChange(event);
                            }, this._windowResize = function(event) {
                                return _this.windowResize(event);
                            }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), 
                            this.compatibility.supportsFullScreen && (this._fullScreenChange = function(event) {
                                return _this.fullScreenChange(event);
                            }, this._fullScreenError = function(event) {
                                return _this.fullScreenError(event);
                            }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), 
                            document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), 
                            document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), 
                            document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), 
                            document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), 
                            this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), 
                            this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback);
                        },
                        parseConfig: function(config) {
                            config.scaleMode && (this.scaleMode = config.scaleMode), config.fullScreenScaleMode && (this.fullScreenScaleMode = config.fullScreenScaleMode), 
                            config.fullScreenTarget && (this.fullScreenTarget = config.fullScreenTarget);
                        },
                        setupScale: function(width, height) {
                            var target, rect = new Phaser.Rectangle();
                            "" !== this.game.parent && ("string" == typeof this.game.parent ? target = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (target = this.game.parent)), 
                            target ? (this.parentNode = target, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), 
                            rect.width = this._parentBounds.width, rect.height = this._parentBounds.height, 
                            this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, 
                            this.parentIsWindow = !0, rect.width = this.dom.visualBounds.width, rect.height = this.dom.visualBounds.height, 
                            this.offset.set(0, 0));
                            var newWidth = 0, newHeight = 0;
                            "number" == typeof width ? newWidth = width : (this.parentScaleFactor.x = parseInt(width, 10) / 100, 
                            newWidth = rect.width * this.parentScaleFactor.x), "number" == typeof height ? newHeight = height : (this.parentScaleFactor.y = parseInt(height, 10) / 100, 
                            newHeight = rect.height * this.parentScaleFactor.y), this._gameSize.setTo(0, 0, newWidth, newHeight), 
                            this.grid = new Phaser.FlexGrid(this, newWidth, newHeight), this.updateDimensions(newWidth, newHeight, !1);
                        },
                        _gameResumed: function() {
                            this.queueUpdate(!0);
                        },
                        setGameSize: function(width, height) {
                            this._gameSize.setTo(0, 0, width, height), this.currentScaleMode !== Phaser.ScaleManager.RESIZE && this.updateDimensions(width, height, !0), 
                            this.queueUpdate(!0);
                        },
                        setUserScale: function(hScale, vScale, hTrim, vTrim) {
                            this._userScaleFactor.setTo(hScale, vScale), this._userScaleTrim.setTo(0 | hTrim, 0 | vTrim), 
                            this.queueUpdate(!0);
                        },
                        setResizeCallback: function(callback, context) {
                            this.onResize = callback, this.onResizeContext = context;
                        },
                        signalSizeChange: function() {
                            if (!Phaser.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !Phaser.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                                var width = this.width, height = this.height;
                                this._lastReportedCanvasSize.setTo(0, 0, width, height), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), 
                                this.grid.onResize(width, height), this.onSizeChange.dispatch(this, width, height), 
                                this.currentScaleMode === Phaser.ScaleManager.RESIZE && (this.game.state.resize(width, height), 
                                this.game.load.resize(width, height));
                            }
                        },
                        setMinMax: function(minWidth, minHeight, maxWidth, maxHeight) {
                            this.minWidth = minWidth, this.minHeight = minHeight, "undefined" != typeof maxWidth && (this.maxWidth = maxWidth), 
                            "undefined" != typeof maxHeight && (this.maxHeight = maxHeight);
                        },
                        preUpdate: function() {
                            if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                                var prevThrottle = this._updateThrottle;
                                this._updateThrottleReset = prevThrottle >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                                var prevWidth = this._parentBounds.width, prevHeight = this._parentBounds.height, bounds = this.getParentBounds(this._parentBounds), boundsChanged = bounds.width !== prevWidth || bounds.height !== prevHeight, orientationChanged = this.updateOrientationState();
                                (boundsChanged || orientationChanged) && (this.onResize && this.onResize.call(this.onResizeContext, this, bounds), 
                                this.updateLayout(), this.signalSizeChange());
                                var throttle = 2 * this._updateThrottle;
                                this._updateThrottle < prevThrottle && (throttle = Math.min(prevThrottle, this._updateThrottleReset)), 
                                this._updateThrottle = Phaser.Math.clamp(throttle, 25, this.trackParentInterval), 
                                this._lastUpdate = this.game.time.time;
                            }
                        },
                        pauseUpdate: function() {
                            this.preUpdate(), this._updateThrottle = this.trackParentInterval;
                        },
                        updateDimensions: function(width, height, resize) {
                            this.width = width * this.parentScaleFactor.x, this.height = height * this.parentScaleFactor.y, 
                            this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, 
                            this.updateScalingAndBounds(), resize && (this.game.renderer.resize(this.width, this.height), 
                            this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height));
                        },
                        updateScalingAndBounds: function() {
                            this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, 
                            this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, 
                            this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), 
                            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y);
                        },
                        forceOrientation: function(forceLandscape, forcePortrait) {
                            "undefined" == typeof forcePortrait && (forcePortrait = !1), this.forceLandscape = forceLandscape, 
                            this.forcePortrait = forcePortrait, this.queueUpdate(!0);
                        },
                        classifyOrientation: function(orientation) {
                            return "portrait-primary" === orientation || "portrait-secondary" === orientation ? "portrait" : "landscape-primary" === orientation || "landscape-secondary" === orientation ? "landscape" : null;
                        },
                        updateOrientationState: function() {
                            var previousOrientation = this.screenOrientation, previouslyIncorrect = this.incorrectOrientation;
                            this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), 
                            this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                            var changed = previousOrientation !== this.screenOrientation, correctnessChanged = previouslyIncorrect !== this.incorrectOrientation;
                            return changed && (this.isLandscape ? this.enterLandscape.dispatch(this.orientation, !0, !1) : this.enterPortrait.dispatch(this.orientation, !1, !0)), 
                            correctnessChanged && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), 
                            (changed || correctnessChanged) && this.onOrientationChange.dispatch(this, previousOrientation, previouslyIncorrect), 
                            changed || correctnessChanged;
                        },
                        orientationChange: function(event) {
                            this.event = event, this.queueUpdate(!0);
                        },
                        windowResize: function(event) {
                            this.event = event, this.queueUpdate(!0);
                        },
                        scrollTop: function() {
                            var scrollTo = this.compatibility.scrollTo;
                            scrollTo && window.scrollTo(scrollTo.x, scrollTo.y);
                        },
                        refresh: function() {
                            this.scrollTop(), this.queueUpdate(!0);
                        },
                        updateLayout: function() {
                            var scaleMode = this.currentScaleMode;
                            if (scaleMode === Phaser.ScaleManager.RESIZE) return void this.reflowGame();
                            if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), 
                            this.incorrectOrientation ? this.setMaximum() : scaleMode === Phaser.ScaleManager.EXACT_FIT ? this.setExactFit() : scaleMode === Phaser.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), 
                            this.resetCanvas(), this.setShowAll()) : this.setShowAll() : scaleMode === Phaser.ScaleManager.NO_SCALE ? (this.width = this.game.width, 
                            this.height = this.game.height) : scaleMode === Phaser.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, 
                            this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), 
                            !this.compatibility.canExpandParent && (scaleMode === Phaser.ScaleManager.SHOW_ALL || scaleMode === Phaser.ScaleManager.USER_SCALE)) {
                                var bounds = this.getParentBounds(this._tempBounds);
                                this.width = Math.min(this.width, bounds.width), this.height = Math.min(this.height, bounds.height);
                            }
                            this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas();
                        },
                        getParentBounds: function(target) {
                            var bounds = target || new Phaser.Rectangle(), parentNode = this.boundingParent, visualBounds = this.dom.visualBounds, layoutBounds = this.dom.layoutBounds;
                            if (parentNode) {
                                var clientRect = parentNode.getBoundingClientRect();
                                bounds.setTo(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
                                var wc = this.windowConstraints;
                                if (wc.right) {
                                    var windowBounds = "layout" === wc.right ? layoutBounds : visualBounds;
                                    bounds.right = Math.min(bounds.right, windowBounds.width);
                                }
                                if (wc.bottom) {
                                    var windowBounds = "layout" === wc.bottom ? layoutBounds : visualBounds;
                                    bounds.bottom = Math.min(bounds.bottom, windowBounds.height);
                                }
                            } else bounds.setTo(0, 0, visualBounds.width, visualBounds.height);
                            return bounds.setTo(Math.round(bounds.x), Math.round(bounds.y), Math.round(bounds.width), Math.round(bounds.height)), 
                            bounds;
                        },
                        alignCanvas: function(horizontal, vertical) {
                            var parentBounds = this.getParentBounds(this._tempBounds), canvas = this.game.canvas, margin = this.margin;
                            if (horizontal) {
                                margin.left = margin.right = 0;
                                var canvasBounds = canvas.getBoundingClientRect();
                                if (this.width < parentBounds.width && !this.incorrectOrientation) {
                                    var currentEdge = canvasBounds.left - parentBounds.x, targetEdge = parentBounds.width / 2 - this.width / 2;
                                    targetEdge = Math.max(targetEdge, 0);
                                    var offset = targetEdge - currentEdge;
                                    margin.left = Math.round(offset);
                                }
                                canvas.style.marginLeft = margin.left + "px", 0 !== margin.left && (margin.right = -(parentBounds.width - canvasBounds.width - margin.left), 
                                canvas.style.marginRight = margin.right + "px");
                            }
                            if (vertical) {
                                margin.top = margin.bottom = 0;
                                var canvasBounds = canvas.getBoundingClientRect();
                                if (this.height < parentBounds.height && !this.incorrectOrientation) {
                                    var currentEdge = canvasBounds.top - parentBounds.y, targetEdge = parentBounds.height / 2 - this.height / 2;
                                    targetEdge = Math.max(targetEdge, 0);
                                    var offset = targetEdge - currentEdge;
                                    margin.top = Math.round(offset);
                                }
                                canvas.style.marginTop = margin.top + "px", 0 !== margin.top && (margin.bottom = -(parentBounds.height - canvasBounds.height - margin.top), 
                                canvas.style.marginBottom = margin.bottom + "px");
                            }
                            margin.x = margin.left, margin.y = margin.top;
                        },
                        reflowGame: function() {
                            this.resetCanvas("", "");
                            var bounds = this.getParentBounds(this._tempBounds);
                            this.updateDimensions(bounds.width, bounds.height, !0);
                        },
                        reflowCanvas: function() {
                            this.incorrectOrientation || (this.width = Phaser.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), 
                            this.height = Phaser.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), 
                            this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), 
                            this.updateScalingAndBounds();
                        },
                        resetCanvas: function(cssWidth, cssHeight) {
                            "undefined" == typeof cssWidth && (cssWidth = this.width + "px"), "undefined" == typeof cssHeight && (cssHeight = this.height + "px");
                            var canvas = this.game.canvas;
                            this.compatibility.noMargins || (canvas.style.marginLeft = "", canvas.style.marginTop = "", 
                            canvas.style.marginRight = "", canvas.style.marginBottom = ""), canvas.style.width = cssWidth, 
                            canvas.style.height = cssHeight;
                        },
                        queueUpdate: function(force) {
                            force && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset;
                        },
                        reset: function(clearWorld) {
                            clearWorld && this.grid.reset();
                        },
                        setMaximum: function() {
                            this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height;
                        },
                        setShowAll: function(expanding) {
                            var multiplier, bounds = this.getParentBounds(this._tempBounds), width = bounds.width, height = bounds.height;
                            multiplier = expanding ? Math.max(height / this.game.height, width / this.game.width) : Math.min(height / this.game.height, width / this.game.width), 
                            this.width = Math.round(this.game.width * multiplier), this.height = Math.round(this.game.height * multiplier);
                        },
                        setExactFit: function() {
                            var bounds = this.getParentBounds(this._tempBounds);
                            this.width = bounds.width, this.height = bounds.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), 
                            this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)));
                        },
                        createFullScreenTarget: function() {
                            var fsTarget = document.createElement("div");
                            return fsTarget.style.margin = "0", fsTarget.style.padding = "0", fsTarget.style.background = "#000", 
                            fsTarget;
                        },
                        startFullScreen: function(antialias, allowTrampoline) {
                            if (this.isFullScreen) return !1;
                            if (!this.compatibility.supportsFullScreen) {
                                var _this = this;
                                return void setTimeout(function() {
                                    _this.fullScreenError();
                                }, 10);
                            }
                            if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                                var input = this.game.input;
                                if (input.activePointer && input.activePointer !== input.mousePointer && (allowTrampoline || allowTrampoline !== !1)) return void input.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [ antialias, !1 ]);
                            }
                            "undefined" != typeof antialias && this.game.renderType === Phaser.CANVAS && (this.game.stage.smoothed = antialias);
                            var fsTarget = this.fullScreenTarget;
                            fsTarget || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), 
                            fsTarget = this._createdFullScreenTarget);
                            var initData = {
                                targetElement: fsTarget
                            };
                            if (this.onFullScreenInit.dispatch(this, initData), this._createdFullScreenTarget) {
                                var canvas = this.game.canvas, parent = canvas.parentNode;
                                parent.insertBefore(fsTarget, canvas), fsTarget.appendChild(canvas);
                            }
                            return this.game.device.fullscreenKeyboard ? fsTarget[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : fsTarget[this.game.device.requestFullscreen](), 
                            !0;
                        },
                        stopFullScreen: function() {
                            return this.isFullScreen && this.compatibility.supportsFullScreen ? (document[this.game.device.cancelFullscreen](), 
                            !0) : !1;
                        },
                        cleanupCreatedTarget: function() {
                            var fsTarget = this._createdFullScreenTarget;
                            if (fsTarget && fsTarget.parentNode) {
                                var parent = fsTarget.parentNode;
                                parent.insertBefore(this.game.canvas, fsTarget), parent.removeChild(fsTarget);
                            }
                            this._createdFullScreenTarget = null;
                        },
                        prepScreenMode: function(enteringFullscreen) {
                            var createdTarget = !!this._createdFullScreenTarget, fsTarget = this._createdFullScreenTarget || this.fullScreenTarget;
                            enteringFullscreen ? (createdTarget || this.fullScreenScaleMode === Phaser.ScaleManager.EXACT_FIT) && fsTarget !== this.game.canvas && (this._fullScreenRestore = {
                                targetWidth: fsTarget.style.width,
                                targetHeight: fsTarget.style.height
                            }, fsTarget.style.width = "100%", fsTarget.style.height = "100%") : (this._fullScreenRestore && (fsTarget.style.width = this._fullScreenRestore.targetWidth, 
                            fsTarget.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), 
                            this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas());
                        },
                        fullScreenChange: function(event) {
                            this.event = event, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), 
                            this.queueUpdate(!0), this.enterFullScreen.dispatch(this.width, this.height)) : (this.prepScreenMode(!1), 
                            this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0), this.leaveFullScreen.dispatch(this.width, this.height)), 
                            this.onFullScreenChange.dispatch(this);
                        },
                        fullScreenError: function(event) {
                            this.event = event, this.cleanupCreatedTarget(), console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"), 
                            this.onFullScreenError.dispatch(this);
                        },
                        scaleSprite: function(sprite, width, height, letterBox) {
                            if ("undefined" == typeof width && (width = this.width), "undefined" == typeof height && (height = this.height), 
                            "undefined" == typeof letterBox && (letterBox = !1), sprite.scale.set(1), sprite.width <= 0 || sprite.height <= 0 || 0 >= width || 0 >= height) return sprite;
                            var scaleX1 = width, scaleY1 = sprite.height * width / sprite.width, scaleX2 = sprite.width * height / sprite.height, scaleY2 = height, scaleOnWidth = scaleX2 > width;
                            return scaleOnWidth = scaleOnWidth ? letterBox : !letterBox, scaleOnWidth ? (sprite.width = Math.floor(scaleX1), 
                            sprite.height = Math.floor(scaleY1)) : (sprite.width = Math.floor(scaleX2), sprite.height = Math.floor(scaleY2)), 
                            sprite;
                        },
                        destroy: function() {
                            this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), 
                            window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), 
                            document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), 
                            document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), 
                            document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), 
                            document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), 
                            document.removeEventListener("fullscreenerror", this._fullScreenError, !1));
                        }
                    }, Phaser.ScaleManager.prototype.constructor = Phaser.ScaleManager, Phaser.ScaleManager.prototype.checkResize = Phaser.ScaleManager.prototype.windowResize, 
                    Phaser.ScaleManager.prototype.checkOrientation = Phaser.ScaleManager.prototype.orientationChange, 
                    Phaser.ScaleManager.prototype.setScreenSize = Phaser.ScaleManager.prototype.updateLayout, 
                    Phaser.ScaleManager.prototype.setSize = Phaser.ScaleManager.prototype.reflowCanvas, 
                    Phaser.ScaleManager.prototype.checkOrientationState = function() {
                        var changed = this.updateOrientationState();
                        return changed && this.refresh(), changed;
                    }, Object.defineProperty(Phaser.ScaleManager.prototype, "boundingParent", {
                        get: function() {
                            if (this.parentIsWindow || this.isFullScreen && !this._createdFullScreenTarget) return null;
                            var parentNode = this.game.canvas && this.game.canvas.parentNode;
                            return parentNode || null;
                        }
                    }), Object.defineProperty(Phaser.ScaleManager.prototype, "scaleMode", {
                        get: function() {
                            return this._scaleMode;
                        },
                        set: function(value) {
                            return value !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), 
                            this.queueUpdate(!0)), this._scaleMode = value), this._scaleMode;
                        }
                    }), Object.defineProperty(Phaser.ScaleManager.prototype, "fullScreenScaleMode", {
                        get: function() {
                            return this._fullScreenScaleMode;
                        },
                        set: function(value) {
                            return value !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), 
                            this._fullScreenScaleMode = value, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = value), 
                            this._fullScreenScaleMode;
                        }
                    }), Object.defineProperty(Phaser.ScaleManager.prototype, "currentScaleMode", {
                        get: function() {
                            return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode;
                        }
                    }), Object.defineProperty(Phaser.ScaleManager.prototype, "pageAlignHorizontally", {
                        get: function() {
                            return this._pageAlignHorizontally;
                        },
                        set: function(value) {
                            value !== this._pageAlignHorizontally && (this._pageAlignHorizontally = value, this.queueUpdate(!0));
                        }
                    }), Object.defineProperty(Phaser.ScaleManager.prototype, "pageAlignVertically", {
                        get: function() {
                            return this._pageAlignVertically;
                        },
                        set: function(value) {
                            value !== this._pageAlignVertically && (this._pageAlignVertically = value, this.queueUpdate(!0));
                        }
                    }), Object.defineProperty(Phaser.ScaleManager.prototype, "isFullScreen", {
                        get: function() {
                            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
                        }
                    }), Object.defineProperty(Phaser.ScaleManager.prototype, "isPortrait", {
                        get: function() {
                            return "portrait" === this.classifyOrientation(this.screenOrientation);
                        }
                    }), Object.defineProperty(Phaser.ScaleManager.prototype, "isLandscape", {
                        get: function() {
                            return "landscape" === this.classifyOrientation(this.screenOrientation);
                        }
                    }), Object.defineProperty(Phaser.ScaleManager.prototype, "orientation", {
                        get: function() {
                            return "portrait" === this.classifyOrientation(this.screenOrientation) ? 0 : 90;
                        }
                    }), Phaser.Game = function(width, height, renderer, parent, state, transparent, antialias, physicsConfig) {
                        return this.id = Phaser.GAMES.push(this) - 1, this.config = null, this.physicsConfig = physicsConfig, 
                        this.parent = "", this.width = 800, this.height = 600, this._width = 800, this._height = 600, 
                        this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.renderer = null, 
                        this.renderType = Phaser.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, 
                        this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, 
                        this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, 
                        this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, 
                        this.rnd = null, this.device = Phaser.Device, this.camera = null, this.canvas = null, 
                        this.context = null, this.debug = null, this.particles = null, this.lockRender = !1, 
                        this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, 
                        this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, 
                        this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, 
                        this._lastCount = 0, this._spiralling = 0, this.fpsProblemNotifier = new Phaser.Signal(), 
                        this.forceSingleUpdate = !1, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
                            enableDebug: !0
                        }, "undefined" != typeof width && (this._width = width), "undefined" != typeof height && (this._height = height), 
                        "undefined" != typeof renderer && (this.renderType = renderer), "undefined" != typeof parent && (this.parent = parent), 
                        "undefined" != typeof transparent && (this.transparent = transparent), "undefined" != typeof antialias && (this.antialias = antialias), 
                        this.rnd = new Phaser.RandomDataGenerator([ (Date.now() * Math.random()).toString() ]), 
                        this.state = new Phaser.StateManager(this, state)), this.device.whenReady(this.boot, this), 
                        this;
                    }, Phaser.Game.prototype = {
                        parseConfig: function(config) {
                            this.config = config, "undefined" == typeof config.enableDebug && (this.config.enableDebug = !0), 
                            config.width && (this._width = config.width), config.height && (this._height = config.height), 
                            config.renderer && (this.renderType = config.renderer), config.parent && (this.parent = config.parent), 
                            config.transparent && (this.transparent = config.transparent), config.antialias && (this.antialias = config.antialias), 
                            config.preserveDrawingBuffer && (this.preserveDrawingBuffer = config.preserveDrawingBuffer), 
                            config.physicsConfig && (this.physicsConfig = config.physicsConfig);
                            var seed = [ (Date.now() * Math.random()).toString() ];
                            config.seed && (seed = config.seed), this.rnd = new Phaser.RandomDataGenerator(seed);
                            var state = null;
                            config.state && (state = config.state), this.state = new Phaser.StateManager(this, state);
                        },
                        boot: function() {
                            this.isBooted || (this.onPause = new Phaser.Signal(), this.onResume = new Phaser.Signal(), 
                            this.onBlur = new Phaser.Signal(), this.onFocus = new Phaser.Signal(), this.isBooted = !0, 
                            this.math = Phaser.Math, this.scale = new Phaser.ScaleManager(this, this._width, this._height), 
                            this.stage = new Phaser.Stage(this), this.setUpRenderer(), this.world = new Phaser.World(this), 
                            this.add = new Phaser.GameObjectFactory(this), this.make = new Phaser.GameObjectCreator(this), 
                            this.cache = new Phaser.Cache(this), this.load = new Phaser.Loader(this), this.time = new Phaser.Time(this), 
                            this.tweens = new Phaser.TweenManager(this), this.input = new Phaser.Input(this), 
                            this.sound = new Phaser.SoundManager(this), this.physics = new Phaser.Physics(this, this.physicsConfig), 
                            this.particles = new Phaser.Particles(this), this.plugins = new Phaser.PluginManager(this), 
                            this.net = new Phaser.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), 
                            this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new Phaser.Utils.Debug(this), 
                            this.debug.boot()) : this.debug = {
                                preUpdate: function() {},
                                update: function() {},
                                reset: function() {}
                            }, this.showDebugHeader(), this.isRunning = !0, this.raf = this.config && this.config.forceSetTimeOut ? new Phaser.RequestAnimationFrame(this, this.config.forceSetTimeOut) : new Phaser.RequestAnimationFrame(this, !1), 
                            this.raf.start());
                        },
                        showDebugHeader: function() {
                            var v = Phaser.VERSION, r = "Canvas", a = "HTML Audio", c = 1;
                            if (this.renderType === Phaser.WEBGL ? (r = "WebGL", c++) : this.renderType == Phaser.HEADLESS && (r = "Headless"), 
                            this.device.webAudio && (a = "WebAudio", c++), this.device.chrome) {
                                for (var args = [ "%c %c %c Phaser v" + v + " | Pixi.js " + PIXI.VERSION + " | " + r + " | " + a + "  %c %c %c http://phaser.io %c♥%c♥%c♥", "background: #3db79f", "background: #329582", "color: #ffffff; background: #226558;", "background: #329582", "background: #3db79f", "background: #ffffff" ], i = 0; 3 > i; i++) args.push(c > i ? "color: #ff2424; background: #fff" : "color: #959595; background: #fff");
                                console.log.apply(console, args);
                            } else window.console && console.log("Phaser v" + v + " | Pixi.js " + PIXI.VERSION + " | " + r + " | " + a + " | http://phaser.io");
                        },
                        setUpRenderer: function() {
                            if (this.canvas = this.config.canvasID ? Phaser.Canvas.create(this.width, this.height, this.config.canvasID) : Phaser.Canvas.create(this.width, this.height), 
                            this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", 
                            this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === Phaser.CANVAS ? !0 : !1), 
                            this.renderType === Phaser.HEADLESS || this.renderType === Phaser.CANVAS || this.renderType === Phaser.AUTO && this.device.webGL === !1) {
                                if (!this.device.canvas) throw new Error("Phaser.Game - cannot create Canvas or WebGL context, aborting.");
                                this.renderType === Phaser.AUTO && (this.renderType = Phaser.CANVAS), this.renderer = new PIXI.CanvasRenderer(this.width, this.height, {
                                    view: this.canvas,
                                    transparent: this.transparent,
                                    resolution: 1,
                                    clearBeforeRender: !0
                                }), this.context = this.renderer.context;
                            } else this.renderType = Phaser.WEBGL, this.renderer = new PIXI.WebGLRenderer(this.width, this.height, {
                                view: this.canvas,
                                transparent: this.transparent,
                                resolution: 1,
                                antialias: this.antialias,
                                preserveDrawingBuffer: this.preserveDrawingBuffer
                            }), this.context = null;
                            this.renderType !== Phaser.HEADLESS && (this.stage.smoothed = this.antialias, Phaser.Canvas.addToDOM(this.canvas, this.parent, !1), 
                            Phaser.Canvas.setTouchAction(this.canvas));
                        },
                        update: function(time) {
                            if (this.time.update(time), this._spiralling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, 
                            this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiralling = 0, 
                            this.updateRender(this.time.slowMotion * this.time.desiredFps); else {
                                var slowStep = 1e3 * this.time.slowMotion / this.time.desiredFps;
                                this._deltaTime += Math.max(Math.min(3 * slowStep, this.time.elapsed), 0);
                                var count = 0;
                                for (this.updatesThisFrame = Math.floor(this._deltaTime / slowStep), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= slowStep && (this._deltaTime -= slowStep, 
                                this.currentUpdateID = count, this.updateLogic(1 / this.time.desiredFps), this.stage.updateTransform(), 
                                count++, !this.forceSingleUpdate || 1 !== count); ) ;
                                count > this._lastCount ? this._spiralling++ : count < this._lastCount && (this._spiralling = 0), 
                                this._lastCount = count, this.updateRender(this._deltaTime / slowStep);
                            }
                        },
                        updateLogic: function(timeStep) {
                            this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), 
                            this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), 
                            this.debug.preUpdate(), this.world.camera.preUpdate(), this.physics.preUpdate(), 
                            this.state.preUpdate(timeStep), this.plugins.preUpdate(timeStep), this.stage.preUpdate(), 
                            this.state.update(), this.stage.update(), this.tweens.update(timeStep), this.sound.update(), 
                            this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), 
                            this.stage.postUpdate(), this.plugins.postUpdate());
                        },
                        updateRender: function(elapsedTime) {
                            this.lockRender || (this.state.preRender(elapsedTime), this.renderer.render(this.stage), 
                            this.plugins.render(elapsedTime), this.state.render(elapsedTime), this.plugins.postRender(elapsedTime));
                        },
                        enableStep: function() {
                            this.stepping = !0, this.pendingStep = !1, this.stepCount = 0;
                        },
                        disableStep: function() {
                            this.stepping = !1, this.pendingStep = !1;
                        },
                        step: function() {
                            this.pendingStep = !1, this.stepCount++;
                        },
                        destroy: function() {
                            this.raf.stop(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), 
                            this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.state = null, 
                            this.cache = null, this.input = null, this.load = null, this.sound = null, this.stage = null, 
                            this.time = null, this.world = null, this.isBooted = !1, this.renderType === Phaser.WEBGL ? (PIXI.glContexts[this.renderer.glContextId] = null, 
                            this.renderer.projection = null, this.renderer.offset = null, this.renderer.shaderManager.destroy(), 
                            this.renderer.spriteBatch.destroy(), this.renderer.maskManager.destroy(), this.renderer.filterManager.destroy(), 
                            this.renderer.shaderManager = null, this.renderer.spriteBatch = null, this.renderer.maskManager = null, 
                            this.renderer.filterManager = null, this.renderer.gl = null, this.renderer.renderSession = null, 
                            Phaser.Canvas.removeFromDOM(this.canvas)) : this.renderer.destroy(!0), Phaser.GAMES[this.id] = null;
                        },
                        gamePaused: function(event) {
                            this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.setMute(), 
                            this.onPause.dispatch(event));
                        },
                        gameResumed: function(event) {
                            this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), 
                            this.input.reset(), this.sound.unsetMute(), this.onResume.dispatch(event));
                        },
                        focusLoss: function(event) {
                            this.onBlur.dispatch(event), this.stage.disableVisibilityChange || this.gamePaused(event);
                        },
                        focusGain: function(event) {
                            this.onFocus.dispatch(event), this.stage.disableVisibilityChange || this.gameResumed(event);
                        }
                    }, Phaser.Game.prototype.constructor = Phaser.Game, Object.defineProperty(Phaser.Game.prototype, "paused", {
                        get: function() {
                            return this._paused;
                        },
                        set: function(value) {
                            value === !0 ? (this._paused === !1 && (this._paused = !0, this.sound.setMute(), 
                            this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, 
                            this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), 
                            this._codePaused = !1);
                        }
                    }), Phaser.Input = function(game) {
                        this.game = game, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], 
                        this.moveCallback = null, this.moveCallbackContext = this, this.pollRate = 0, this.enabled = !0, 
                        this.multiInputOverride = Phaser.Input.MOUSE_TOUCH_COMBINE, this.position = null, 
                        this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, 
                        this.currentPointers = 0, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, 
                        this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, 
                        this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, 
                        this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, 
                        this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, 
                        this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, 
                        this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, 
                        this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, 
                        this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new Phaser.ArraySet(), 
                        this._localPoint = new Phaser.Point(), this._pollCounter = 0, this._oldPosition = null, 
                        this._x = 0, this._y = 0;
                    }, Phaser.Input.MOUSE_OVERRIDES_TOUCH = 0, Phaser.Input.TOUCH_OVERRIDES_MOUSE = 1, 
                    Phaser.Input.MOUSE_TOUCH_COMBINE = 2, Phaser.Input.MAX_POINTERS = 10, Phaser.Input.prototype = {
                        boot: function() {
                            this.mousePointer = new Phaser.Pointer(this.game, 0), this.addPointer(), this.addPointer(), 
                            this.mouse = new Phaser.Mouse(this.game), this.keyboard = new Phaser.Keyboard(this.game), 
                            this.touch = new Phaser.Touch(this.game), this.mspointer = new Phaser.MSPointer(this.game), 
                            this.gamepad = new Phaser.Gamepad(this.game), this.onDown = new Phaser.Signal(), 
                            this.onUp = new Phaser.Signal(), this.onTap = new Phaser.Signal(), this.onHold = new Phaser.Signal(), 
                            this.scale = new Phaser.Point(1, 1), this.speed = new Phaser.Point(), this.position = new Phaser.Point(), 
                            this._oldPosition = new Phaser.Point(), this.circle = new Phaser.Circle(0, 0, 44), 
                            this.activePointer = this.mousePointer, this.currentPointers = 0, this.hitCanvas = document.createElement("canvas"), 
                            this.hitCanvas.width = 1, this.hitCanvas.height = 1, this.hitContext = this.hitCanvas.getContext("2d"), 
                            this.mouse.start(), this.keyboard.start(), this.touch.start(), this.mspointer.start(), 
                            this.mousePointer.active = !0;
                            var _this = this;
                            this._onClickTrampoline = function(event) {
                                _this.onClickTrampoline(event);
                            }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1);
                        },
                        destroy: function() {
                            this.mouse.stop(), this.keyboard.stop(), this.touch.stop(), this.mspointer.stop(), 
                            this.gamepad.stop(), this.moveCallbacks = [], this.game.canvas.removeEventListener("click", this._onClickTrampoline);
                        },
                        addMoveCallback: function(callback, context) {
                            return this.moveCallbacks.push({
                                callback: callback,
                                context: context
                            }) - 1;
                        },
                        deleteMoveCallback: function(index) {
                            this.moveCallbacks[index] && this.moveCallbacks.splice(index, 1);
                        },
                        addPointer: function() {
                            if (this.pointers.length >= Phaser.Input.MAX_POINTERS) return console.warn("Phaser.Input.addPointer: only " + Phaser.Input.MAX_POINTERS + " pointer allowed"), 
                            null;
                            var id = this.pointers.length + 1, pointer = new Phaser.Pointer(this.game, id);
                            return this.pointers.push(pointer), this["pointer" + id] = pointer, pointer;
                        },
                        update: function() {
                            if (this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) return void this._pollCounter++;
                            this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, 
                            this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad.active && this.gamepad.update();
                            for (var i = 0; i < this.pointers.length; i++) this.pointers[i].update();
                            this._pollCounter = 0;
                        },
                        reset: function(hard) {
                            if (this.game.isBooted && !this.resetLocked) {
                                "undefined" == typeof hard && (hard = !1), this.keyboard.reset(hard), this.mousePointer.reset(), 
                                this.gamepad.reset();
                                for (var i = 0; i < this.pointers.length; i++) this.pointers[i].reset();
                                this.currentPointers = 0, "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), 
                                hard && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), 
                                this.onDown = new Phaser.Signal(), this.onUp = new Phaser.Signal(), this.onTap = new Phaser.Signal(), 
                                this.onHold = new Phaser.Signal(), this.moveCallbacks = []), this._pollCounter = 0;
                            }
                        },
                        resetSpeed: function(x, y) {
                            this._oldPosition.setTo(x, y), this.speed.setTo(0, 0);
                        },
                        startPointer: function(event) {
                            if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
                            if (!this.pointer1.active) return this.pointer1.start(event);
                            if (!this.pointer2.active) return this.pointer2.start(event);
                            for (var i = 2; i < this.pointers.length; i++) {
                                var pointer = this.pointers[i];
                                if (!pointer.active) return pointer.start(event);
                            }
                            return null;
                        },
                        updatePointer: function(event) {
                            if (this.pointer1.active && this.pointer1.identifier === event.identifier) return this.pointer1.move(event);
                            if (this.pointer2.active && this.pointer2.identifier === event.identifier) return this.pointer2.move(event);
                            for (var i = 2; i < this.pointers.length; i++) {
                                var pointer = this.pointers[i];
                                if (pointer.active && pointer.identifier === event.identifier) return pointer.move(event);
                            }
                            return null;
                        },
                        stopPointer: function(event) {
                            if (this.pointer1.active && this.pointer1.identifier === event.identifier) return this.pointer1.stop(event);
                            if (this.pointer2.active && this.pointer2.identifier === event.identifier) return this.pointer2.stop(event);
                            for (var i = 2; i < this.pointers.length; i++) {
                                var pointer = this.pointers[i];
                                if (pointer.active && pointer.identifier === event.identifier) return pointer.stop(event);
                            }
                            return null;
                        },
                        countActivePointers: function(limit) {
                            "undefined" == typeof limit && (limit = this.pointers.length);
                            for (var count = limit, i = 0; i < this.pointers.length && count > 0; i++) {
                                var pointer = this.pointers[i];
                                pointer.active && count--;
                            }
                            return this.currentPointers = limit - count, limit - count;
                        },
                        getPointer: function(isActive) {
                            "undefined" == typeof isActive && (isActive = !1);
                            for (var i = 0; i < this.pointers.length; i++) {
                                var pointer = this.pointers[i];
                                if (pointer.active === isActive) return pointer;
                            }
                            return null;
                        },
                        getPointerFromIdentifier: function(identifier) {
                            for (var i = 0; i < this.pointers.length; i++) {
                                var pointer = this.pointers[i];
                                if (pointer.identifier === identifier) return pointer;
                            }
                            return null;
                        },
                        getPointerFromId: function(pointerId) {
                            for (var i = 0; i < this.pointers.length; i++) {
                                var pointer = this.pointers[i];
                                if (pointer.pointerId === pointerId) return pointer;
                            }
                            return null;
                        },
                        getLocalPosition: function(displayObject, pointer, output) {
                            "undefined" == typeof output && (output = new Phaser.Point());
                            var wt = displayObject.worldTransform, id = 1 / (wt.a * wt.d + wt.c * -wt.b);
                            return output.setTo(wt.d * id * pointer.x + -wt.c * id * pointer.y + (wt.ty * wt.c - wt.tx * wt.d) * id, wt.a * id * pointer.y + -wt.b * id * pointer.x + (-wt.ty * wt.a + wt.tx * wt.b) * id);
                        },
                        hitTest: function(displayObject, pointer, localPoint) {
                            if (!displayObject.worldVisible) return !1;
                            if (this.getLocalPosition(displayObject, pointer, this._localPoint), localPoint.copyFrom(this._localPoint), 
                            displayObject.hitArea && displayObject.hitArea.contains) return displayObject.hitArea.contains(this._localPoint.x, this._localPoint.y);
                            if (displayObject instanceof PIXI.Sprite) {
                                var width = displayObject.texture.frame.width, height = displayObject.texture.frame.height, x1 = -width * displayObject.anchor.x;
                                if (this._localPoint.x >= x1 && this._localPoint.x < x1 + width) {
                                    var y1 = -height * displayObject.anchor.y;
                                    if (this._localPoint.y >= y1 && this._localPoint.y < y1 + height) return !0;
                                }
                            } else if (displayObject instanceof Phaser.TileSprite) {
                                var width = displayObject.width, height = displayObject.height, x1 = -width * displayObject.anchor.x;
                                if (this._localPoint.x >= x1 && this._localPoint.x < x1 + width) {
                                    var y1 = -height * displayObject.anchor.y;
                                    if (this._localPoint.y >= y1 && this._localPoint.y < y1 + height) return !0;
                                }
                            } else if (displayObject instanceof Phaser.Graphics) for (var i = 0; i < displayObject.graphicsData.length; i++) {
                                var data = displayObject.graphicsData[i];
                                if (data.fill && data.shape && data.shape.contains(this._localPoint.x, this._localPoint.y)) return !0;
                            }
                            for (var i = 0, len = displayObject.children.length; len > i; i++) if (this.hitTest(displayObject.children[i], pointer, localPoint)) return !0;
                            return !1;
                        },
                        onClickTrampoline: function() {
                            this.activePointer.processClickTrampolines();
                        }
                    }, Phaser.Input.prototype.constructor = Phaser.Input, Object.defineProperty(Phaser.Input.prototype, "x", {
                        get: function() {
                            return this._x;
                        },
                        set: function(value) {
                            this._x = Math.floor(value);
                        }
                    }), Object.defineProperty(Phaser.Input.prototype, "y", {
                        get: function() {
                            return this._y;
                        },
                        set: function(value) {
                            this._y = Math.floor(value);
                        }
                    }), Object.defineProperty(Phaser.Input.prototype, "pollLocked", {
                        get: function() {
                            return this.pollRate > 0 && this._pollCounter < this.pollRate;
                        }
                    }), Object.defineProperty(Phaser.Input.prototype, "totalInactivePointers", {
                        get: function() {
                            return this.pointers.length - this.countActivePointers();
                        }
                    }), Object.defineProperty(Phaser.Input.prototype, "totalActivePointers", {
                        get: function() {
                            return this.countActivePointers();
                        }
                    }), Object.defineProperty(Phaser.Input.prototype, "worldX", {
                        get: function() {
                            return this.game.camera.view.x + this.x;
                        }
                    }), Object.defineProperty(Phaser.Input.prototype, "worldY", {
                        get: function() {
                            return this.game.camera.view.y + this.y;
                        }
                    }), Object.defineProperty(Phaser.Input.prototype, "disabled", {
                        get: function() {
                            return !this.enabled;
                        },
                        set: function(value) {
                            this.enabled = !value;
                        }
                    }), Phaser.Key = function(game, keycode) {
                        this.game = game, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, 
                        this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, 
                        this.timeUp = -2500, this.repeats = 0, this.keyCode = keycode, this.onDown = new Phaser.Signal(), 
                        this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new Phaser.Signal(), 
                        this._justDown = !1, this._justUp = !1;
                    }, Phaser.Key.prototype = {
                        update: function() {
                            this._enabled && this.isDown && (this.duration = this.game.time.time - this.timeDown, 
                            this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this));
                        },
                        processKeyDown: function(event) {
                            this._enabled && (this.event = event, this.isDown || (this.altKey = event.altKey, 
                            this.ctrlKey = event.ctrlKey, this.shiftKey = event.shiftKey, this.isDown = !0, 
                            this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.repeats = 0, 
                            this._justDown = !0, this.onDown.dispatch(this)));
                        },
                        processKeyUp: function(event) {
                            this._enabled && (this.event = event, this.isUp || (this.isDown = !1, this.isUp = !0, 
                            this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, 
                            this._justUp = !0, this.onUp.dispatch(this)));
                        },
                        reset: function(hard) {
                            "undefined" == typeof hard && (hard = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, 
                            this.duration = 0, this._enabled = !0, this._justDown = !1, this._justUp = !1, hard && (this.onDown.removeAll(), 
                            this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null);
                        },
                        downDuration: function(duration) {
                            return "undefined" == typeof duration && (duration = 50), this.isDown && this.duration < duration;
                        },
                        upDuration: function(duration) {
                            return "undefined" == typeof duration && (duration = 50), !this.isDown && this.game.time.time - this.timeUp < duration;
                        }
                    }, Object.defineProperty(Phaser.Key.prototype, "justDown", {
                        get: function() {
                            var current = this._justDown;
                            return this._justDown = !1, current;
                        }
                    }), Object.defineProperty(Phaser.Key.prototype, "justUp", {
                        get: function() {
                            var current = this._justUp;
                            return this._justUp = !1, current;
                        }
                    }), Object.defineProperty(Phaser.Key.prototype, "enabled", {
                        get: function() {
                            return this._enabled;
                        },
                        set: function(value) {
                            value = !!value, value !== this._enabled && (value || this.reset(!1), this._enabled = value);
                        }
                    }), Phaser.Key.prototype.constructor = Phaser.Key, Phaser.Keyboard = function(game) {
                        this.game = game, this.enabled = !0, this.event = null, this.pressEvent = null, 
                        this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, 
                        this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, 
                        this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0;
                    }, Phaser.Keyboard.prototype = {
                        addCallbacks: function(context, onDown, onUp, onPress) {
                            this.callbackContext = context, "undefined" != typeof onDown && (this.onDownCallback = onDown), 
                            "undefined" != typeof onUp && (this.onUpCallback = onUp), "undefined" != typeof onPress && (this.onPressCallback = onPress);
                        },
                        addKey: function(keycode) {
                            return this._keys[keycode] || (this._keys[keycode] = new Phaser.Key(this.game, keycode), 
                            this.addKeyCapture(keycode)), this._keys[keycode];
                        },
                        removeKey: function(keycode) {
                            this._keys[keycode] && (this._keys[keycode] = null, this.removeKeyCapture(keycode));
                        },
                        createCursorKeys: function() {
                            return {
                                up: this.addKey(Phaser.Keyboard.UP),
                                down: this.addKey(Phaser.Keyboard.DOWN),
                                left: this.addKey(Phaser.Keyboard.LEFT),
                                right: this.addKey(Phaser.Keyboard.RIGHT)
                            };
                        },
                        start: function() {
                            if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                                var _this = this;
                                this._onKeyDown = function(event) {
                                    return _this.processKeyDown(event);
                                }, this._onKeyUp = function(event) {
                                    return _this.processKeyUp(event);
                                }, this._onKeyPress = function(event) {
                                    return _this.processKeyPress(event);
                                }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), 
                                window.addEventListener("keypress", this._onKeyPress, !1);
                            }
                        },
                        stop: function() {
                            window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), 
                            window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, 
                            this._onKeyUp = null, this._onKeyPress = null;
                        },
                        destroy: function() {
                            this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0;
                        },
                        addKeyCapture: function(keycode) {
                            if ("object" == typeof keycode) for (var key in keycode) this._capture[keycode[key]] = !0; else this._capture[keycode] = !0;
                        },
                        removeKeyCapture: function(keycode) {
                            delete this._capture[keycode];
                        },
                        clearCaptures: function() {
                            this._capture = {};
                        },
                        update: function() {
                            for (this._i = this._keys.length; this._i--; ) this._keys[this._i] && this._keys[this._i].update();
                        },
                        processKeyDown: function(event) {
                            this.event = event, this.game.input.enabled && this.enabled && (this._capture[event.keyCode] && event.preventDefault(), 
                            this._keys[event.keyCode] || (this._keys[event.keyCode] = new Phaser.Key(this.game, event.keyCode)), 
                            this._keys[event.keyCode].processKeyDown(event), this._k = event.keyCode, this.onDownCallback && this.onDownCallback.call(this.callbackContext, event));
                        },
                        processKeyPress: function(event) {
                            this.pressEvent = event, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(event.charCode), event);
                        },
                        processKeyUp: function(event) {
                            this.event = event, this.game.input.enabled && this.enabled && (this._capture[event.keyCode] && event.preventDefault(), 
                            this._keys[event.keyCode] || (this._keys[event.keyCode] = new Phaser.Key(this.game, event.keyCode)), 
                            this._keys[event.keyCode].processKeyUp(event), this.onUpCallback && this.onUpCallback.call(this.callbackContext, event));
                        },
                        reset: function(hard) {
                            "undefined" == typeof hard && (hard = !0), this.event = null;
                            for (var i = this._keys.length; i--; ) this._keys[i] && this._keys[i].reset(hard);
                        },
                        downDuration: function(keycode, duration) {
                            return this._keys[keycode] ? this._keys[keycode].downDuration(duration) : null;
                        },
                        upDuration: function(keycode, duration) {
                            return this._keys[keycode] ? this._keys[keycode].upDuration(duration) : null;
                        },
                        isDown: function(keycode) {
                            return this._keys[keycode] ? this._keys[keycode].isDown : null;
                        }
                    }, Object.defineProperty(Phaser.Keyboard.prototype, "disabled", {
                        get: function() {
                            return !this.enabled;
                        },
                        set: function(value) {
                            this.enabled = !value;
                        }
                    }), Object.defineProperty(Phaser.Keyboard.prototype, "lastChar", {
                        get: function() {
                            return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode);
                        }
                    }), Object.defineProperty(Phaser.Keyboard.prototype, "lastKey", {
                        get: function() {
                            return this._keys[this._k];
                        }
                    }), Phaser.Keyboard.prototype.constructor = Phaser.Keyboard, Phaser.Keyboard.A = "A".charCodeAt(0), 
                    Phaser.Keyboard.B = "B".charCodeAt(0), Phaser.Keyboard.C = "C".charCodeAt(0), Phaser.Keyboard.D = "D".charCodeAt(0), 
                    Phaser.Keyboard.E = "E".charCodeAt(0), Phaser.Keyboard.F = "F".charCodeAt(0), Phaser.Keyboard.G = "G".charCodeAt(0), 
                    Phaser.Keyboard.H = "H".charCodeAt(0), Phaser.Keyboard.I = "I".charCodeAt(0), Phaser.Keyboard.J = "J".charCodeAt(0), 
                    Phaser.Keyboard.K = "K".charCodeAt(0), Phaser.Keyboard.L = "L".charCodeAt(0), Phaser.Keyboard.M = "M".charCodeAt(0), 
                    Phaser.Keyboard.N = "N".charCodeAt(0), Phaser.Keyboard.O = "O".charCodeAt(0), Phaser.Keyboard.P = "P".charCodeAt(0), 
                    Phaser.Keyboard.Q = "Q".charCodeAt(0), Phaser.Keyboard.R = "R".charCodeAt(0), Phaser.Keyboard.S = "S".charCodeAt(0), 
                    Phaser.Keyboard.T = "T".charCodeAt(0), Phaser.Keyboard.U = "U".charCodeAt(0), Phaser.Keyboard.V = "V".charCodeAt(0), 
                    Phaser.Keyboard.W = "W".charCodeAt(0), Phaser.Keyboard.X = "X".charCodeAt(0), Phaser.Keyboard.Y = "Y".charCodeAt(0), 
                    Phaser.Keyboard.Z = "Z".charCodeAt(0), Phaser.Keyboard.ZERO = "0".charCodeAt(0), 
                    Phaser.Keyboard.ONE = "1".charCodeAt(0), Phaser.Keyboard.TWO = "2".charCodeAt(0), 
                    Phaser.Keyboard.THREE = "3".charCodeAt(0), Phaser.Keyboard.FOUR = "4".charCodeAt(0), 
                    Phaser.Keyboard.FIVE = "5".charCodeAt(0), Phaser.Keyboard.SIX = "6".charCodeAt(0), 
                    Phaser.Keyboard.SEVEN = "7".charCodeAt(0), Phaser.Keyboard.EIGHT = "8".charCodeAt(0), 
                    Phaser.Keyboard.NINE = "9".charCodeAt(0), Phaser.Keyboard.NUMPAD_0 = 96, Phaser.Keyboard.NUMPAD_1 = 97, 
                    Phaser.Keyboard.NUMPAD_2 = 98, Phaser.Keyboard.NUMPAD_3 = 99, Phaser.Keyboard.NUMPAD_4 = 100, 
                    Phaser.Keyboard.NUMPAD_5 = 101, Phaser.Keyboard.NUMPAD_6 = 102, Phaser.Keyboard.NUMPAD_7 = 103, 
                    Phaser.Keyboard.NUMPAD_8 = 104, Phaser.Keyboard.NUMPAD_9 = 105, Phaser.Keyboard.NUMPAD_MULTIPLY = 106, 
                    Phaser.Keyboard.NUMPAD_ADD = 107, Phaser.Keyboard.NUMPAD_ENTER = 108, Phaser.Keyboard.NUMPAD_SUBTRACT = 109, 
                    Phaser.Keyboard.NUMPAD_DECIMAL = 110, Phaser.Keyboard.NUMPAD_DIVIDE = 111, Phaser.Keyboard.F1 = 112, 
                    Phaser.Keyboard.F2 = 113, Phaser.Keyboard.F3 = 114, Phaser.Keyboard.F4 = 115, Phaser.Keyboard.F5 = 116, 
                    Phaser.Keyboard.F6 = 117, Phaser.Keyboard.F7 = 118, Phaser.Keyboard.F8 = 119, Phaser.Keyboard.F9 = 120, 
                    Phaser.Keyboard.F10 = 121, Phaser.Keyboard.F11 = 122, Phaser.Keyboard.F12 = 123, 
                    Phaser.Keyboard.F13 = 124, Phaser.Keyboard.F14 = 125, Phaser.Keyboard.F15 = 126, 
                    Phaser.Keyboard.COLON = 186, Phaser.Keyboard.EQUALS = 187, Phaser.Keyboard.UNDERSCORE = 189, 
                    Phaser.Keyboard.QUESTION_MARK = 191, Phaser.Keyboard.TILDE = 192, Phaser.Keyboard.OPEN_BRACKET = 219, 
                    Phaser.Keyboard.BACKWARD_SLASH = 220, Phaser.Keyboard.CLOSED_BRACKET = 221, Phaser.Keyboard.QUOTES = 222, 
                    Phaser.Keyboard.BACKSPACE = 8, Phaser.Keyboard.TAB = 9, Phaser.Keyboard.CLEAR = 12, 
                    Phaser.Keyboard.ENTER = 13, Phaser.Keyboard.SHIFT = 16, Phaser.Keyboard.CONTROL = 17, 
                    Phaser.Keyboard.ALT = 18, Phaser.Keyboard.CAPS_LOCK = 20, Phaser.Keyboard.ESC = 27, 
                    Phaser.Keyboard.SPACEBAR = 32, Phaser.Keyboard.PAGE_UP = 33, Phaser.Keyboard.PAGE_DOWN = 34, 
                    Phaser.Keyboard.END = 35, Phaser.Keyboard.HOME = 36, Phaser.Keyboard.LEFT = 37, 
                    Phaser.Keyboard.UP = 38, Phaser.Keyboard.RIGHT = 39, Phaser.Keyboard.DOWN = 40, 
                    Phaser.Keyboard.INSERT = 45, Phaser.Keyboard.DELETE = 46, Phaser.Keyboard.HELP = 47, 
                    Phaser.Keyboard.NUM_LOCK = 144, Phaser.Keyboard.PLUS = 43, Phaser.Keyboard.MINUS = 45, 
                    Phaser.Mouse = function(game) {
                        this.game = game, this.callbackContext = this.game, this.mouseDownCallback = null, 
                        this.mouseMoveCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, 
                        this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, 
                        this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, 
                        this.pointerLock = new Phaser.Signal(), this.event = null, this._onMouseDown = null, 
                        this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, 
                        this._onMouseWheel = null, this._wheelEvent = null;
                    }, Phaser.Mouse.NO_BUTTON = -1, Phaser.Mouse.LEFT_BUTTON = 0, Phaser.Mouse.MIDDLE_BUTTON = 1, 
                    Phaser.Mouse.RIGHT_BUTTON = 2, Phaser.Mouse.WHEEL_UP = 1, Phaser.Mouse.WHEEL_DOWN = -1, 
                    Phaser.Mouse.prototype = {
                        start: function() {
                            if ((!this.game.device.android || this.game.device.chrome !== !1) && null === this._onMouseDown) {
                                var _this = this;
                                this._onMouseDown = function(event) {
                                    return _this.onMouseDown(event);
                                }, this._onMouseMove = function(event) {
                                    return _this.onMouseMove(event);
                                }, this._onMouseUp = function(event) {
                                    return _this.onMouseUp(event);
                                }, this._onMouseUpGlobal = function(event) {
                                    return _this.onMouseUpGlobal(event);
                                }, this._onMouseOut = function(event) {
                                    return _this.onMouseOut(event);
                                }, this._onMouseOver = function(event) {
                                    return _this.onMouseOver(event);
                                }, this._onMouseWheel = function(event) {
                                    return _this.onMouseWheel(event);
                                }, this.game.canvas.addEventListener("mousedown", this._onMouseDown, !0), this.game.canvas.addEventListener("mousemove", this._onMouseMove, !0), 
                                this.game.canvas.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), 
                                this.game.canvas.addEventListener("mouseover", this._onMouseOver, !0), this.game.canvas.addEventListener("mouseout", this._onMouseOut, !0));
                                var wheelEvent = this.game.device.wheelEvent;
                                wheelEvent && (this.game.canvas.addEventListener(wheelEvent, this._onMouseWheel, !0), 
                                "mousewheel" === wheelEvent ? this._wheelEvent = new WheelEventProxy(-1 / 40, 1) : "DOMMouseScroll" === wheelEvent && (this._wheelEvent = new WheelEventProxy(1, 1)));
                            }
                        },
                        onMouseDown: function(event) {
                            this.event = event, this.capture && event.preventDefault(), this.button = event.button, 
                            this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, event), 
                            this.game.input.enabled && this.enabled && (event.identifier = 0, this.game.input.mousePointer.start(event));
                        },
                        onMouseMove: function(event) {
                            this.event = event, this.capture && event.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, event), 
                            this.game.input.enabled && this.enabled && (event.identifier = 0, this.game.input.mousePointer.move(event));
                        },
                        onMouseUp: function(event) {
                            this.event = event, this.capture && event.preventDefault(), this.button = Phaser.Mouse.NO_BUTTON, 
                            this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, event), 
                            this.game.input.enabled && this.enabled && (event.identifier = 0, this.game.input.mousePointer.stop(event));
                        },
                        onMouseUpGlobal: function(event) {
                            this.game.input.mousePointer.withinGame || (this.button = Phaser.Mouse.NO_BUTTON, 
                            this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, event), 
                            event.identifier = 0, this.game.input.mousePointer.stop(event));
                        },
                        onMouseOut: function(event) {
                            this.event = event, this.capture && event.preventDefault(), this.game.input.mousePointer.withinGame = !1, 
                            this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, event), 
                            this.game.input.enabled && this.enabled && this.stopOnGameOut && (event.identifier = 0, 
                            this.game.input.mousePointer.stop(event));
                        },
                        onMouseWheel: function(event) {
                            this._wheelEvent && (event = this._wheelEvent.bindEvent(event)), this.event = event, 
                            this.capture && event.preventDefault(), this.wheelDelta = Phaser.Math.clamp(-event.deltaY, -1, 1), 
                            this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, event);
                        },
                        onMouseOver: function(event) {
                            this.event = event, this.capture && event.preventDefault(), this.game.input.mousePointer.withinGame = !0, 
                            this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, event), 
                            !this.game.input.enabled || !this.enabled;
                        },
                        requestPointerLock: function() {
                            if (this.game.device.pointerLock) {
                                var element = this.game.canvas;
                                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock, 
                                element.requestPointerLock();
                                var _this = this;
                                this._pointerLockChange = function(event) {
                                    return _this.pointerLockChange(event);
                                }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), 
                                document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), 
                                document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0);
                            }
                        },
                        pointerLockChange: function(event) {
                            var element = this.game.canvas;
                            document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ? (this.locked = !0, 
                            this.pointerLock.dispatch(!0, event)) : (this.locked = !1, this.pointerLock.dispatch(!1, event));
                        },
                        releasePointerLock: function() {
                            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, 
                            document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), 
                            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), 
                            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0);
                        },
                        stop: function() {
                            this.game.canvas.removeEventListener("mousedown", this._onMouseDown, !0), this.game.canvas.removeEventListener("mousemove", this._onMouseMove, !0), 
                            this.game.canvas.removeEventListener("mouseup", this._onMouseUp, !0), this.game.canvas.removeEventListener("mouseover", this._onMouseOver, !0), 
                            this.game.canvas.removeEventListener("mouseout", this._onMouseOut, !0);
                            var wheelEvent = this.game.device.wheelEvent;
                            wheelEvent && this.game.canvas.removeEventListener(wheelEvent, this._onMouseWheel, !0), 
                            window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), 
                            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), 
                            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0);
                        }
                    }, Phaser.Mouse.prototype.constructor = Phaser.Mouse, Object.defineProperty(Phaser.Mouse.prototype, "disabled", {
                        get: function() {
                            return !this.enabled;
                        },
                        set: function(value) {
                            this.enabled = !value;
                        }
                    }), WheelEventProxy.prototype = {}, WheelEventProxy.prototype.constructor = WheelEventProxy, 
                    WheelEventProxy.prototype.bindEvent = function(event) {
                        if (!WheelEventProxy._stubsGenerated && event) {
                            var makeBinder = function(name) {
                                return function() {
                                    var v = this.originalEvent[name];
                                    return "function" != typeof v ? v : v.bind(this.originalEvent);
                                };
                            };
                            for (var prop in event) prop in WheelEventProxy.prototype || Object.defineProperty(WheelEventProxy.prototype, prop, {
                                get: makeBinder(prop)
                            });
                            WheelEventProxy._stubsGenerated = !0;
                        }
                        return this.originalEvent = event, this;
                    }, Object.defineProperties(WheelEventProxy.prototype, {
                        type: {
                            value: "wheel"
                        },
                        deltaMode: {
                            get: function() {
                                return this._deltaMode;
                            }
                        },
                        deltaY: {
                            get: function() {
                                return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0;
                            }
                        },
                        deltaX: {
                            get: function() {
                                return this._scaleFactor * this.originalEvent.wheelDeltaX || 0;
                            }
                        },
                        deltaZ: {
                            value: 0
                        }
                    }), Phaser.MSPointer = function(game) {
                        this.game = game, this.callbackContext = this.game, this.enabled = !0, this._onMSPointerDown = null, 
                        this._onMSPointerMove = null, this._onMSPointerUp = null;
                    }, Phaser.MSPointer.prototype = {
                        start: function() {
                            if (null === this._onMSPointerDown) {
                                var _this = this;
                                this.game.device.mspointer && (this._onMSPointerDown = function(event) {
                                    return _this.onPointerDown(event);
                                }, this._onMSPointerMove = function(event) {
                                    return _this.onPointerMove(event);
                                }, this._onMSPointerUp = function(event) {
                                    return _this.onPointerUp(event);
                                }, this.game.canvas.addEventListener("MSPointerDown", this._onMSPointerDown, !1), 
                                this.game.canvas.addEventListener("MSPointerMove", this._onMSPointerMove, !1), this.game.canvas.addEventListener("MSPointerUp", this._onMSPointerUp, !1), 
                                this.game.canvas.addEventListener("pointerDown", this._onMSPointerDown, !1), this.game.canvas.addEventListener("pointerMove", this._onMSPointerMove, !1), 
                                this.game.canvas.addEventListener("pointerUp", this._onMSPointerUp, !1), this.game.canvas.style["-ms-content-zooming"] = "none", 
                                this.game.canvas.style["-ms-touch-action"] = "none");
                            }
                        },
                        onPointerDown: function(event) {
                            this.game.input.enabled && this.enabled && (event.preventDefault(), event.identifier = event.pointerId, 
                            this.game.input.startPointer(event));
                        },
                        onPointerMove: function(event) {
                            this.game.input.enabled && this.enabled && (event.preventDefault(), event.identifier = event.pointerId, 
                            this.game.input.updatePointer(event));
                        },
                        onPointerUp: function(event) {
                            this.game.input.enabled && this.enabled && (event.preventDefault(), event.identifier = event.pointerId, 
                            this.game.input.stopPointer(event));
                        },
                        stop: function() {
                            this.game.canvas.removeEventListener("MSPointerDown", this._onMSPointerDown), this.game.canvas.removeEventListener("MSPointerMove", this._onMSPointerMove), 
                            this.game.canvas.removeEventListener("MSPointerUp", this._onMSPointerUp), this.game.canvas.removeEventListener("pointerDown", this._onMSPointerDown), 
                            this.game.canvas.removeEventListener("pointerMove", this._onMSPointerMove), this.game.canvas.removeEventListener("pointerUp", this._onMSPointerUp);
                        }
                    }, Phaser.MSPointer.prototype.constructor = Phaser.MSPointer, Object.defineProperty(Phaser.MSPointer.prototype, "disabled", {
                        get: function() {
                            return !this.enabled;
                        },
                        set: function(value) {
                            this.enabled = !value;
                        }
                    }), Phaser.Pointer = function(game, id) {
                        this.game = game, this.id = id, this.type = Phaser.POINTER, this.exists = !0, this.identifier = 0, 
                        this.pointerId = null, this.target = null, this.button = null, this._holdSent = !1, 
                        this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, 
                        this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, 
                        this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, 
                        this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = !1, this.isDown = !1, 
                        this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, 
                        this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.active = !1, 
                        this.dirty = !1, this.position = new Phaser.Point(), this.positionDown = new Phaser.Point(), 
                        this.positionUp = new Phaser.Point(), this.circle = new Phaser.Circle(0, 0, 44), 
                        0 === id && (this.isMouse = !0), this._clickTrampolines = null, this._trampolineTargetObject = null;
                    }, Phaser.Pointer.prototype = {
                        start: function(event) {
                            return event.pointerId && (this.pointerId = event.pointerId), this.identifier = event.identifier, 
                            this.target = event.target, "undefined" != typeof event.button && (this.button = event.button), 
                            this._history = [], this.active = !0, this.withinGame = !0, this.isDown = !0, this.isUp = !1, 
                            this.dirty = !1, this._clickTrampolines = null, this._trampolineTargetObject = null, 
                            this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, 
                            this._holdSent = !1, this.move(event, !0), this.positionDown.setTo(this.x, this.y), 
                            (this.game.input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) && (this.game.input.x = this.x, 
                            this.game.input.y = this.y, this.game.input.position.setTo(this.x, this.y), this.game.input.onDown.dispatch(this, event), 
                            this.game.input.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, 
                            this.isMouse || this.game.input.currentPointers++, null !== this.targetObject && this.targetObject._touchedHandler(this), 
                            this;
                        },
                        update: function() {
                            this.active && (this.dirty && (this.game.input.interactiveItems.total > 0 && this.processInteractiveObjects(!1), 
                            this.dirty = !1), this._holdSent === !1 && this.duration >= this.game.input.holdRate && ((this.game.input.multiInputOverride == Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride == Phaser.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) && this.game.input.onHold.dispatch(this), 
                            this._holdSent = !0), this.game.input.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + this.game.input.recordRate, 
                            this._history.push({
                                x: this.position.x,
                                y: this.position.y
                            }), this._history.length > this.game.input.recordLimit && this._history.shift()));
                        },
                        move: function(event, fromClick) {
                            if (!this.game.input.pollLocked) {
                                if ("undefined" == typeof fromClick && (fromClick = !1), "undefined" != typeof event.button && (this.button = event.button), 
                                this.clientX = event.clientX, this.clientY = event.clientY, this.pageX = event.pageX, 
                                this.pageY = event.pageY, this.screenX = event.screenX, this.screenY = event.screenY, 
                                this.isMouse && this.game.input.mouse.locked && !fromClick && (this.rawMovementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0, 
                                this.rawMovementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0, 
                                this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * this.game.input.scale.x, 
                                this.y = (this.pageY - this.game.scale.offset.y) * this.game.input.scale.y, this.position.setTo(this.x, this.y), 
                                this.circle.x = this.x, this.circle.y = this.y, (this.game.input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) && (this.game.input.activePointer = this, 
                                this.game.input.x = this.x, this.game.input.y = this.y, this.game.input.position.setTo(this.game.input.x, this.game.input.y), 
                                this.game.input.circle.x = this.game.input.x, this.game.input.circle.y = this.game.input.y), 
                                this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY), this.game.paused) return this;
                                for (var i = this.game.input.moveCallbacks.length; i--; ) this.game.input.moveCallbacks[i].callback.call(this.game.input.moveCallbacks[i].context, this, this.x, this.y, fromClick);
                                return null !== this.targetObject && this.targetObject.isDragged === !0 ? this.targetObject.update(this) === !1 && (this.targetObject = null) : this.game.input.interactiveItems.total > 0 && this.processInteractiveObjects(fromClick), 
                                this;
                            }
                        },
                        processInteractiveObjects: function(fromClick) {
                            for (var highestRenderOrderID = Number.MAX_VALUE, highestInputPriorityID = -1, candidateTarget = null, currentNode = this.game.input.interactiveItems.first; currentNode; ) currentNode.checked = !1, 
                            currentNode.validForInput(highestInputPriorityID, highestRenderOrderID, !1) && (currentNode.checked = !0, 
                            (fromClick && currentNode.checkPointerDown(this, !0) || !fromClick && currentNode.checkPointerOver(this, !0)) && (highestRenderOrderID = currentNode.sprite._cache[3], 
                            highestInputPriorityID = currentNode.priorityID, candidateTarget = currentNode)), 
                            currentNode = this.game.input.interactiveItems.next;
                            for (var currentNode = this.game.input.interactiveItems.first; currentNode; ) !currentNode.checked && currentNode.validForInput(highestInputPriorityID, highestRenderOrderID, !0) && (fromClick && currentNode.checkPointerDown(this, !1) || !fromClick && currentNode.checkPointerOver(this, !1)) && (highestRenderOrderID = currentNode.sprite._cache[3], 
                            highestInputPriorityID = currentNode.priorityID, candidateTarget = currentNode), 
                            currentNode = this.game.input.interactiveItems.next;
                            return null === candidateTarget ? this.targetObject && (this.targetObject._pointerOutHandler(this), 
                            this.targetObject = null) : null === this.targetObject ? (this.targetObject = candidateTarget, 
                            candidateTarget._pointerOverHandler(this)) : this.targetObject === candidateTarget ? candidateTarget.update(this) === !1 && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this), 
                            this.targetObject = candidateTarget, this.targetObject._pointerOverHandler(this)), 
                            null !== this.targetObject;
                        },
                        leave: function(event) {
                            this.withinGame = !1, this.move(event, !1);
                        },
                        stop: function(event) {
                            return this._stateReset ? void event.preventDefault() : (this.timeUp = this.game.time.time, 
                            (this.game.input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) && (this.game.input.onUp.dispatch(this, event), 
                            this.duration >= 0 && this.duration <= this.game.input.tapRate && (this.timeUp - this.previousTapTime < this.game.input.doubleTapRate ? this.game.input.onTap.dispatch(this, !0) : this.game.input.onTap.dispatch(this, !1), 
                            this.previousTapTime = this.timeUp)), this.id > 0 && (this.active = !1), this.withinGame = !1, 
                            this.isDown = !1, this.isUp = !0, this.pointerId = null, this.identifier = null, 
                            this.positionUp.setTo(this.x, this.y), this.isMouse === !1 && this.game.input.currentPointers--, 
                            this.game.input.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), 
                            this.targetObject = null, this);
                        },
                        justPressed: function(duration) {
                            return duration = duration || this.game.input.justPressedRate, this.isDown === !0 && this.timeDown + duration > this.game.time.time;
                        },
                        justReleased: function(duration) {
                            return duration = duration || this.game.input.justReleasedRate, this.isUp === !0 && this.timeUp + duration > this.game.time.time;
                        },
                        addClickTrampoline: function(name, callback, callbackContext, callbackArgs) {
                            if (this.isDown) {
                                for (var trampolines = this._clickTrampolines = this._clickTrampolines || [], i = 0; i < trampolines.length; i++) if (trampolines[i].name === name) {
                                    trampolines.splice(i, 1);
                                    break;
                                }
                                trampolines.push({
                                    name: name,
                                    targetObject: this.targetObject,
                                    callback: callback,
                                    callbackContext: callbackContext,
                                    callbackArgs: callbackArgs
                                });
                            }
                        },
                        processClickTrampolines: function() {
                            var trampolines = this._clickTrampolines;
                            if (trampolines) {
                                for (var i = 0; i < trampolines.length; i++) {
                                    var trampoline = trampolines[i];
                                    trampoline.targetObject === this._trampolineTargetObject && trampoline.callback.apply(trampoline.callbackContext, trampoline.callbackArgs);
                                }
                                this._clickTrampolines = null, this._trampolineTargetObject = null;
                            }
                        },
                        reset: function() {
                            this.isMouse === !1 && (this.active = !1), this.pointerId = null, this.identifier = null, 
                            this.dirty = !1, this.isDown = !1, this.isUp = !0, this.totalTouches = 0, this._holdSent = !1, 
                            this._history.length = 0, this._stateReset = !0, this.targetObject && this.targetObject._releasedHandler(this), 
                            this.targetObject = null;
                        },
                        resetMovement: function() {
                            this.movementX = 0, this.movementY = 0;
                        }
                    }, Phaser.Pointer.prototype.constructor = Phaser.Pointer, Object.defineProperty(Phaser.Pointer.prototype, "duration", {
                        get: function() {
                            return this.isUp ? -1 : this.game.time.time - this.timeDown;
                        }
                    }), Object.defineProperty(Phaser.Pointer.prototype, "worldX", {
                        get: function() {
                            return this.game.world.camera.x + this.x;
                        }
                    }), Object.defineProperty(Phaser.Pointer.prototype, "worldY", {
                        get: function() {
                            return this.game.world.camera.y + this.y;
                        }
                    }), Phaser.Touch = function(game) {
                        this.game = game, this.enabled = !0, this.callbackContext = this.game, this.touchStartCallback = null, 
                        this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, 
                        this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, 
                        this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, 
                        this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, 
                        this._onTouchMove = null;
                    }, Phaser.Touch.prototype = {
                        start: function() {
                            if (null === this._onTouchStart) {
                                var _this = this;
                                this.game.device.touch && (this._onTouchStart = function(event) {
                                    return _this.onTouchStart(event);
                                }, this._onTouchMove = function(event) {
                                    return _this.onTouchMove(event);
                                }, this._onTouchEnd = function(event) {
                                    return _this.onTouchEnd(event);
                                }, this._onTouchEnter = function(event) {
                                    return _this.onTouchEnter(event);
                                }, this._onTouchLeave = function(event) {
                                    return _this.onTouchLeave(event);
                                }, this._onTouchCancel = function(event) {
                                    return _this.onTouchCancel(event);
                                }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), 
                                this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), 
                                this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), 
                                this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)));
                            }
                        },
                        consumeDocumentTouches: function() {
                            this._documentTouchMove = function(event) {
                                event.preventDefault();
                            }, document.addEventListener("touchmove", this._documentTouchMove, !1);
                        },
                        onTouchStart: function(event) {
                            if (this.event = event, this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, event), 
                            this.game.input.enabled && this.enabled) {
                                this.preventDefault && event.preventDefault();
                                for (var i = 0; i < event.changedTouches.length; i++) this.game.input.startPointer(event.changedTouches[i]);
                            }
                        },
                        onTouchCancel: function(event) {
                            if (this.event = event, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, event), 
                            this.game.input.enabled && this.enabled) {
                                this.preventDefault && event.preventDefault();
                                for (var i = 0; i < event.changedTouches.length; i++) this.game.input.stopPointer(event.changedTouches[i]);
                            }
                        },
                        onTouchEnter: function(event) {
                            this.event = event, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, event), 
                            this.game.input.enabled && this.enabled && this.preventDefault && event.preventDefault();
                        },
                        onTouchLeave: function(event) {
                            this.event = event, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, event), 
                            this.preventDefault && event.preventDefault();
                        },
                        onTouchMove: function(event) {
                            this.event = event, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, event), 
                            this.preventDefault && event.preventDefault();
                            for (var i = 0; i < event.changedTouches.length; i++) this.game.input.updatePointer(event.changedTouches[i]);
                        },
                        onTouchEnd: function(event) {
                            this.event = event, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, event), 
                            this.preventDefault && event.preventDefault();
                            for (var i = 0; i < event.changedTouches.length; i++) this.game.input.stopPointer(event.changedTouches[i]);
                        },
                        stop: function() {
                            this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), 
                            this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), 
                            this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), 
                            this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel));
                        }
                    }, Phaser.Touch.prototype.constructor = Phaser.Touch, Object.defineProperty(Phaser.Touch.prototype, "disabled", {
                        get: function() {
                            return !this.enabled;
                        },
                        set: function(value) {
                            this.enabled = !value;
                        }
                    }), Phaser.Gamepad = function(game) {
                        this.game = game, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, 
                        this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 != navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, 
                        this._prevRawGamepadTypes = [], this._prevTimestamps = [], this.callbackContext = this, 
                        this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, 
                        this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, 
                        this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [ new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this) ];
                    }, Phaser.Gamepad.prototype = {
                        addCallbacks: function(context, callbacks) {
                            "undefined" != typeof callbacks && (this.onConnectCallback = "function" == typeof callbacks.onConnect ? callbacks.onConnect : this.onConnectCallback, 
                            this.onDisconnectCallback = "function" == typeof callbacks.onDisconnect ? callbacks.onDisconnect : this.onDisconnectCallback, 
                            this.onDownCallback = "function" == typeof callbacks.onDown ? callbacks.onDown : this.onDownCallback, 
                            this.onUpCallback = "function" == typeof callbacks.onUp ? callbacks.onUp : this.onUpCallback, 
                            this.onAxisCallback = "function" == typeof callbacks.onAxis ? callbacks.onAxis : this.onAxisCallback, 
                            this.onFloatCallback = "function" == typeof callbacks.onFloat ? callbacks.onFloat : this.onFloatCallback, 
                            this.callbackContext = context);
                        },
                        start: function() {
                            if (!this._active) {
                                this._active = !0;
                                var _this = this;
                                this._onGamepadConnected = function(event) {
                                    return _this.onGamepadConnected(event);
                                }, this._onGamepadDisconnected = function(event) {
                                    return _this.onGamepadDisconnected(event);
                                }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1);
                            }
                        },
                        onGamepadConnected: function(event) {
                            var newPad = event.gamepad;
                            this._rawPads.push(newPad), this._gamepads[newPad.index].connect(newPad);
                        },
                        onGamepadDisconnected: function(event) {
                            var removedPad = event.gamepad;
                            for (var i in this._rawPads) this._rawPads[i].index === removedPad.index && this._rawPads.splice(i, 1);
                            this._gamepads[removedPad.index].disconnect();
                        },
                        update: function() {
                            this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), 
                            this.pad4.pollStatus();
                        },
                        _pollGamepads: function() {
                            if (navigator.getGamepads) var rawGamepads = navigator.getGamepads(); else if (navigator.webkitGetGamepads) var rawGamepads = navigator.webkitGetGamepads(); else if (navigator.webkitGamepads) var rawGamepads = navigator.webkitGamepads();
                            if (rawGamepads) {
                                this._rawPads = [];
                                for (var gamepadsChanged = !1, i = 0; i < rawGamepads.length && (typeof rawGamepads[i] !== this._prevRawGamepadTypes[i] && (gamepadsChanged = !0, 
                                this._prevRawGamepadTypes[i] = typeof rawGamepads[i]), rawGamepads[i] && this._rawPads.push(rawGamepads[i]), 
                                3 !== i); i++) ;
                                if (gamepadsChanged) {
                                    for (var singlePad, validConnections = {
                                        rawIndices: {},
                                        padIndices: {}
                                    }, j = 0; j < this._gamepads.length; j++) if (singlePad = this._gamepads[j], singlePad.connected) for (var k = 0; k < this._rawPads.length; k++) this._rawPads[k].index === singlePad.index && (validConnections.rawIndices[singlePad.index] = !0, 
                                    validConnections.padIndices[j] = !0);
                                    for (var l = 0; l < this._gamepads.length; l++) if (singlePad = this._gamepads[l], 
                                    !validConnections.padIndices[l]) {
                                        this._rawPads.length < 1 && singlePad.disconnect();
                                        for (var m = 0; m < this._rawPads.length && !validConnections.padIndices[l]; m++) {
                                            var rawPad = this._rawPads[m];
                                            if (rawPad) {
                                                if (validConnections.rawIndices[rawPad.index]) {
                                                    singlePad.disconnect();
                                                    continue;
                                                }
                                                singlePad.connect(rawPad), validConnections.rawIndices[rawPad.index] = !0, validConnections.padIndices[l] = !0;
                                            } else singlePad.disconnect();
                                        }
                                    }
                                }
                            }
                        },
                        setDeadZones: function(value) {
                            for (var i = 0; i < this._gamepads.length; i++) this._gamepads[i].deadZone = value;
                        },
                        stop: function() {
                            this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), 
                            window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected);
                        },
                        reset: function() {
                            this.update();
                            for (var i = 0; i < this._gamepads.length; i++) this._gamepads[i].reset();
                        },
                        justPressed: function(buttonCode, duration) {
                            for (var i = 0; i < this._gamepads.length; i++) if (this._gamepads[i].justPressed(buttonCode, duration) === !0) return !0;
                            return !1;
                        },
                        justReleased: function(buttonCode, duration) {
                            for (var i = 0; i < this._gamepads.length; i++) if (this._gamepads[i].justReleased(buttonCode, duration) === !0) return !0;
                            return !1;
                        },
                        isDown: function(buttonCode) {
                            for (var i = 0; i < this._gamepads.length; i++) if (this._gamepads[i].isDown(buttonCode) === !0) return !0;
                            return !1;
                        },
                        destroy: function() {
                            this.stop();
                            for (var i = 0; i < this._gamepads.length; i++) this._gamepads[i].destroy();
                        }
                    }, Phaser.Gamepad.prototype.constructor = Phaser.Gamepad, Object.defineProperty(Phaser.Gamepad.prototype, "disabled", {
                        get: function() {
                            return !this.enabled;
                        },
                        set: function(value) {
                            this.enabled = !value;
                        }
                    }), Object.defineProperty(Phaser.Gamepad.prototype, "active", {
                        get: function() {
                            return this._active;
                        }
                    }), Object.defineProperty(Phaser.Gamepad.prototype, "supported", {
                        get: function() {
                            return this._gamepadSupportAvailable;
                        }
                    }), Object.defineProperty(Phaser.Gamepad.prototype, "padsConnected", {
                        get: function() {
                            return this._rawPads.length;
                        }
                    }), Object.defineProperty(Phaser.Gamepad.prototype, "pad1", {
                        get: function() {
                            return this._gamepads[0];
                        }
                    }), Object.defineProperty(Phaser.Gamepad.prototype, "pad2", {
                        get: function() {
                            return this._gamepads[1];
                        }
                    }), Object.defineProperty(Phaser.Gamepad.prototype, "pad3", {
                        get: function() {
                            return this._gamepads[2];
                        }
                    }), Object.defineProperty(Phaser.Gamepad.prototype, "pad4", {
                        get: function() {
                            return this._gamepads[3];
                        }
                    }), Phaser.Gamepad.BUTTON_0 = 0, Phaser.Gamepad.BUTTON_1 = 1, Phaser.Gamepad.BUTTON_2 = 2, 
                    Phaser.Gamepad.BUTTON_3 = 3, Phaser.Gamepad.BUTTON_4 = 4, Phaser.Gamepad.BUTTON_5 = 5, 
                    Phaser.Gamepad.BUTTON_6 = 6, Phaser.Gamepad.BUTTON_7 = 7, Phaser.Gamepad.BUTTON_8 = 8, 
                    Phaser.Gamepad.BUTTON_9 = 9, Phaser.Gamepad.BUTTON_10 = 10, Phaser.Gamepad.BUTTON_11 = 11, 
                    Phaser.Gamepad.BUTTON_12 = 12, Phaser.Gamepad.BUTTON_13 = 13, Phaser.Gamepad.BUTTON_14 = 14, 
                    Phaser.Gamepad.BUTTON_15 = 15, Phaser.Gamepad.AXIS_0 = 0, Phaser.Gamepad.AXIS_1 = 1, 
                    Phaser.Gamepad.AXIS_2 = 2, Phaser.Gamepad.AXIS_3 = 3, Phaser.Gamepad.AXIS_4 = 4, 
                    Phaser.Gamepad.AXIS_5 = 5, Phaser.Gamepad.AXIS_6 = 6, Phaser.Gamepad.AXIS_7 = 7, 
                    Phaser.Gamepad.AXIS_8 = 8, Phaser.Gamepad.AXIS_9 = 9, Phaser.Gamepad.XBOX360_A = 0, 
                    Phaser.Gamepad.XBOX360_B = 1, Phaser.Gamepad.XBOX360_X = 2, Phaser.Gamepad.XBOX360_Y = 3, 
                    Phaser.Gamepad.XBOX360_LEFT_BUMPER = 4, Phaser.Gamepad.XBOX360_RIGHT_BUMPER = 5, 
                    Phaser.Gamepad.XBOX360_LEFT_TRIGGER = 6, Phaser.Gamepad.XBOX360_RIGHT_TRIGGER = 7, 
                    Phaser.Gamepad.XBOX360_BACK = 8, Phaser.Gamepad.XBOX360_START = 9, Phaser.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, 
                    Phaser.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, Phaser.Gamepad.XBOX360_DPAD_LEFT = 14, 
                    Phaser.Gamepad.XBOX360_DPAD_RIGHT = 15, Phaser.Gamepad.XBOX360_DPAD_UP = 12, Phaser.Gamepad.XBOX360_DPAD_DOWN = 13, 
                    Phaser.Gamepad.XBOX360_STICK_LEFT_X = 0, Phaser.Gamepad.XBOX360_STICK_LEFT_Y = 1, 
                    Phaser.Gamepad.XBOX360_STICK_RIGHT_X = 2, Phaser.Gamepad.XBOX360_STICK_RIGHT_Y = 3, 
                    Phaser.Gamepad.PS3XC_X = 0, Phaser.Gamepad.PS3XC_CIRCLE = 1, Phaser.Gamepad.PS3XC_SQUARE = 2, 
                    Phaser.Gamepad.PS3XC_TRIANGLE = 3, Phaser.Gamepad.PS3XC_L1 = 4, Phaser.Gamepad.PS3XC_R1 = 5, 
                    Phaser.Gamepad.PS3XC_L2 = 6, Phaser.Gamepad.PS3XC_R2 = 7, Phaser.Gamepad.PS3XC_SELECT = 8, 
                    Phaser.Gamepad.PS3XC_START = 9, Phaser.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, Phaser.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, 
                    Phaser.Gamepad.PS3XC_DPAD_UP = 12, Phaser.Gamepad.PS3XC_DPAD_DOWN = 13, Phaser.Gamepad.PS3XC_DPAD_LEFT = 14, 
                    Phaser.Gamepad.PS3XC_DPAD_RIGHT = 15, Phaser.Gamepad.PS3XC_STICK_LEFT_X = 0, Phaser.Gamepad.PS3XC_STICK_LEFT_Y = 1, 
                    Phaser.Gamepad.PS3XC_STICK_RIGHT_X = 2, Phaser.Gamepad.PS3XC_STICK_RIGHT_Y = 3, 
                    Phaser.SinglePad = function(game, padParent) {
                        this.game = game, this.index = null, this.connected = !1, this.callbackContext = this, 
                        this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, 
                        this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, 
                        this.deadZone = .26, this._padParent = padParent, this._rawPad = null, this._prevTimestamp = null, 
                        this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0;
                    }, Phaser.SinglePad.prototype = {
                        addCallbacks: function(context, callbacks) {
                            "undefined" != typeof callbacks && (this.onConnectCallback = "function" == typeof callbacks.onConnect ? callbacks.onConnect : this.onConnectCallback, 
                            this.onDisconnectCallback = "function" == typeof callbacks.onDisconnect ? callbacks.onDisconnect : this.onDisconnectCallback, 
                            this.onDownCallback = "function" == typeof callbacks.onDown ? callbacks.onDown : this.onDownCallback, 
                            this.onUpCallback = "function" == typeof callbacks.onUp ? callbacks.onUp : this.onUpCallback, 
                            this.onAxisCallback = "function" == typeof callbacks.onAxis ? callbacks.onAxis : this.onAxisCallback, 
                            this.onFloatCallback = "function" == typeof callbacks.onFloat ? callbacks.onFloat : this.onFloatCallback);
                        },
                        getButton: function(buttonCode) {
                            return this._buttons[buttonCode] ? this._buttons[buttonCode] : null;
                        },
                        pollStatus: function() {
                            if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                                for (var i = 0; i < this._buttonsLen; i++) {
                                    var rawButtonVal = isNaN(this._rawPad.buttons[i]) ? this._rawPad.buttons[i].value : this._rawPad.buttons[i];
                                    rawButtonVal !== this._buttons[i].value && (1 === rawButtonVal ? this.processButtonDown(i, rawButtonVal) : 0 === rawButtonVal ? this.processButtonUp(i, rawButtonVal) : this.processButtonFloat(i, rawButtonVal));
                                }
                                for (var index = 0; index < this._axesLen; index++) {
                                    var value = this._rawPad.axes[index];
                                    value > 0 && value > this.deadZone || 0 > value && value < -this.deadZone ? this.processAxisChange(index, value) : this.processAxisChange(index, 0);
                                }
                                this._prevTimestamp = this._rawPad.timestamp;
                            }
                        },
                        connect: function(rawPad) {
                            var triggerCallback = !this.connected;
                            this.connected = !0, this.index = rawPad.index, this._rawPad = rawPad, this._buttons = [], 
                            this._buttonsLen = rawPad.buttons.length, this._axes = [], this._axesLen = rawPad.axes.length;
                            for (var a = 0; a < this._axesLen; a++) this._axes[a] = rawPad.axes[a];
                            for (var buttonCode in rawPad.buttons) buttonCode = parseInt(buttonCode, 10), this._buttons[buttonCode] = new Phaser.GamepadButton(this, buttonCode);
                            triggerCallback && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), 
                            triggerCallback && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext);
                        },
                        disconnect: function() {
                            var triggerCallback = this.connected, disconnectingIndex = this.index;
                            this.connected = !1, this.index = null, this._rawPad = void 0;
                            for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
                            this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, triggerCallback && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, disconnectingIndex), 
                            triggerCallback && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext);
                        },
                        destroy: function() {
                            this._rawPad = void 0;
                            for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
                            this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, 
                            this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, 
                            this.onAxisCallback = null, this.onFloatCallback = null;
                        },
                        processAxisChange: function(index, value) {
                            this._axes[index] !== value && (this._axes[index] = value, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, index, value), 
                            this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, index, value));
                        },
                        processButtonDown: function(buttonCode, value) {
                            this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, buttonCode, value, this.index), 
                            this.onDownCallback && this.onDownCallback.call(this.callbackContext, buttonCode, value), 
                            this._buttons[buttonCode] && this._buttons[buttonCode].processButtonDown(value);
                        },
                        processButtonUp: function(buttonCode, value) {
                            this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, buttonCode, value, this.index), 
                            this.onUpCallback && this.onUpCallback.call(this.callbackContext, buttonCode, value), 
                            this._buttons[buttonCode] && this._buttons[buttonCode].processButtonUp(value);
                        },
                        processButtonFloat: function(buttonCode, value) {
                            this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, buttonCode, value, this.index), 
                            this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, buttonCode, value), 
                            this._buttons[buttonCode] && this._buttons[buttonCode].processButtonFloat(value);
                        },
                        axis: function(axisCode) {
                            return this._axes[axisCode] ? this._axes[axisCode] : !1;
                        },
                        isDown: function(buttonCode) {
                            return this._buttons[buttonCode] ? this._buttons[buttonCode].isDown : !1;
                        },
                        isUp: function(buttonCode) {
                            return this._buttons[buttonCode] ? this._buttons[buttonCode].isUp : !1;
                        },
                        justReleased: function(buttonCode, duration) {
                            return this._buttons[buttonCode] ? this._buttons[buttonCode].justReleased(duration) : void 0;
                        },
                        justPressed: function(buttonCode, duration) {
                            return this._buttons[buttonCode] ? this._buttons[buttonCode].justPressed(duration) : void 0;
                        },
                        buttonValue: function(buttonCode) {
                            return this._buttons[buttonCode] ? this._buttons[buttonCode].value : null;
                        },
                        reset: function() {
                            for (var j = 0; j < this._axes.length; j++) this._axes[j] = 0;
                        }
                    }, Phaser.SinglePad.prototype.constructor = Phaser.SinglePad, Phaser.GamepadButton = function(pad, buttonCode) {
                        this.pad = pad, this.game = pad.game, this.isDown = !1, this.isUp = !0, this.timeDown = 0, 
                        this.duration = 0, this.timeUp = 0, this.repeats = 0, this.value = 0, this.buttonCode = buttonCode, 
                        this.onDown = new Phaser.Signal(), this.onUp = new Phaser.Signal(), this.onFloat = new Phaser.Signal();
                    }, Phaser.GamepadButton.prototype = {
                        processButtonDown: function(value) {
                            this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, 
                            this.repeats = 0, this.value = value, this.onDown.dispatch(this, value);
                        },
                        processButtonUp: function(value) {
                            this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.value = value, 
                            this.onUp.dispatch(this, value);
                        },
                        processButtonFloat: function(value) {
                            this.value = value, this.onFloat.dispatch(this, value);
                        },
                        justPressed: function(duration) {
                            return duration = duration || 250, this.isDown === !0 && this.timeDown + duration > this.game.time.time;
                        },
                        justReleased: function(duration) {
                            return duration = duration || 250, this.isUp === !0 && this.timeUp + duration > this.game.time.time;
                        },
                        reset: function() {
                            this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.duration = 0, 
                            this.repeats = 0;
                        },
                        destroy: function() {
                            this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.pad = null, 
                            this.game = null;
                        }
                    }, Phaser.GamepadButton.prototype.constructor = Phaser.GamepadButton, Phaser.InputHandler = function(sprite) {
                        this.sprite = sprite, this.game = sprite.game, this.enabled = !1, this.checked = !1, 
                        this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, 
                        this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, 
                        this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, 
                        this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, 
                        this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, 
                        this.boundsRect = null, this.boundsSprite = null, this.consumePointerEvent = !1, 
                        this.scaleLayer = !1, this._dragPhase = !1, this._wasEnabled = !1, this._tempPoint = new Phaser.Point(), 
                        this._pointerData = [], this._pointerData.push({
                            id: 0,
                            x: 0,
                            y: 0,
                            isDown: !1,
                            isUp: !1,
                            isOver: !1,
                            isOut: !1,
                            timeOver: 0,
                            timeOut: 0,
                            timeDown: 0,
                            timeUp: 0,
                            downDuration: 0,
                            isDragged: !1
                        });
                    }, Phaser.InputHandler.prototype = {
                        start: function(priority, useHandCursor) {
                            if (priority = priority || 0, "undefined" == typeof useHandCursor && (useHandCursor = !1), 
                            this.enabled === !1) {
                                this.game.input.interactiveItems.add(this), this.useHandCursor = useHandCursor, 
                                this.priorityID = priority;
                                for (var i = 0; 10 > i; i++) this._pointerData[i] = {
                                    id: i,
                                    x: 0,
                                    y: 0,
                                    isDown: !1,
                                    isUp: !1,
                                    isOver: !1,
                                    isOut: !1,
                                    timeOver: 0,
                                    timeOut: 0,
                                    timeDown: 0,
                                    timeUp: 0,
                                    downDuration: 0,
                                    isDragged: !1
                                };
                                this.snapOffset = new Phaser.Point(), this.enabled = !0, this._wasEnabled = !0;
                            }
                            return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), 
                            this.flagged = !1, this.sprite;
                        },
                        addedToGroup: function() {
                            this._dragPhase || this._wasEnabled && !this.enabled && this.start();
                        },
                        removedFromGroup: function() {
                            this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1);
                        },
                        reset: function() {
                            this.enabled = !1, this.flagged = !1;
                            for (var i = 0; 10 > i; i++) this._pointerData[i] = {
                                id: i,
                                x: 0,
                                y: 0,
                                isDown: !1,
                                isUp: !1,
                                isOver: !1,
                                isOut: !1,
                                timeOver: 0,
                                timeOut: 0,
                                timeDown: 0,
                                timeUp: 0,
                                downDuration: 0,
                                isDragged: !1
                            };
                        },
                        stop: function() {
                            this.enabled !== !1 && (this.enabled = !1, this.game.input.interactiveItems.remove(this));
                        },
                        destroy: function() {
                            this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", 
                            this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), 
                            this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, 
                            this.sprite = null);
                        },
                        validForInput: function(highestID, highestRenderID, includePixelPerfect) {
                            return "undefined" == typeof includePixelPerfect && (includePixelPerfect = !0), 
                            0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID ? !1 : (includePixelPerfect || !this.pixelPerfectClick && !this.pixelPerfectOver) && (this.priorityID > highestID || this.priorityID === highestID && this.sprite._cache[3] < highestRenderID) ? !0 : !1;
                        },
                        isPixelPerfect: function() {
                            return this.pixelPerfectClick || this.pixelPerfectOver;
                        },
                        pointerX: function(pointer) {
                            return pointer = pointer || 0, this._pointerData[pointer].x;
                        },
                        pointerY: function(pointer) {
                            return pointer = pointer || 0, this._pointerData[pointer].y;
                        },
                        pointerDown: function(pointer) {
                            return pointer = pointer || 0, this._pointerData[pointer].isDown;
                        },
                        pointerUp: function(pointer) {
                            return pointer = pointer || 0, this._pointerData[pointer].isUp;
                        },
                        pointerTimeDown: function(pointer) {
                            return pointer = pointer || 0, this._pointerData[pointer].timeDown;
                        },
                        pointerTimeUp: function(pointer) {
                            return pointer = pointer || 0, this._pointerData[pointer].timeUp;
                        },
                        pointerOver: function(index) {
                            if (this.enabled) {
                                if ("undefined" != typeof index) return this._pointerData[index].isOver;
                                for (var i = 0; 10 > i; i++) if (this._pointerData[i].isOver) return !0;
                            }
                            return !1;
                        },
                        pointerOut: function(index) {
                            if (this.enabled) {
                                if ("undefined" != typeof index) return this._pointerData[index].isOut;
                                for (var i = 0; 10 > i; i++) if (this._pointerData[i].isOut) return !0;
                            }
                            return !1;
                        },
                        pointerTimeOver: function(pointer) {
                            return pointer = pointer || 0, this._pointerData[pointer].timeOver;
                        },
                        pointerTimeOut: function(pointer) {
                            return pointer = pointer || 0, this._pointerData[pointer].timeOut;
                        },
                        pointerDragged: function(pointer) {
                            return pointer = pointer || 0, this._pointerData[pointer].isDragged;
                        },
                        checkPointerDown: function(pointer, fastTest) {
                            return pointer.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && this.game.input.hitTest(this.sprite, pointer, this._tempPoint) ? ("undefined" == typeof fastTest && (fastTest = !1), 
                            !fastTest && this.pixelPerfectClick ? this.checkPixel(this._tempPoint.x, this._tempPoint.y) : !0) : !1;
                        },
                        checkPointerOver: function(pointer, fastTest) {
                            return this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && this.game.input.hitTest(this.sprite, pointer, this._tempPoint) ? ("undefined" == typeof fastTest && (fastTest = !1), 
                            !fastTest && this.pixelPerfectOver ? this.checkPixel(this._tempPoint.x, this._tempPoint.y) : !0) : !1;
                        },
                        checkPixel: function(x, y, pointer) {
                            if (this.sprite.texture.baseTexture.source) {
                                if (null === x && null === y) {
                                    this.game.input.getLocalPosition(this.sprite, pointer, this._tempPoint);
                                    var x = this._tempPoint.x, y = this._tempPoint.y;
                                }
                                if (0 !== this.sprite.anchor.x && (x -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 
                                0 !== this.sprite.anchor.y && (y -= -this.sprite.texture.frame.height * this.sprite.anchor.y), 
                                x += this.sprite.texture.frame.x, y += this.sprite.texture.frame.y, this.sprite.texture.trim && (x -= this.sprite.texture.trim.x, 
                                y -= this.sprite.texture.trim.y, x < this.sprite.texture.crop.x || x > this.sprite.texture.crop.right || y < this.sprite.texture.crop.y || y > this.sprite.texture.crop.bottom)) return this._dx = x, 
                                this._dy = y, !1;
                                this._dx = x, this._dy = y, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, x, y, 1, 1, 0, 0, 1, 1);
                                var rgb = this.game.input.hitContext.getImageData(0, 0, 1, 1);
                                if (rgb.data[3] >= this.pixelPerfectAlpha) return !0;
                            }
                            return !1;
                        },
                        update: function(pointer) {
                            return null !== this.sprite && void 0 !== this.sprite.parent ? this.enabled && this.sprite.visible && this.sprite.parent.visible ? this.draggable && this._draggedPointerID === pointer.id ? this.updateDrag(pointer) : this._pointerData[pointer.id].isOver ? this.checkPointerOver(pointer) ? (this._pointerData[pointer.id].x = pointer.x - this.sprite.x, 
                            this._pointerData[pointer.id].y = pointer.y - this.sprite.y, !0) : (this._pointerOutHandler(pointer), 
                            !1) : void 0 : (this._pointerOutHandler(pointer), !1) : void 0;
                        },
                        _pointerOverHandler: function(pointer) {
                            null !== this.sprite && (this._pointerData[pointer.id].isOver === !1 || pointer.dirty) && (this._pointerData[pointer.id].isOver = !0, 
                            this._pointerData[pointer.id].isOut = !1, this._pointerData[pointer.id].timeOver = this.game.time.time, 
                            this._pointerData[pointer.id].x = pointer.x - this.sprite.x, this._pointerData[pointer.id].y = pointer.y - this.sprite.y, 
                            this.useHandCursor && this._pointerData[pointer.id].isDragged === !1 && (this.game.canvas.style.cursor = "pointer", 
                            this._setHandCursor = !0), this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, pointer));
                        },
                        _pointerOutHandler: function(pointer) {
                            null !== this.sprite && (this._pointerData[pointer.id].isOver = !1, this._pointerData[pointer.id].isOut = !0, 
                            this._pointerData[pointer.id].timeOut = this.game.time.time, this.useHandCursor && this._pointerData[pointer.id].isDragged === !1 && (this.game.canvas.style.cursor = "default", 
                            this._setHandCursor = !1), this.sprite && this.sprite.events && this.sprite.events.onInputOut$dispatch(this.sprite, pointer));
                        },
                        _touchedHandler: function(pointer) {
                            if (null !== this.sprite) {
                                if (this._pointerData[pointer.id].isDown === !1 && this._pointerData[pointer.id].isOver === !0) {
                                    if (this.pixelPerfectClick && !this.checkPixel(null, null, pointer)) return;
                                    this._pointerData[pointer.id].isDown = !0, this._pointerData[pointer.id].isUp = !1, 
                                    this._pointerData[pointer.id].timeDown = this.game.time.time, this.sprite && this.sprite.events && this.sprite.events.onInputDown$dispatch(this.sprite, pointer), 
                                    pointer.dirty = !0, this.draggable && this.isDragged === !1 && this.startDrag(pointer), 
                                    this.bringToTop && this.sprite.bringToTop();
                                }
                                return this.consumePointerEvent;
                            }
                        },
                        _releasedHandler: function(pointer) {
                            null !== this.sprite && this._pointerData[pointer.id].isDown && pointer.isUp && (this._pointerData[pointer.id].isDown = !1, 
                            this._pointerData[pointer.id].isUp = !0, this._pointerData[pointer.id].timeUp = this.game.time.time, 
                            this._pointerData[pointer.id].downDuration = this._pointerData[pointer.id].timeUp - this._pointerData[pointer.id].timeDown, 
                            this.checkPointerOver(pointer) ? this.sprite && this.sprite.events && this.sprite.events.onInputUp$dispatch(this.sprite, pointer, !0) : (this.sprite && this.sprite.events && this.sprite.events.onInputUp$dispatch(this.sprite, pointer, !1), 
                            this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1)), 
                            pointer.dirty = !0, this.draggable && this.isDragged && this._draggedPointerID === pointer.id && this.stopDrag(pointer));
                        },
                        updateDrag: function(pointer) {
                            if (pointer.isUp) return this.stopDrag(pointer), !1;
                            var px = this.globalToLocalX(pointer.x) + this._dragPoint.x + this.dragOffset.x, py = this.globalToLocalY(pointer.y) + this._dragPoint.y + this.dragOffset.y;
                            return this.sprite.fixedToCamera ? (this.allowHorizontalDrag && (this.sprite.cameraOffset.x = px), 
                            this.allowVerticalDrag && (this.sprite.cameraOffset.y = py), this.boundsRect && this.checkBoundsRect(), 
                            this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, 
                            this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)) : (this.allowHorizontalDrag && (this.sprite.x = px), 
                            this.allowVerticalDrag && (this.sprite.y = py), this.boundsRect && this.checkBoundsRect(), 
                            this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, 
                            this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), 
                            !0;
                        },
                        justOver: function(pointer, delay) {
                            return pointer = pointer || 0, delay = delay || 500, this._pointerData[pointer].isOver && this.overDuration(pointer) < delay;
                        },
                        justOut: function(pointer, delay) {
                            return pointer = pointer || 0, delay = delay || 500, this._pointerData[pointer].isOut && this.game.time.time - this._pointerData[pointer].timeOut < delay;
                        },
                        justPressed: function(pointer, delay) {
                            return pointer = pointer || 0, delay = delay || 500, this._pointerData[pointer].isDown && this.downDuration(pointer) < delay;
                        },
                        justReleased: function(pointer, delay) {
                            return pointer = pointer || 0, delay = delay || 500, this._pointerData[pointer].isUp && this.game.time.time - this._pointerData[pointer].timeUp < delay;
                        },
                        overDuration: function(pointer) {
                            return pointer = pointer || 0, this._pointerData[pointer].isOver ? this.game.time.time - this._pointerData[pointer].timeOver : -1;
                        },
                        downDuration: function(pointer) {
                            return pointer = pointer || 0, this._pointerData[pointer].isDown ? this.game.time.time - this._pointerData[pointer].timeDown : -1;
                        },
                        enableDrag: function(lockCenter, bringToTop, pixelPerfect, alphaThreshold, boundsRect, boundsSprite) {
                            "undefined" == typeof lockCenter && (lockCenter = !1), "undefined" == typeof bringToTop && (bringToTop = !1), 
                            "undefined" == typeof pixelPerfect && (pixelPerfect = !1), "undefined" == typeof alphaThreshold && (alphaThreshold = 255), 
                            "undefined" == typeof boundsRect && (boundsRect = null), "undefined" == typeof boundsSprite && (boundsSprite = null), 
                            this._dragPoint = new Phaser.Point(), this.draggable = !0, this.bringToTop = bringToTop, 
                            this.dragOffset = new Phaser.Point(), this.dragFromCenter = lockCenter, this.pixelPerfectClick = pixelPerfect, 
                            this.pixelPerfectAlpha = alphaThreshold, boundsRect && (this.boundsRect = boundsRect), 
                            boundsSprite && (this.boundsSprite = boundsSprite);
                        },
                        disableDrag: function() {
                            if (this._pointerData) for (var i = 0; 10 > i; i++) this._pointerData[i].isDragged = !1;
                            this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1;
                        },
                        startDrag: function(pointer) {
                            if (this.isDragged = !0, this._draggedPointerID = pointer.id, this._pointerData[pointer.id].isDragged = !0, 
                            this.sprite.fixedToCamera) this.dragFromCenter ? (this.sprite.centerOn(pointer.x, pointer.y), 
                            this._dragPoint.setTo(this.sprite.cameraOffset.x - pointer.x, this.sprite.cameraOffset.y - pointer.y)) : this._dragPoint.setTo(this.sprite.cameraOffset.x - pointer.x, this.sprite.cameraOffset.y - pointer.y); else {
                                if (this.dragFromCenter) {
                                    var bounds = this.sprite.getBounds();
                                    this.sprite.x = this.globalToLocalX(pointer.x) + (this.sprite.x - bounds.centerX), 
                                    this.sprite.y = this.globalToLocalY(pointer.y) + (this.sprite.y - bounds.centerY);
                                }
                                this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(pointer.x), this.sprite.y - this.globalToLocalY(pointer.y));
                            }
                            this.updateDrag(pointer), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), 
                            this.sprite.events.onDragStart$dispatch(this.sprite, pointer);
                        },
                        globalToLocalX: function(x) {
                            return this.scaleLayer && (x -= this.game.scale.grid.boundsFluid.x, x *= this.game.scale.grid.scaleFluidInversed.x), 
                            x;
                        },
                        globalToLocalY: function(y) {
                            return this.scaleLayer && (y -= this.game.scale.grid.boundsFluid.y, y *= this.game.scale.grid.scaleFluidInversed.y), 
                            y;
                        },
                        stopDrag: function(pointer) {
                            this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[pointer.id].isDragged = !1, 
                            this._dragPhase = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, 
                            this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, 
                            this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), 
                            this.sprite.events.onDragStop$dispatch(this.sprite, pointer), this.checkPointerOver(pointer) === !1 && this._pointerOutHandler(pointer);
                        },
                        setDragLock: function(allowHorizontal, allowVertical) {
                            "undefined" == typeof allowHorizontal && (allowHorizontal = !0), "undefined" == typeof allowVertical && (allowVertical = !0), 
                            this.allowHorizontalDrag = allowHorizontal, this.allowVerticalDrag = allowVertical;
                        },
                        enableSnap: function(snapX, snapY, onDrag, onRelease, snapOffsetX, snapOffsetY) {
                            "undefined" == typeof onDrag && (onDrag = !0), "undefined" == typeof onRelease && (onRelease = !1), 
                            "undefined" == typeof snapOffsetX && (snapOffsetX = 0), "undefined" == typeof snapOffsetY && (snapOffsetY = 0), 
                            this.snapX = snapX, this.snapY = snapY, this.snapOffsetX = snapOffsetX, this.snapOffsetY = snapOffsetY, 
                            this.snapOnDrag = onDrag, this.snapOnRelease = onRelease;
                        },
                        disableSnap: function() {
                            this.snapOnDrag = !1, this.snapOnRelease = !1;
                        },
                        checkBoundsRect: function() {
                            this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), 
                            this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.x < this.boundsRect.left ? this.sprite.x = this.boundsRect.x : this.sprite.x + this.sprite.width > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - this.sprite.width), 
                            this.sprite.y < this.boundsRect.top ? this.sprite.y = this.boundsRect.top : this.sprite.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - this.sprite.height));
                        },
                        checkBoundsSprite: function() {
                            this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.camerOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.camerOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.camerOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.camerOffset.x + this.boundsSprite.width - this.sprite.width), 
                            this.sprite.cameraOffset.y < this.boundsSprite.camerOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.camerOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.camerOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.camerOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.x < this.boundsSprite.x ? this.sprite.x = this.boundsSprite.x : this.sprite.x + this.sprite.width > this.boundsSprite.x + this.boundsSprite.width && (this.sprite.x = this.boundsSprite.x + this.boundsSprite.width - this.sprite.width), 
                            this.sprite.y < this.boundsSprite.y ? this.sprite.y = this.boundsSprite.y : this.sprite.y + this.sprite.height > this.boundsSprite.y + this.boundsSprite.height && (this.sprite.y = this.boundsSprite.y + this.boundsSprite.height - this.sprite.height));
                        }
                    }, Phaser.InputHandler.prototype.constructor = Phaser.InputHandler, Phaser.Events = function(sprite) {
                        this.parent = sprite;
                    }, Phaser.Events.prototype = {
                        destroy: function() {
                            this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), 
                            this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), 
                            this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), 
                            this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), 
                            this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), 
                            this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), 
                            this._onDragStart && this._onDragStart.dispose(), this._onDragStop && this._onDragStop.dispose(), 
                            this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), 
                            this._onAnimationLoop && this._onAnimationLoop.dispose();
                        },
                        onAddedToGroup: null,
                        onRemovedFromGroup: null,
                        onRemovedFromWorld: null,
                        onDestroy: null,
                        onKilled: null,
                        onRevived: null,
                        onOutOfBounds: null,
                        onEnterBounds: null,
                        onInputOver: null,
                        onInputOut: null,
                        onInputDown: null,
                        onInputUp: null,
                        onDragStart: null,
                        onDragStop: null,
                        onAnimationStart: null,
                        onAnimationComplete: null,
                        onAnimationLoop: null
                    }, Phaser.Events.prototype.constructor = Phaser.Events;
                    for (var prop in Phaser.Events.prototype) Phaser.Events.prototype.hasOwnProperty(prop) && 0 === prop.indexOf("on") && null === Phaser.Events.prototype[prop] && !function(prop, backing) {
                        "use strict";
                        Object.defineProperty(Phaser.Events.prototype, prop, {
                            get: function() {
                                return this[backing] || (this[backing] = new Phaser.Signal());
                            }
                        }), Phaser.Events.prototype[prop + "$dispatch"] = function() {
                            return this[backing] ? this[backing].dispatch.apply(this[backing], arguments) : null;
                        };
                    }(prop, "_" + prop);
                    Phaser.GameObjectFactory = function(game) {
                        this.game = game, this.world = this.game.world;
                    }, Phaser.GameObjectFactory.prototype = {
                        existing: function(object) {
                            return this.world.add(object);
                        },
                        image: function(x, y, key, frame, group) {
                            return "undefined" == typeof group && (group = this.world), group.add(new Phaser.Image(this.game, x, y, key, frame));
                        },
                        sprite: function(x, y, key, frame, group) {
                            return "undefined" == typeof group && (group = this.world), group.create(x, y, key, frame);
                        },
                        tween: function(obj) {
                            return this.game.tweens.create(obj);
                        },
                        group: function(parent, name, addToStage, enableBody, physicsBodyType) {
                            return new Phaser.Group(this.game, parent, name, addToStage, enableBody, physicsBodyType);
                        },
                        physicsGroup: function(physicsBodyType, parent, name, addToStage) {
                            return new Phaser.Group(this.game, parent, name, addToStage, !0, physicsBodyType);
                        },
                        spriteBatch: function(parent, name, addToStage) {
                            return "undefined" == typeof parent && (parent = null), "undefined" == typeof name && (name = "group"), 
                            "undefined" == typeof addToStage && (addToStage = !1), new Phaser.SpriteBatch(this.game, parent, name, addToStage);
                        },
                        audio: function(key, volume, loop, connect) {
                            return this.game.sound.add(key, volume, loop, connect);
                        },
                        sound: function(key, volume, loop, connect) {
                            return this.game.sound.add(key, volume, loop, connect);
                        },
                        audioSprite: function(key) {
                            return this.game.sound.addSprite(key);
                        },
                        tileSprite: function(x, y, width, height, key, frame, group) {
                            return "undefined" == typeof group && (group = this.world), group.add(new Phaser.TileSprite(this.game, x, y, width, height, key, frame));
                        },
                        rope: function(x, y, key, frame, points, group) {
                            return "undefined" == typeof group && (group = this.world), group.add(new Phaser.Rope(this.game, x, y, key, frame, points));
                        },
                        text: function(x, y, text, style, group) {
                            return "undefined" == typeof group && (group = this.world), group.add(new Phaser.Text(this.game, x, y, text, style));
                        },
                        button: function(x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame, group) {
                            return "undefined" == typeof group && (group = this.world), group.add(new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame));
                        },
                        graphics: function(x, y, group) {
                            return "undefined" == typeof group && (group = this.world), group.add(new Phaser.Graphics(this.game, x, y));
                        },
                        emitter: function(x, y, maxParticles) {
                            return this.game.particles.add(new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles));
                        },
                        retroFont: function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
                            return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
                        },
                        bitmapText: function(x, y, font, text, size, group) {
                            return "undefined" == typeof group && (group = this.world), group.add(new Phaser.BitmapText(this.game, x, y, font, text, size));
                        },
                        tilemap: function(key, tileWidth, tileHeight, width, height) {
                            return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height);
                        },
                        renderTexture: function(width, height, key, addToCache) {
                            ("undefined" == typeof key || "" === key) && (key = this.game.rnd.uuid()), "undefined" == typeof addToCache && (addToCache = !1);
                            var texture = new Phaser.RenderTexture(this.game, width, height, key);
                            return addToCache && this.game.cache.addRenderTexture(key, texture), texture;
                        },
                        bitmapData: function(width, height, key, addToCache) {
                            "undefined" == typeof addToCache && (addToCache = !1), ("undefined" == typeof key || "" === key) && (key = this.game.rnd.uuid());
                            var texture = new Phaser.BitmapData(this.game, key, width, height);
                            return addToCache && this.game.cache.addBitmapData(key, texture), texture;
                        },
                        filter: function(filter) {
                            var args = Array.prototype.splice.call(arguments, 1), filter = new Phaser.Filter[filter](this.game);
                            return filter.init.apply(filter, args), filter;
                        },
                        plugin: function(plugin) {
                            return this.game.plugins.add(plugin);
                        }
                    }, Phaser.GameObjectFactory.prototype.constructor = Phaser.GameObjectFactory, Phaser.GameObjectCreator = function(game) {
                        this.game = game, this.world = this.game.world;
                    }, Phaser.GameObjectCreator.prototype = {
                        image: function(x, y, key, frame) {
                            return new Phaser.Image(this.game, x, y, key, frame);
                        },
                        sprite: function(x, y, key, frame) {
                            return new Phaser.Sprite(this.game, x, y, key, frame);
                        },
                        tween: function(obj) {
                            return new Phaser.Tween(obj, this.game, this.game.tweens);
                        },
                        group: function(parent, name, addToStage, enableBody, physicsBodyType) {
                            return new Phaser.Group(this.game, null, name, addToStage, enableBody, physicsBodyType);
                        },
                        spriteBatch: function(parent, name, addToStage) {
                            return "undefined" == typeof name && (name = "group"), "undefined" == typeof addToStage && (addToStage = !1), 
                            new Phaser.SpriteBatch(this.game, parent, name, addToStage);
                        },
                        audio: function(key, volume, loop, connect) {
                            return this.game.sound.add(key, volume, loop, connect);
                        },
                        audioSprite: function(key) {
                            return this.game.sound.addSprite(key);
                        },
                        sound: function(key, volume, loop, connect) {
                            return this.game.sound.add(key, volume, loop, connect);
                        },
                        tileSprite: function(x, y, width, height, key, frame) {
                            return new Phaser.TileSprite(this.game, x, y, width, height, key, frame);
                        },
                        rope: function(x, y, key, frame, points) {
                            return new Phaser.Rope(this.game, x, y, key, frame, points);
                        },
                        text: function(x, y, text, style) {
                            return new Phaser.Text(this.game, x, y, text, style);
                        },
                        button: function(x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) {
                            return new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame);
                        },
                        graphics: function(x, y) {
                            return new Phaser.Graphics(this.game, x, y);
                        },
                        emitter: function(x, y, maxParticles) {
                            return new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles);
                        },
                        retroFont: function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
                            return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
                        },
                        bitmapText: function(x, y, font, text, size) {
                            return new Phaser.BitmapText(this.game, x, y, font, text, size);
                        },
                        tilemap: function(key, tileWidth, tileHeight, width, height) {
                            return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height);
                        },
                        renderTexture: function(width, height, key, addToCache) {
                            ("undefined" == typeof key || "" === key) && (key = this.game.rnd.uuid()), "undefined" == typeof addToCache && (addToCache = !1);
                            var texture = new Phaser.RenderTexture(this.game, width, height, key);
                            return addToCache && this.game.cache.addRenderTexture(key, texture), texture;
                        },
                        bitmapData: function(width, height, key, addToCache) {
                            "undefined" == typeof addToCache && (addToCache = !1), ("undefined" == typeof key || "" === key) && (key = this.game.rnd.uuid());
                            var texture = new Phaser.BitmapData(this.game, key, width, height);
                            return addToCache && this.game.cache.addBitmapData(key, texture), texture;
                        },
                        filter: function(filter) {
                            var args = Array.prototype.splice.call(arguments, 1), filter = new Phaser.Filter[filter](this.game);
                            return filter.init.apply(filter, args), filter;
                        }
                    }, Phaser.GameObjectCreator.prototype.constructor = Phaser.GameObjectCreator, Phaser.BitmapData = function(game, key, width, height) {
                        "undefined" == typeof width && (width = 256), "undefined" == typeof height && (height = 256), 
                        this.game = game, this.key = key, this.width = width, this.height = height, this.canvas = Phaser.Canvas.create(width, height, "", !0), 
                        this.context = this.canvas.getContext("2d", {
                            alpha: !0
                        }), this.ctx = this.context, this.imageData = this.context.getImageData(0, 0, width, height), 
                        this.data = this.imageData.data, this.pixels = null, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, 
                        this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), 
                        this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, 
                        this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), 
                        this.textureFrame = new Phaser.Frame(0, 0, 0, width, height, "bitmapData", game.rnd.uuid()), 
                        this.texture.frame = this.textureFrame, this.type = Phaser.BITMAPDATA, this.disableTextureUpload = !1, 
                        this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new Phaser.Point(), 
                        this._size = new Phaser.Point(), this._scale = new Phaser.Point(), this._rotate = 0, 
                        this._alpha = {
                            prev: 1,
                            current: 1
                        }, this._anchor = new Phaser.Point(), this._tempR = 0, this._tempG = 0, this._tempB = 0, 
                        this._circle = new Phaser.Circle();
                    }, Phaser.BitmapData.prototype = {
                        add: function(object) {
                            if (Array.isArray(object)) for (var i = 0; i < object.length; i++) object[i].loadTexture && object[i].loadTexture(this); else object.loadTexture(this);
                            return this;
                        },
                        load: function(source) {
                            return "string" == typeof source && (source = this.game.cache.getImage(source)), 
                            source ? (this.resize(source.width, source.height), this.cls(), this.draw(source), 
                            this.update(), this) : void 0;
                        },
                        clear: function() {
                            return this.context.clearRect(0, 0, this.width, this.height), this.dirty = !0, this;
                        },
                        fill: function(r, g, b, a) {
                            return "undefined" == typeof a && (a = 1), this.context.fillStyle = "rgba(" + r + "," + g + "," + b + "," + a + ")", 
                            this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this;
                        },
                        resize: function(width, height) {
                            return (width !== this.width || height !== this.height) && (this.width = width, 
                            this.height = height, this.canvas.width = width, this.canvas.height = height, this.baseTexture.width = width, 
                            this.baseTexture.height = height, this.textureFrame.width = width, this.textureFrame.height = height, 
                            this.texture.width = width, this.texture.height = height, this.texture.crop.width = width, 
                            this.texture.crop.height = height, this.update(), this.dirty = !0), this;
                        },
                        update: function(x, y, width, height) {
                            return "undefined" == typeof x && (x = 0), "undefined" == typeof y && (y = 0), "undefined" == typeof width && (width = this.width), 
                            "undefined" == typeof height && (height = this.height), this.imageData = this.context.getImageData(x, y, width, height), 
                            this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, 
                            this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), 
                            this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, 
                            this;
                        },
                        processPixelRGB: function(callback, callbackContext, x, y, width, height) {
                            "undefined" == typeof x && (x = 0), "undefined" == typeof y && (y = 0), "undefined" == typeof width && (width = this.width), 
                            "undefined" == typeof height && (height = this.height);
                            for (var w = x + width, h = y + height, pixel = Phaser.Color.createColor(), result = {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 0
                            }, dirty = !1, ty = y; h > ty; ty++) for (var tx = x; w > tx; tx++) Phaser.Color.unpackPixel(this.getPixel32(tx, ty), pixel), 
                            result = callback.call(callbackContext, pixel, tx, ty), result !== !1 && null !== result && void 0 !== result && (this.setPixel32(tx, ty, result.r, result.g, result.b, result.a, !1), 
                            dirty = !0);
                            return dirty && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), 
                            this;
                        },
                        processPixel: function(callback, callbackContext, x, y, width, height) {
                            "undefined" == typeof x && (x = 0), "undefined" == typeof y && (y = 0), "undefined" == typeof width && (width = this.width), 
                            "undefined" == typeof height && (height = this.height);
                            for (var w = x + width, h = y + height, pixel = 0, result = 0, dirty = !1, ty = y; h > ty; ty++) for (var tx = x; w > tx; tx++) pixel = this.getPixel32(tx, ty), 
                            result = callback.call(callbackContext, pixel, tx, ty), result !== pixel && (this.pixels[ty * this.width + tx] = result, 
                            dirty = !0);
                            return dirty && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), 
                            this;
                        },
                        replaceRGB: function(r1, g1, b1, a1, r2, g2, b2, a2, region) {
                            var sx = 0, sy = 0, w = this.width, h = this.height, source = Phaser.Color.packPixel(r1, g1, b1, a1);
                            void 0 !== region && region instanceof Phaser.Rectangle && (sx = region.x, sy = region.y, 
                            w = region.width, h = region.height);
                            for (var y = 0; h > y; y++) for (var x = 0; w > x; x++) this.getPixel32(sx + x, sy + y) === source && this.setPixel32(sx + x, sy + y, r2, g2, b2, a2, !1);
                            return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this;
                        },
                        setHSL: function(h, s, l, region) {
                            if (("undefined" == typeof h || null === h) && (h = !1), ("undefined" == typeof s || null === s) && (s = !1), 
                            ("undefined" == typeof l || null === l) && (l = !1), h || s || l) {
                                "undefined" == typeof region && (region = new Phaser.Rectangle(0, 0, this.width, this.height));
                                for (var pixel = Phaser.Color.createColor(), y = region.y; y < region.bottom; y++) for (var x = region.x; x < region.right; x++) Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, !0), 
                                h && (pixel.h = h), s && (pixel.s = s), l && (pixel.l = l), Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel), 
                                this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, !1);
                                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this;
                            }
                        },
                        shiftHSL: function(h, s, l, region) {
                            if (("undefined" == typeof h || null === h) && (h = !1), ("undefined" == typeof s || null === s) && (s = !1), 
                            ("undefined" == typeof l || null === l) && (l = !1), h || s || l) {
                                "undefined" == typeof region && (region = new Phaser.Rectangle(0, 0, this.width, this.height));
                                for (var pixel = Phaser.Color.createColor(), y = region.y; y < region.bottom; y++) for (var x = region.x; x < region.right; x++) Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, !0), 
                                h && (pixel.h = this.game.math.wrap(pixel.h + h, 0, 1)), s && (pixel.s = this.game.math.limitValue(pixel.s + s, 0, 1)), 
                                l && (pixel.l = this.game.math.limitValue(pixel.l + l, 0, 1)), Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel), 
                                this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, !1);
                                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this;
                            }
                        },
                        setPixel32: function(x, y, red, green, blue, alpha, immediate) {
                            return "undefined" == typeof immediate && (immediate = !0), x >= 0 && x <= this.width && y >= 0 && y <= this.height && (this.pixels[y * this.width + x] = Phaser.Device.LITTLE_ENDIAN ? alpha << 24 | blue << 16 | green << 8 | red : red << 24 | green << 16 | blue << 8 | alpha, 
                            immediate && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), 
                            this;
                        },
                        setPixel: function(x, y, red, green, blue, immediate) {
                            return this.setPixel32(x, y, red, green, blue, 255, immediate);
                        },
                        getPixel: function(x, y, out) {
                            out || (out = Phaser.Color.createColor());
                            var index = ~~(x + y * this.width);
                            return index *= 4, out.r = this.data[index], out.g = this.data[++index], out.b = this.data[++index], 
                            out.a = this.data[++index], out;
                        },
                        getPixel32: function(x, y) {
                            return x >= 0 && x <= this.width && y >= 0 && y <= this.height ? this.pixels[y * this.width + x] : void 0;
                        },
                        getPixelRGB: function(x, y, out, hsl, hsv) {
                            return Phaser.Color.unpackPixel(this.getPixel32(x, y), out, hsl, hsv);
                        },
                        getPixels: function(rect) {
                            return this.context.getImageData(rect.x, rect.y, rect.width, rect.height);
                        },
                        getFirstPixel: function(direction) {
                            "undefined" == typeof direction && (direction = 0);
                            var pixel = Phaser.Color.createColor(), x = 0, y = 0, v = 1, scan = !1;
                            1 === direction ? (v = -1, y = this.height) : 3 === direction && (v = -1, x = this.width);
                            do Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel), 0 === direction || 1 === direction ? (x++, 
                            x === this.width && (x = 0, y += v, (y >= this.height || 0 >= y) && (scan = !0))) : (2 === direction || 3 === direction) && (y++, 
                            y === this.height && (y = 0, x += v, (x >= this.width || 0 >= x) && (scan = !0))); while (0 === pixel.a && !scan);
                            return pixel.x = x, pixel.y = y, pixel;
                        },
                        getBounds: function(rect) {
                            return "undefined" == typeof rect && (rect = new Phaser.Rectangle()), rect.x = this.getFirstPixel(2).x, 
                            rect.x === this.width ? rect.setTo(0, 0, 0, 0) : (rect.y = this.getFirstPixel(0).y, 
                            rect.width = this.getFirstPixel(3).x - rect.x + 1, rect.height = this.getFirstPixel(1).y - rect.y + 1, 
                            rect);
                        },
                        addToWorld: function(x, y, anchorX, anchorY, scaleX, scaleY) {
                            scaleX = scaleX || 1, scaleY = scaleY || 1;
                            var image = this.game.add.image(x, y, this);
                            return image.anchor.set(anchorX, anchorY), image.scale.set(scaleX, scaleY), image;
                        },
                        copy: function(source, x, y, width, height, tx, ty, newWidth, newHeight, rotate, anchorX, anchorY, scaleX, scaleY, alpha, blendMode, roundPx) {
                            if (("undefined" == typeof source || null === source) && (source = this), this._image = source, 
                            source instanceof Phaser.Sprite || source instanceof Phaser.Image || source instanceof Phaser.Text) this._pos.set(source.texture.crop.x, source.texture.crop.y), 
                            this._size.set(source.texture.crop.width, source.texture.crop.height), this._scale.set(source.scale.x, source.scale.y), 
                            this._anchor.set(source.anchor.x, source.anchor.y), this._rotate = source.rotation, 
                            this._alpha.current = source.alpha, this._image = source.texture.baseTexture.source, 
                            ("undefined" == typeof tx || null === tx) && (tx = source.x), ("undefined" == typeof ty || null === ty) && (ty = source.y), 
                            source.texture.trim && (tx += source.texture.trim.x - source.anchor.x * source.texture.trim.width, 
                            ty += source.texture.trim.y - source.anchor.y * source.texture.trim.height), 16777215 !== source.tint && (source.cachedTint !== source.tint && (source.cachedTint = source.tint, 
                            source.tintedTexture = PIXI.CanvasTinter.getTintedTexture(source, source.tint)), 
                            this._image = source.tintedTexture); else {
                                if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, 
                                this._alpha.current = 1, source instanceof Phaser.BitmapData) this._image = source.canvas; else if ("string" == typeof source) {
                                    if (source = this.game.cache.getImage(source), null === source) return;
                                    this._image = source;
                                }
                                this._size.set(this._image.width, this._image.height);
                            }
                            return ("undefined" == typeof x || null === x) && (x = 0), ("undefined" == typeof y || null === y) && (y = 0), 
                            width && (this._size.x = width), height && (this._size.y = height), ("undefined" == typeof tx || null === tx) && (tx = x), 
                            ("undefined" == typeof ty || null === ty) && (ty = y), ("undefined" == typeof newWidth || null === newWidth) && (newWidth = this._size.x), 
                            ("undefined" == typeof newHeight || null === newHeight) && (newHeight = this._size.y), 
                            "number" == typeof rotate && (this._rotate = rotate), "number" == typeof anchorX && (this._anchor.x = anchorX), 
                            "number" == typeof anchorY && (this._anchor.y = anchorY), "number" == typeof scaleX && (this._scale.x = scaleX), 
                            "number" == typeof scaleY && (this._scale.y = scaleY), "number" == typeof alpha && (this._alpha.current = alpha), 
                            "undefined" == typeof blendMode && (blendMode = null), "undefined" == typeof roundPx && (roundPx = !1), 
                            this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y ? void 0 : (this._alpha.prev = this.context.globalAlpha, 
                            this.context.save(), this.context.globalAlpha = this._alpha.current, blendMode && (this.context.globalCompositeOperation = blendMode), 
                            roundPx && (tx |= 0, ty |= 0), this.context.translate(tx, ty), this.context.scale(this._scale.x, this._scale.y), 
                            this.context.rotate(this._rotate), this.context.drawImage(this._image, this._pos.x + x, this._pos.y + y, this._size.x, this._size.y, -newWidth * this._anchor.x, -newHeight * this._anchor.y, newWidth, newHeight), 
                            this.context.restore(), this.context.globalAlpha = this._alpha.prev, this.dirty = !0, 
                            this);
                        },
                        copyRect: function(source, area, x, y, alpha, blendMode, roundPx) {
                            return this.copy(source, area.x, area.y, area.width, area.height, x, y, area.width, area.height, 0, 0, 0, 1, 1, alpha, blendMode, roundPx);
                        },
                        draw: function(source, x, y, width, height, blendMode, roundPx) {
                            return this.copy(source, null, null, null, null, x, y, width, height, null, null, null, null, null, null, blendMode, roundPx);
                        },
                        drawGroup: function(group, blendMode, roundPx) {
                            return group.total > 0 && group.forEachExists(this.copy, this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, blendMode, roundPx), 
                            this;
                        },
                        shadow: function(color, blur, x, y) {
                            "undefined" == typeof color || null === color ? this.context.shadowColor = "rgba(0,0,0,0)" : (this.context.shadowColor = color, 
                            this.context.shadowBlur = blur || 5, this.context.shadowOffsetX = x || 10, this.context.shadowOffsetY = y || 10);
                        },
                        alphaMask: function(source, mask, sourceRect, maskRect) {
                            return "undefined" == typeof maskRect || null === maskRect ? this.draw(mask).blendSourceAtop() : this.draw(mask, maskRect.x, maskRect.y, maskRect.width, maskRect.height).blendSourceAtop(), 
                            "undefined" == typeof sourceRect || null === sourceRect ? this.draw(source).blendReset() : this.draw(source, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height).blendReset(), 
                            this;
                        },
                        extract: function(destination, r, g, b, a, resize, r2, g2, b2) {
                            return "undefined" == typeof a && (a = 255), "undefined" == typeof resize && (resize = !1), 
                            "undefined" == typeof r2 && (r2 = r), "undefined" == typeof g2 && (g2 = g), "undefined" == typeof b2 && (b2 = b), 
                            resize && destination.resize(this.width, this.height), this.processPixelRGB(function(pixel, x, y) {
                                return pixel.r === r && pixel.g === g && pixel.b === b && destination.setPixel32(x, y, r2, g2, b2, a, !1), 
                                !1;
                            }, this), destination.context.putImageData(destination.imageData, 0, 0), destination.dirty = !0, 
                            destination;
                        },
                        rect: function(x, y, width, height, fillStyle) {
                            return "undefined" != typeof fillStyle && (this.context.fillStyle = fillStyle), 
                            this.context.fillRect(x, y, width, height), this;
                        },
                        circle: function(x, y, radius, fillStyle) {
                            return "undefined" != typeof fillStyle && (this.context.fillStyle = fillStyle), 
                            this.context.beginPath(), this.context.arc(x, y, radius, 0, 2 * Math.PI, !1), this.context.closePath(), 
                            this.context.fill(), this;
                        },
                        textureLine: function(line, image, repeat) {
                            if ("undefined" == typeof repeat && (repeat = "repeat-x"), "string" != typeof image || (image = this.game.cache.getImage(image))) {
                                var width = line.length;
                                return "no-repeat" === repeat && width > image.width && (width = image.width), this.context.fillStyle = this.context.createPattern(image, repeat), 
                                this._circle = new Phaser.Circle(line.start.x, line.start.y, image.height), this._circle.circumferencePoint(line.angle - 1.5707963267948966, !1, this._pos), 
                                this.context.save(), this.context.translate(this._pos.x, this._pos.y), this.context.rotate(line.angle), 
                                this.context.fillRect(0, 0, width, image.height), this.context.restore(), this.dirty = !0, 
                                this;
                            }
                        },
                        render: function() {
                            return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), 
                            this;
                        },
                        blendReset: function() {
                            return this.context.globalCompositeOperation = "source-over", this;
                        },
                        blendSourceOver: function() {
                            return this.context.globalCompositeOperation = "source-over", this;
                        },
                        blendSourceIn: function() {
                            return this.context.globalCompositeOperation = "source-in", this;
                        },
                        blendSourceOut: function() {
                            return this.context.globalCompositeOperation = "source-out", this;
                        },
                        blendSourceAtop: function() {
                            return this.context.globalCompositeOperation = "source-atop", this;
                        },
                        blendDestinationOver: function() {
                            return this.context.globalCompositeOperation = "destination-over", this;
                        },
                        blendDestinationIn: function() {
                            return this.context.globalCompositeOperation = "destination-in", this;
                        },
                        blendDestinationOut: function() {
                            return this.context.globalCompositeOperation = "destination-out", this;
                        },
                        blendDestinationAtop: function() {
                            return this.context.globalCompositeOperation = "destination-atop", this;
                        },
                        blendXor: function() {
                            return this.context.globalCompositeOperation = "xor", this;
                        },
                        blendAdd: function() {
                            return this.context.globalCompositeOperation = "lighter", this;
                        },
                        blendMultiply: function() {
                            return this.context.globalCompositeOperation = "multiply", this;
                        },
                        blendScreen: function() {
                            return this.context.globalCompositeOperation = "screen", this;
                        },
                        blendOverlay: function() {
                            return this.context.globalCompositeOperation = "overlay", this;
                        },
                        blendDarken: function() {
                            return this.context.globalCompositeOperation = "darken", this;
                        },
                        blendLighten: function() {
                            return this.context.globalCompositeOperation = "lighten", this;
                        },
                        blendColorDodge: function() {
                            return this.context.globalCompositeOperation = "color-dodge", this;
                        },
                        blendColorBurn: function() {
                            return this.context.globalCompositeOperation = "color-burn", this;
                        },
                        blendHardLight: function() {
                            return this.context.globalCompositeOperation = "hard-light", this;
                        },
                        blendSoftLight: function() {
                            return this.context.globalCompositeOperation = "soft-light", this;
                        },
                        blendDifference: function() {
                            return this.context.globalCompositeOperation = "difference", this;
                        },
                        blendExclusion: function() {
                            return this.context.globalCompositeOperation = "exclusion", this;
                        },
                        blendHue: function() {
                            return this.context.globalCompositeOperation = "hue", this;
                        },
                        blendSaturation: function() {
                            return this.context.globalCompositeOperation = "saturation", this;
                        },
                        blendColor: function() {
                            return this.context.globalCompositeOperation = "color", this;
                        },
                        blendLuminosity: function() {
                            return this.context.globalCompositeOperation = "luminosity", this;
                        }
                    }, Object.defineProperty(Phaser.BitmapData.prototype, "smoothed", {
                        get: function() {
                            Phaser.Canvas.getSmoothingEnabled(this.context);
                        },
                        set: function(value) {
                            Phaser.Canvas.setSmoothingEnabled(this.context, value);
                        }
                    }), Phaser.BitmapData.getTransform = function(translateX, translateY, scaleX, scaleY, skewX, skewY) {
                        return "number" != typeof translateX && (translateX = 0), "number" != typeof translateY && (translateY = 0), 
                        "number" != typeof scaleX && (scaleX = 1), "number" != typeof scaleY && (scaleY = 1), 
                        "number" != typeof skewX && (skewX = 0), "number" != typeof skewY && (skewY = 0), 
                        {
                            sx: scaleX,
                            sy: scaleY,
                            scaleX: scaleX,
                            scaleY: scaleY,
                            skewX: skewX,
                            skewY: skewY,
                            translateX: translateX,
                            translateY: translateY,
                            tx: translateX,
                            ty: translateY
                        };
                    }, Phaser.BitmapData.prototype.constructor = Phaser.BitmapData, Phaser.Sprite = function(game, x, y, key, frame) {
                        x = x || 0, y = y || 0, key = key || null, frame = frame || null, this.game = game, 
                        this.name = "", this.type = Phaser.SPRITE, this.z = 0, this.events = new Phaser.Events(this), 
                        this.animations = new Phaser.AnimationManager(this), this.key = key, PIXI.Sprite.call(this, PIXI.TextureCache.__default), 
                        this.transformCallback = this.checkTransform, this.transformCallbackContext = this, 
                        this.position.set(x, y), this.world = new Phaser.Point(x, y), this.autoCull = !1, 
                        this.input = null, this.body = null, this.alive = !0, this.health = 1, this.lifespan = 0, 
                        this.checkWorldBounds = !1, this.outOfBoundsKill = !1, this.debug = !1, this.cameraOffset = new Phaser.Point(), 
                        this.cropRect = null, this.scaleMin = null, this.scaleMax = null, this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0 ], 
                        this._crop = null, this._frame = null, this._bounds = new Phaser.Rectangle(), this.loadTexture(key, frame);
                    }, Phaser.Sprite.prototype = Object.create(PIXI.Sprite.prototype), Phaser.Sprite.prototype.constructor = Phaser.Sprite, 
                    Phaser.Sprite.prototype.preUpdate = function() {
                        if (1 === this._cache[4] && this.exists) return this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), 
                        this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this._cache[0] = this.world.x, 
                        this._cache[1] = this.world.y, this._cache[2] = this.rotation, this.body && this.body.preUpdate(), 
                        this._cache[4] = 0, !1;
                        if (this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, 
                        !this.exists || !this.parent.exists) return this._cache[3] = -1, !1;
                        if (this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) return this.kill(), 
                        !1;
                        if ((this.autoCull || this.checkWorldBounds) && (this._bounds.copyFrom(this.getBounds()), 
                        this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, 
                        this.autoCull && (this.game.world.camera.view.intersects(this._bounds) ? (this.renderable = !0, 
                        this.game.world.camera.totalInView++) : this.renderable = !1), this.checkWorldBounds)) if (1 === this._cache[5] && this.game.world.bounds.intersects(this._bounds)) this._cache[5] = 0, 
                        this.events.onEnterBounds$dispatch(this); else if (0 === this._cache[5] && !this.game.world.bounds.intersects(this._bounds) && (this._cache[5] = 1, 
                        this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), 
                        !1;
                        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), 
                        this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++), this.animations.update(), 
                        this.body && this.body.preUpdate();
                        for (var i = 0, len = this.children.length; len > i; i++) this.children[i].preUpdate();
                        return !0;
                    }, Phaser.Sprite.prototype.update = function() {}, Phaser.Sprite.prototype.postUpdate = function() {
                        this.key instanceof Phaser.BitmapData && this.key.render(), this.exists && this.body && this.body.postUpdate(), 
                        1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, 
                        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
                        for (var i = 0, len = this.children.length; len > i; i++) this.children[i].postUpdate();
                    }, Phaser.Sprite.prototype.loadTexture = function(key, frame, stopAnimation) {
                        frame = frame || 0, (stopAnimation || "undefined" == typeof stopAnimation) && this.animations.stop(), 
                        this.key = key;
                        var setFrame = !0, smoothed = this.smoothed;
                        key instanceof Phaser.RenderTexture ? (this.key = key.key, this.setTexture(key)) : key instanceof Phaser.BitmapData ? (this.setTexture(key.texture), 
                        this.game.cache.getFrameData(key.key, Phaser.Cache.BITMAPDATA) && (setFrame = !this.animations.loadFrameData(this.game.cache.getFrameData(key.key, Phaser.Cache.BITMAPDATA), frame))) : key instanceof PIXI.Texture ? this.setTexture(key) : null === key || "undefined" == typeof key ? (this.key = "__default", 
                        this.setTexture(PIXI.TextureCache[this.key])) : "string" != typeof key || this.game.cache.checkImageKey(key) ? (this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[key])), 
                        setFrame = !this.animations.loadFrameData(this.game.cache.getFrameData(key), frame)) : (console.warn("Texture with key '" + key + "' not found."), 
                        this.key = "__missing", this.setTexture(PIXI.TextureCache[this.key])), this.texture.baseTexture.dirty(), 
                        setFrame && (this._frame = Phaser.Rectangle.clone(this.texture.frame)), smoothed || (this.smoothed = !1);
                    }, Phaser.Sprite.prototype.setFrame = function(frame) {
                        this._frame = frame, this.texture.frame.x = frame.x, this.texture.frame.y = frame.y, 
                        this.texture.frame.width = frame.width, this.texture.frame.height = frame.height, 
                        this.texture.crop.x = frame.x, this.texture.crop.y = frame.y, this.texture.crop.width = frame.width, 
                        this.texture.crop.height = frame.height, frame.trimmed ? (this.texture.trim ? (this.texture.trim.x = frame.spriteSourceSizeX, 
                        this.texture.trim.y = frame.spriteSourceSizeY, this.texture.trim.width = frame.sourceSizeW, 
                        this.texture.trim.height = frame.sourceSizeH) : this.texture.trim = {
                            x: frame.spriteSourceSizeX,
                            y: frame.spriteSourceSizeY,
                            width: frame.sourceSizeW,
                            height: frame.sourceSizeH
                        }, this.texture.width = frame.sourceSizeW, this.texture.height = frame.sourceSizeH, 
                        this.texture.frame.width = frame.sourceSizeW, this.texture.frame.height = frame.sourceSizeH) : !frame.trimmed && this.texture.trim && (this.texture.trim = null), 
                        this.cropRect && this.updateCrop(), this.texture._updateUvs();
                    }, Phaser.Sprite.prototype.resetFrame = function() {
                        this._frame && this.setFrame(this._frame);
                    }, Phaser.Sprite.prototype.crop = function(rect, copy) {
                        "undefined" == typeof copy && (copy = !1), rect ? (copy && null !== this.cropRect ? this.cropRect.setTo(rect.x, rect.y, rect.width, rect.height) : this.cropRect = copy && null === this.cropRect ? new Phaser.Rectangle(rect.x, rect.y, rect.width, rect.height) : rect, 
                        this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame());
                    }, Phaser.Sprite.prototype.updateCrop = function() {
                        if (this.cropRect) {
                            this._crop = Phaser.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, 
                            this._crop.y += this._frame.y;
                            var cx = Math.max(this._frame.x, this._crop.x), cy = Math.max(this._frame.y, this._crop.y), cw = Math.min(this._frame.right, this._crop.right) - cx, ch = Math.min(this._frame.bottom, this._crop.bottom) - cy;
                            this.texture.crop.x = cx, this.texture.crop.y = cy, this.texture.crop.width = cw, 
                            this.texture.crop.height = ch, this.texture.frame.width = Math.min(cw, this.cropRect.width), 
                            this.texture.frame.height = Math.min(ch, this.cropRect.height), this.texture.width = this.texture.frame.width, 
                            this.texture.height = this.texture.frame.height, this.texture._updateUvs();
                        }
                    }, Phaser.Sprite.prototype.revive = function(health) {
                        return "undefined" == typeof health && (health = 1), this.alive = !0, this.exists = !0, 
                        this.visible = !0, this.health = health, this.events && this.events.onRevived$dispatch(this), 
                        this;
                    }, Phaser.Sprite.prototype.kill = function() {
                        return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), 
                        this;
                    }, Phaser.Sprite.prototype.destroy = function(destroyChildren) {
                        if (null !== this.game && 1 !== this._cache[8]) {
                            "undefined" == typeof destroyChildren && (destroyChildren = !0), this._cache[8] = 1, 
                            this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof Phaser.Group ? this.parent.remove(this) : this.parent.removeChild(this)), 
                            this.input && this.input.destroy(), this.animations && this.animations.destroy(), 
                            this.body && this.body.destroy(), this.events && this.events.destroy();
                            var i = this.children.length;
                            if (destroyChildren) for (;i--; ) this.children[i].destroy(destroyChildren); else for (;i--; ) this.removeChild(this.children[i]);
                            this._crop && (this._crop = null), this._frame && (this._frame = null), this.alive = !1, 
                            this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, 
                            this._cache[8] = 0;
                        }
                    }, Phaser.Sprite.prototype.damage = function(amount) {
                        return this.alive && (this.health -= amount, this.health <= 0 && this.kill()), this;
                    }, Phaser.Sprite.prototype.reset = function(x, y, health) {
                        return "undefined" == typeof health && (health = 1), this.world.setTo(x, y), this.position.x = x, 
                        this.position.y = y, this.alive = !0, this.exists = !0, this.visible = !0, this.renderable = !0, 
                        this._outOfBoundsFired = !1, this.health = health, this.body && this.body.reset(x, y, !1, !1), 
                        this._cache[4] = 1, this;
                    }, Phaser.Sprite.prototype.bringToTop = function() {
                        return this.parent && this.parent.bringToTop(this), this;
                    }, Phaser.Sprite.prototype.play = function(name, frameRate, loop, killOnComplete) {
                        return this.animations ? this.animations.play(name, frameRate, loop, killOnComplete) : void 0;
                    }, Phaser.Sprite.prototype.overlap = function(displayObject) {
                        return Phaser.Rectangle.intersects(this.getBounds(), displayObject.getBounds());
                    }, Phaser.Sprite.prototype.checkTransform = function(wt) {
                        this.scaleMin && (wt.a < this.scaleMin.x && (wt.a = this.scaleMin.x), wt.d < this.scaleMin.y && (wt.d = this.scaleMin.y)), 
                        this.scaleMax && (wt.a > this.scaleMax.x && (wt.a = this.scaleMax.x), wt.d > this.scaleMax.y && (wt.d = this.scaleMax.y));
                    }, Phaser.Sprite.prototype.setScaleMinMax = function(minX, minY, maxX, maxY) {
                        "undefined" == typeof minY ? minY = maxX = maxY = minX : "undefined" == typeof maxX && (maxX = maxY = minY, 
                        minY = minX), null === minX ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(minX, minY) : this.scaleMin = new Phaser.Point(minX, minY), 
                        null === maxX ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(maxX, maxY) : this.scaleMax = new Phaser.Point(maxX, maxY);
                    }, Object.defineProperty(Phaser.Sprite.prototype, "angle", {
                        get: function() {
                            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));
                        },
                        set: function(value) {
                            this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "deltaX", {
                        get: function() {
                            return this.world.x - this._cache[0];
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "deltaY", {
                        get: function() {
                            return this.world.y - this._cache[1];
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "deltaZ", {
                        get: function() {
                            return this.rotation - this._cache[2];
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "inWorld", {
                        get: function() {
                            return this.game.world.bounds.intersects(this.getBounds());
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "inCamera", {
                        get: function() {
                            return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), 
                            this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), 
                            this.game.world.camera.view.intersects(this._bounds);
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "frame", {
                        get: function() {
                            return this.animations.frame;
                        },
                        set: function(value) {
                            this.animations.frame = value;
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "frameName", {
                        get: function() {
                            return this.animations.frameName;
                        },
                        set: function(value) {
                            this.animations.frameName = value;
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "renderOrderID", {
                        get: function() {
                            return this._cache[3];
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "inputEnabled", {
                        get: function() {
                            return this.input && this.input.enabled;
                        },
                        set: function(value) {
                            value ? null === this.input ? (this.input = new Phaser.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop();
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "exists", {
                        get: function() {
                            return !!this._cache[6];
                        },
                        set: function(value) {
                            value ? (this._cache[6] = 1, this.body && this.body.type === Phaser.Physics.P2JS && this.body.addToWorld(), 
                            this.visible = !0) : (this._cache[6] = 0, this.body && this.body.type === Phaser.Physics.P2JS && this.body.removeFromWorld(), 
                            this.visible = !1);
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "fixedToCamera", {
                        get: function() {
                            return !!this._cache[7];
                        },
                        set: function(value) {
                            value ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0;
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "smoothed", {
                        get: function() {
                            return !this.texture.baseTexture.scaleMode;
                        },
                        set: function(value) {
                            value ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1);
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "x", {
                        get: function() {
                            return this.position.x;
                        },
                        set: function(value) {
                            this.position.x = value, this.body && this.body.type === Phaser.Physics.ARCADE && 2 === this.body.phase && (this.body._reset = 1);
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "y", {
                        get: function() {
                            return this.position.y;
                        },
                        set: function(value) {
                            this.position.y = value, this.body && this.body.type === Phaser.Physics.ARCADE && 2 === this.body.phase && (this.body._reset = 1);
                        }
                    }), Object.defineProperty(Phaser.Sprite.prototype, "destroyPhase", {
                        get: function() {
                            return !!this._cache[8];
                        }
                    }), Phaser.Image = function(game, x, y, key, frame) {
                        x = x || 0, y = y || 0, key = key || null, frame = frame || null, this.game = game, 
                        this.exists = !0, this.name = "", this.type = Phaser.IMAGE, this.z = 0, this.events = new Phaser.Events(this), 
                        this.animations = new Phaser.AnimationManager(this), this.key = key, PIXI.Sprite.call(this, PIXI.TextureCache.__default), 
                        this.transformCallback = this.checkTransform, this.transformCallbackContext = this, 
                        this.position.set(x, y), this.world = new Phaser.Point(x, y), this.alive = !0, this.autoCull = !1, 
                        this.input = null, this.debug = !1, this.cameraOffset = new Phaser.Point(), this.cropRect = null, 
                        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ], this._crop = null, this._frame = null, 
                        this._bounds = new Phaser.Rectangle(), this.loadTexture(key, frame);
                    }, Phaser.Image.prototype = Object.create(PIXI.Sprite.prototype), Phaser.Image.prototype.constructor = Phaser.Image, 
                    Phaser.Image.prototype.preUpdate = function() {
                        if (this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, 
                        !this.exists || !this.parent.exists) return this._cache[3] = -1, !1;
                        this.autoCull && (this._bounds.copyFrom(this.getBounds()), this.renderable = this.game.world.camera.screenView.intersects(this._bounds)), 
                        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), 
                        this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++);
                        for (var i = 0, len = this.children.length; len > i; i++) this.children[i].preUpdate();
                        return !0;
                    }, Phaser.Image.prototype.update = function() {}, Phaser.Image.prototype.postUpdate = function() {
                        this.key instanceof Phaser.BitmapData && this.key.render(), 1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, 
                        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
                        for (var i = 0, len = this.children.length; len > i; i++) this.children[i].postUpdate();
                    }, Phaser.Image.prototype.loadTexture = function(key, frame) {
                        frame = frame || 0, this.key = key;
                        var setFrame = !0, smoothed = this.smoothed;
                        key instanceof Phaser.RenderTexture ? (this.key = key.key, this.setTexture(key)) : key instanceof Phaser.BitmapData ? (this.setTexture(key.texture), 
                        this.game.cache.getFrameData(key.key, Phaser.Cache.BITMAPDATA) && (setFrame = !this.animations.loadFrameData(this.game.cache.getFrameData(key.key, Phaser.Cache.BITMAPDATA), frame))) : key instanceof PIXI.Texture ? this.setTexture(key) : null === key || "undefined" == typeof key ? (this.key = "__default", 
                        this.setTexture(PIXI.TextureCache[this.key])) : "string" != typeof key || this.game.cache.checkImageKey(key) ? (this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[key])), 
                        setFrame = !this.animations.loadFrameData(this.game.cache.getFrameData(key), frame)) : (console.warn("Texture with key '" + key + "' not found."), 
                        this.key = "__missing", this.setTexture(PIXI.TextureCache[this.key])), this.texture.baseTexture.dirty(), 
                        setFrame && (this._frame = Phaser.Rectangle.clone(this.texture.frame)), smoothed || (this.smoothed = !1);
                    }, Phaser.Image.prototype.setFrame = function(frame) {
                        this._frame = frame, this.texture.frame.x = frame.x, this.texture.frame.y = frame.y, 
                        this.texture.frame.width = frame.width, this.texture.frame.height = frame.height, 
                        this.texture.crop.x = frame.x, this.texture.crop.y = frame.y, this.texture.crop.width = frame.width, 
                        this.texture.crop.height = frame.height, frame.trimmed ? (this.texture.trim ? (this.texture.trim.x = frame.spriteSourceSizeX, 
                        this.texture.trim.y = frame.spriteSourceSizeY, this.texture.trim.width = frame.sourceSizeW, 
                        this.texture.trim.height = frame.sourceSizeH) : this.texture.trim = {
                            x: frame.spriteSourceSizeX,
                            y: frame.spriteSourceSizeY,
                            width: frame.sourceSizeW,
                            height: frame.sourceSizeH
                        }, this.texture.width = frame.sourceSizeW, this.texture.height = frame.sourceSizeH, 
                        this.texture.frame.width = frame.sourceSizeW, this.texture.frame.height = frame.sourceSizeH) : !frame.trimmed && this.texture.trim && (this.texture.trim = null), 
                        this.cropRect && this.updateCrop(), this.texture._updateUvs();
                    }, Phaser.Image.prototype.resetFrame = function() {
                        this._frame && this.setFrame(this._frame);
                    }, Phaser.Image.prototype.crop = function(rect, copy) {
                        "undefined" == typeof copy && (copy = !1), rect ? (copy && null !== this.cropRect ? this.cropRect.setTo(rect.x, rect.y, rect.width, rect.height) : this.cropRect = copy && null === this.cropRect ? new Phaser.Rectangle(rect.x, rect.y, rect.width, rect.height) : rect, 
                        this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame());
                    }, Phaser.Image.prototype.updateCrop = function() {
                        if (this.cropRect) {
                            this._crop = Phaser.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, 
                            this._crop.y += this._frame.y;
                            var cx = Math.max(this._frame.x, this._crop.x), cy = Math.max(this._frame.y, this._crop.y), cw = Math.min(this._frame.right, this._crop.right) - cx, ch = Math.min(this._frame.bottom, this._crop.bottom) - cy;
                            this.texture.crop.x = cx, this.texture.crop.y = cy, this.texture.crop.width = cw, 
                            this.texture.crop.height = ch, this.texture.frame.width = Math.min(cw, this.cropRect.width), 
                            this.texture.frame.height = Math.min(ch, this.cropRect.height), this.texture.width = this.texture.frame.width, 
                            this.texture.height = this.texture.frame.height, this.texture._updateUvs();
                        }
                    }, Phaser.Image.prototype.revive = function() {
                        return this.alive = !0, this.exists = !0, this.visible = !0, this.events && this.events.onRevived$dispatch(this), 
                        this;
                    }, Phaser.Image.prototype.kill = function() {
                        return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), 
                        this;
                    }, Phaser.Image.prototype.destroy = function(destroyChildren) {
                        if (null !== this.game && !this.destroyPhase) {
                            "undefined" == typeof destroyChildren && (destroyChildren = !0), this._cache[8] = 1, 
                            this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof Phaser.Group ? this.parent.remove(this) : this.parent.removeChild(this)), 
                            this.events && this.events.destroy(), this.input && this.input.destroy(), this.animations && this.animations.destroy();
                            var i = this.children.length;
                            if (destroyChildren) for (;i--; ) this.children[i].destroy(destroyChildren); else for (;i--; ) this.removeChild(this.children[i]);
                            this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, 
                            this.game = null, this._cache[8] = 0;
                        }
                    }, Phaser.Image.prototype.reset = function(x, y) {
                        return this.world.setTo(x, y), this.position.x = x, this.position.y = y, this.alive = !0, 
                        this.exists = !0, this.visible = !0, this.renderable = !0, this;
                    }, Phaser.Image.prototype.bringToTop = function() {
                        return this.parent && this.parent.bringToTop(this), this;
                    }, Phaser.Image.prototype.checkTransform = function(wt) {
                        this.scaleMin && (wt.a < this.scaleMin.x && (wt.a = this.scaleMin.x), wt.d < this.scaleMin.y && (wt.d = this.scaleMin.y)), 
                        this.scaleMax && (wt.a > this.scaleMax.x && (wt.a = this.scaleMax.x), wt.d > this.scaleMax.y && (wt.d = this.scaleMax.y));
                    }, Phaser.Image.prototype.setScaleMinMax = function(minX, minY, maxX, maxY) {
                        "undefined" == typeof minY ? minY = maxX = maxY = minX : "undefined" == typeof maxX && (maxX = maxY = minY, 
                        minY = minX), null === minX ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(minX, minY) : this.scaleMin = new Phaser.Point(minX, minY), 
                        null === maxX ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(maxX, maxY) : this.scaleMax = new Phaser.Point(maxX, maxY);
                    }, Object.defineProperty(Phaser.Image.prototype, "angle", {
                        get: function() {
                            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));
                        },
                        set: function(value) {
                            this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
                        }
                    }), Object.defineProperty(Phaser.Image.prototype, "deltaX", {
                        get: function() {
                            return this.world.x - this._cache[0];
                        }
                    }), Object.defineProperty(Phaser.Image.prototype, "deltaY", {
                        get: function() {
                            return this.world.y - this._cache[1];
                        }
                    }), Object.defineProperty(Phaser.Image.prototype, "deltaZ", {
                        get: function() {
                            return this.rotation - this._cache[2];
                        }
                    }), Object.defineProperty(Phaser.Image.prototype, "inWorld", {
                        get: function() {
                            return this.game.world.bounds.intersects(this.getBounds());
                        }
                    }), Object.defineProperty(Phaser.Image.prototype, "inCamera", {
                        get: function() {
                            return this.game.world.camera.screenView.intersects(this.getBounds());
                        }
                    }), Object.defineProperty(Phaser.Image.prototype, "frame", {
                        get: function() {
                            return this._frame;
                        },
                        set: function(value) {
                            if (value !== this.frame) {
                                var frameData = this.game.cache.getFrameData(this.key);
                                frameData && value < frameData.total && frameData.getFrame(value) && (this.setTexture(PIXI.TextureCache[frameData.getFrame(value).uuid]), 
                                this._frame = value);
                            }
                        }
                    }), Object.defineProperty(Phaser.Image.prototype, "frameName", {
                        get: function() {
                            return this._frameName;
                        },
                        set: function(value) {
                            if (value !== this.frameName) {
                                var frameData = this.game.cache.getFrameData(this.key);
                                frameData && frameData.getFrameByName(value) && (this.setTexture(PIXI.TextureCache[frameData.getFrameByName(value).uuid]), 
                                this._frameName = value);
                            }
                        }
                    }), Object.defineProperty(Phaser.Image.prototype, "renderOrderID", {
                        get: function() {
                            return this._cache[3];
                        }
                    }), Object.defineProperty(Phaser.Image.prototype, "inputEnabled", {
                        get: function() {
                            return this.input && this.input.enabled;
                        },
                        set: function(value) {
                            value ? null === this.input ? (this.input = new Phaser.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop();
                        }
                    }), Object.defineProperty(Phaser.Image.prototype, "fixedToCamera", {
                        get: function() {
                            return !!this._cache[7];
                        },
                        set: function(value) {
                            value ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0;
                        }
                    }), Object.defineProperty(Phaser.Image.prototype, "smoothed", {
                        get: function() {
                            return !this.texture.baseTexture.scaleMode;
                        },
                        set: function(value) {
                            value ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1);
                        }
                    }), Object.defineProperty(Phaser.Image.prototype, "destroyPhase", {
                        get: function() {
                            return !!this._cache[8];
                        }
                    }), Phaser.TileSprite = function(game, x, y, width, height, key, frame) {
                        x = x || 0, y = y || 0, width = width || 256, height = height || 256, key = key || null, 
                        frame = frame || null, this.game = game, this.name = "", this.type = Phaser.TILESPRITE, 
                        this.z = 0, this.events = new Phaser.Events(this), this.animations = new Phaser.AnimationManager(this), 
                        this.key = key, this._frame = 0, this._frameName = "", this._scroll = new Phaser.Point(), 
                        PIXI.TilingSprite.call(this, PIXI.TextureCache.__default, width, height), this.position.set(x, y), 
                        this.input = null, this.world = new Phaser.Point(x, y), this.autoCull = !1, this.checkWorldBounds = !1, 
                        this.cameraOffset = new Phaser.Point(), this.body = null, this.alive = !0, this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ], 
                        this.loadTexture(key, frame);
                    }, Phaser.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype), Phaser.TileSprite.prototype.constructor = Phaser.TileSprite, 
                    Phaser.TileSprite.prototype.preUpdate = function() {
                        if (1 === this._cache[4] && this.exists) return this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), 
                        this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this._cache[0] = this.world.x, 
                        this._cache[1] = this.world.y, this._cache[2] = this.rotation, this.body && this.body.preUpdate(), 
                        this._cache[4] = 0, !1;
                        if (this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, 
                        !this.exists || !this.parent.exists) return this._cache[3] = -1, !1;
                        (this.autoCull || this.checkWorldBounds) && this._bounds.copyFrom(this.getBounds()), 
                        this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this._bounds)), 
                        this.checkWorldBounds && (1 === this._cache[5] && this.game.world.bounds.intersects(this._bounds) ? (this._cache[5] = 0, 
                        this.events.onEnterBounds$dispatch(this)) : 0 !== this._cache[5] || this.game.world.bounds.intersects(this._bounds) || (this._cache[5] = 1, 
                        this.events.onOutOfBounds$dispatch(this))), this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), 
                        this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++), this.animations.update(), 
                        0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 
                        0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), 
                        this.body && this.body.preUpdate();
                        for (var i = 0, len = this.children.length; len > i; i++) this.children[i].preUpdate();
                        return !0;
                    }, Phaser.TileSprite.prototype.update = function() {}, Phaser.TileSprite.prototype.postUpdate = function() {
                        this.exists && this.body && this.body.postUpdate(), 1 === this._cache[7] && (this.position.x = this.game.camera.view.x + this.cameraOffset.x, 
                        this.position.y = this.game.camera.view.y + this.cameraOffset.y);
                        for (var i = 0, len = this.children.length; len > i; i++) this.children[i].postUpdate();
                    }, Phaser.TileSprite.prototype.autoScroll = function(x, y) {
                        this._scroll.set(x, y);
                    }, Phaser.TileSprite.prototype.stopScroll = function() {
                        this._scroll.set(0, 0);
                    }, Phaser.TileSprite.prototype.loadTexture = function(key, frame) {
                        frame = frame || 0, this.key = key, key instanceof Phaser.RenderTexture ? (this.key = key.key, 
                        this.setTexture(key)) : key instanceof Phaser.BitmapData ? this.setTexture(key.texture) : key instanceof PIXI.Texture ? this.setTexture(key) : null === key || "undefined" == typeof key ? (this.key = "__default", 
                        this.setTexture(PIXI.TextureCache[this.key])) : "string" != typeof key || this.game.cache.checkImageKey(key) ? (this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[key])), 
                        this.animations.loadFrameData(this.game.cache.getFrameData(key), frame)) : (console.warn("Texture with key '" + key + "' not found."), 
                        this.key = "__missing", this.setTexture(PIXI.TextureCache[this.key])), this.texture.baseTexture.dirty();
                    }, Phaser.TileSprite.prototype.setFrame = function(frame) {
                        this.texture.frame.x = frame.x, this.texture.frame.y = frame.y, this.texture.frame.width = frame.width, 
                        this.texture.frame.height = frame.height, this.texture.crop.x = frame.x, this.texture.crop.y = frame.y, 
                        this.texture.crop.width = frame.width, this.texture.crop.height = frame.height, 
                        frame.trimmed ? (this.texture.trim ? (this.texture.trim.x = frame.spriteSourceSizeX, 
                        this.texture.trim.y = frame.spriteSourceSizeY, this.texture.trim.width = frame.sourceSizeW, 
                        this.texture.trim.height = frame.sourceSizeH) : this.texture.trim = {
                            x: frame.spriteSourceSizeX,
                            y: frame.spriteSourceSizeY,
                            width: frame.sourceSizeW,
                            height: frame.sourceSizeH
                        }, this.texture.width = frame.sourceSizeW, this.texture.height = frame.sourceSizeH, 
                        this.texture.frame.width = frame.sourceSizeW, this.texture.frame.height = frame.sourceSizeH) : !frame.trimmed && this.texture.trim && (this.texture.trim = null), 
                        this.texture._updateUvs();
                    }, Phaser.TileSprite.prototype.destroy = function(destroyChildren) {
                        if (null !== this.game && !this.destroyPhase) {
                            "undefined" == typeof destroyChildren && (destroyChildren = !0), this._cache[8] = 1, 
                            this.events && this.events.onDestroy$dispatch(this), this.filters && (this.filters = null), 
                            this.parent && (this.parent instanceof Phaser.Group ? this.parent.remove(this) : this.parent.removeChild(this)), 
                            this.animations.destroy(), this.events.destroy();
                            var i = this.children.length;
                            if (destroyChildren) for (;i--; ) this.children[i].destroy(destroyChildren); else for (;i--; ) this.removeChild(this.children[i]);
                            this.exists = !1, this.visible = !1, this.alive = !1, this.filters = null, this.mask = null, 
                            this.game = null, this._cache[8] = 0;
                        }
                    }, Phaser.TileSprite.prototype.play = function(name, frameRate, loop, killOnComplete) {
                        return this.animations.play(name, frameRate, loop, killOnComplete);
                    }, Phaser.TileSprite.prototype.reset = function(x, y) {
                        return this.world.setTo(x, y), this.position.x = x, this.position.y = y, this.alive = !0, 
                        this.exists = !0, this.visible = !0, this.renderable = !0, this._outOfBoundsFired = !1, 
                        this.tilePosition.x = 0, this.tilePosition.y = 0, this.body && this.body.reset(x, y, !1, !1), 
                        this._cache[4] = 1, this;
                    }, Object.defineProperty(Phaser.TileSprite.prototype, "angle", {
                        get: function() {
                            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));
                        },
                        set: function(value) {
                            this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
                        }
                    }), Object.defineProperty(Phaser.TileSprite.prototype, "frame", {
                        get: function() {
                            return this.animations.frame;
                        },
                        set: function(value) {
                            value !== this.animations.frame && (this.animations.frame = value);
                        }
                    }), Object.defineProperty(Phaser.TileSprite.prototype, "frameName", {
                        get: function() {
                            return this.animations.frameName;
                        },
                        set: function(value) {
                            value !== this.animations.frameName && (this.animations.frameName = value);
                        }
                    }), Object.defineProperty(Phaser.TileSprite.prototype, "fixedToCamera", {
                        get: function() {
                            return !!this._cache[7];
                        },
                        set: function(value) {
                            value ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0;
                        }
                    }), Object.defineProperty(Phaser.TileSprite.prototype, "exists", {
                        get: function() {
                            return !!this._cache[6];
                        },
                        set: function(value) {
                            value ? (this._cache[6] = 1, this.body && this.body.type === Phaser.Physics.P2JS && this.body.addToWorld(), 
                            this.visible = !0) : (this._cache[6] = 0, this.body && this.body.type === Phaser.Physics.P2JS && (this.body.safeRemove = !0), 
                            this.visible = !1);
                        }
                    }), Object.defineProperty(Phaser.TileSprite.prototype, "inputEnabled", {
                        get: function() {
                            return this.input && this.input.enabled;
                        },
                        set: function(value) {
                            value ? null === this.input ? (this.input = new Phaser.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop();
                        }
                    }), Object.defineProperty(Phaser.TileSprite.prototype, "x", {
                        get: function() {
                            return this.position.x;
                        },
                        set: function(value) {
                            this.position.x = value, this.body && this.body.type === Phaser.Physics.ARCADE && 2 === this.body.phase && (this.body._reset = 1);
                        }
                    }), Object.defineProperty(Phaser.TileSprite.prototype, "y", {
                        get: function() {
                            return this.position.y;
                        },
                        set: function(value) {
                            this.position.y = value, this.body && this.body.type === Phaser.Physics.ARCADE && 2 === this.body.phase && (this.body._reset = 1);
                        }
                    }), Object.defineProperty(Phaser.TileSprite.prototype, "destroyPhase", {
                        get: function() {
                            return !!this._cache[8];
                        }
                    }), Phaser.Rope = function(game, x, y, key, frame, points) {
                        this.points = [], this.points = points, this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, 
                        x = x || 0, y = y || 0, key = key || null, frame = frame || null, this.game = game, 
                        this.name = "", this.type = Phaser.ROPE, this.z = 0, this.events = new Phaser.Events(this), 
                        this.animations = new Phaser.AnimationManager(this), this.key = key, this._frame = 0, 
                        this._frameName = "", this._scroll = new Phaser.Point(), PIXI.Rope.call(this, key, this.points), 
                        this.position.set(x, y), this.input = null, this.world = new Phaser.Point(x, y), 
                        this.autoCull = !1, this.checkWorldBounds = !1, this.cameraOffset = new Phaser.Point(), 
                        this.body = null, this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ], this.loadTexture(key, frame);
                    }, Phaser.Rope.prototype = Object.create(PIXI.Rope.prototype), Phaser.Rope.prototype.constructor = Phaser.Rope, 
                    Phaser.Rope.prototype.preUpdate = function() {
                        if (1 === this._cache[4] && this.exists) return this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), 
                        this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this._cache[0] = this.world.x, 
                        this._cache[1] = this.world.y, this._cache[2] = this.rotation, this.body && this.body.preUpdate(), 
                        this._cache[4] = 0, !1;
                        if (this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, 
                        !this.exists || !this.parent.exists) return this._cache[3] = -1, !1;
                        (this.autoCull || this.checkWorldBounds) && this._bounds.copyFrom(this.getBounds()), 
                        this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this._bounds)), 
                        this.checkWorldBounds && (1 === this._cache[5] && this.game.world.bounds.intersects(this._bounds) ? (this._cache[5] = 0, 
                        this.events.onEnterBounds$dispatch(this)) : 0 !== this._cache[5] || this.game.world.bounds.intersects(this._bounds) || (this._cache[5] = 1, 
                        this.events.onOutOfBounds$dispatch(this))), this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), 
                        this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++), this.animations.update(), 
                        0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 
                        0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), 
                        this.body && this.body.preUpdate();
                        for (var i = 0, len = this.children.length; len > i; i++) this.children[i].preUpdate();
                        return !0;
                    }, Phaser.Rope.prototype.update = function() {
                        this._hasUpdateAnimation && this.updateAnimation.call(this);
                    }, Phaser.Rope.prototype.postUpdate = function() {
                        this.exists && this.body && this.body.postUpdate(), 1 === this._cache[7] && (this.position.x = this.game.camera.view.x + this.cameraOffset.x, 
                        this.position.y = this.game.camera.view.y + this.cameraOffset.y);
                        for (var i = 0, len = this.children.length; len > i; i++) this.children[i].postUpdate();
                    }, Phaser.Rope.prototype.loadTexture = function(key, frame) {
                        frame = frame || 0, this.key = key, key instanceof Phaser.RenderTexture ? (this.key = key.key, 
                        this.setTexture(key)) : key instanceof Phaser.BitmapData ? this.setTexture(key.texture) : key instanceof PIXI.Texture ? this.setTexture(key) : null === key || "undefined" == typeof key ? (this.key = "__default", 
                        this.setTexture(PIXI.TextureCache[this.key])) : "string" != typeof key || this.game.cache.checkImageKey(key) ? (this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[key])), 
                        this.animations.loadFrameData(this.game.cache.getFrameData(key), frame)) : (console.warn("Texture with key '" + key + "' not found."), 
                        this.key = "__missing", this.setTexture(PIXI.TextureCache[this.key]));
                    }, Phaser.Rope.prototype.setFrame = function(frame) {
                        this.texture.frame.x = frame.x, this.texture.frame.y = frame.y, this.texture.frame.width = frame.width, 
                        this.texture.frame.height = frame.height, this.texture.crop.x = frame.x, this.texture.crop.y = frame.y, 
                        this.texture.crop.width = frame.width, this.texture.crop.height = frame.height, 
                        frame.trimmed ? (this.texture.trim ? (this.texture.trim.x = frame.spriteSourceSizeX, 
                        this.texture.trim.y = frame.spriteSourceSizeY, this.texture.trim.width = frame.sourceSizeW, 
                        this.texture.trim.height = frame.sourceSizeH) : this.texture.trim = {
                            x: frame.spriteSourceSizeX,
                            y: frame.spriteSourceSizeY,
                            width: frame.sourceSizeW,
                            height: frame.sourceSizeH
                        }, this.texture.width = frame.sourceSizeW, this.texture.height = frame.sourceSizeH, 
                        this.texture.frame.width = frame.sourceSizeW, this.texture.frame.height = frame.sourceSizeH) : !frame.trimmed && this.texture.trim && (this.texture.trim = null), 
                        this.texture._updateUvs();
                    }, Phaser.Rope.prototype.destroy = function(destroyChildren) {
                        if (null !== this.game && !this.destroyPhase) {
                            "undefined" == typeof destroyChildren && (destroyChildren = !0), this._cache[8] = 1, 
                            this.events && this.events.onDestroy$dispatch(this), this.filters && (this.filters = null), 
                            this.parent && (this.parent instanceof Phaser.Group ? this.parent.remove(this) : this.parent.removeChild(this)), 
                            this.animations.destroy(), this.events.destroy();
                            var i = this.children.length;
                            if (destroyChildren) for (;i--; ) this.children[i].destroy(destroyChildren); else for (;i--; ) this.removeChild(this.children[i]);
                            this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, 
                            this._cache[8] = 0;
                        }
                    }, Phaser.Rope.prototype.play = function(name, frameRate, loop, killOnComplete) {
                        return this.animations.play(name, frameRate, loop, killOnComplete);
                    }, Phaser.Rope.prototype.reset = function(x, y) {
                        return this.world.setTo(x, y), this.position.x = x, this.position.y = y, this.alive = !0, 
                        this.exists = !0, this.visible = !0, this.renderable = !0, this._outOfBoundsFired = !1, 
                        this.tilePosition.x = 0, this.tilePosition.y = 0, this.body && this.body.reset(x, y, !1, !1), 
                        this._cache[4] = 1, this;
                    }, Object.defineProperty(Phaser.Rope.prototype, "angle", {
                        get: function() {
                            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));
                        },
                        set: function(value) {
                            this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
                        }
                    }), Object.defineProperty(Phaser.Rope.prototype, "frame", {
                        get: function() {
                            return this.animations.frame;
                        },
                        set: function(value) {
                            value !== this.animations.frame && (this.animations.frame = value);
                        }
                    }), Object.defineProperty(Phaser.Rope.prototype, "frameName", {
                        get: function() {
                            return this.animations.frameName;
                        },
                        set: function(value) {
                            value !== this.animations.frameName && (this.animations.frameName = value);
                        }
                    }), Object.defineProperty(Phaser.Rope.prototype, "fixedToCamera", {
                        get: function() {
                            return !!this._cache[7];
                        },
                        set: function(value) {
                            value ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0;
                        }
                    }), Object.defineProperty(Phaser.Rope.prototype, "exists", {
                        get: function() {
                            return !!this._cache[6];
                        },
                        set: function(value) {
                            value ? (this._cache[6] = 1, this.body && this.body.type === Phaser.Physics.P2JS && this.body.addToWorld(), 
                            this.visible = !0) : (this._cache[6] = 0, this.body && this.body.type === Phaser.Physics.P2JS && (this.body.safeRemove = !0), 
                            this.visible = !1);
                        }
                    }), Object.defineProperty(Phaser.Rope.prototype, "inputEnabled", {
                        get: function() {
                            return this.input && this.input.enabled;
                        },
                        set: function(value) {
                            value ? null === this.input ? (this.input = new Phaser.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop();
                        }
                    }), Object.defineProperty(Phaser.Rope.prototype, "x", {
                        get: function() {
                            return this.position.x;
                        },
                        set: function(value) {
                            this.position.x = value, this.body && this.body.type === Phaser.Physics.ARCADE && 2 === this.body.phase && (this.body._reset = 1);
                        }
                    }), Object.defineProperty(Phaser.Rope.prototype, "y", {
                        get: function() {
                            return this.position.y;
                        },
                        set: function(value) {
                            this.position.y = value, this.body && this.body.type === Phaser.Physics.ARCADE && 2 === this.body.phase && (this.body._reset = 1);
                        }
                    }), Object.defineProperty(Phaser.Rope.prototype, "updateAnimation", {
                        get: function() {
                            return this._updateAnimation;
                        },
                        set: function(value) {
                            value && "function" == typeof value ? (this._hasUpdateAnimation = !0, this._updateAnimation = value) : (this._hasUpdateAnimation = !1, 
                            this._updateAnimation = null);
                        }
                    }), Object.defineProperty(Phaser.Rope.prototype, "segments", {
                        get: function() {
                            for (var index, x1, y1, x2, y2, width, height, rect, segments = [], i = 0; i < this.points.length; i++) index = 4 * i, 
                            x1 = this.verticies[index], y1 = this.verticies[index + 1], x2 = this.verticies[index + 4], 
                            y2 = this.verticies[index + 3], width = Phaser.Math.difference(x1, x2), height = Phaser.Math.difference(y1, y2), 
                            x1 += this.world.x, y1 += this.world.y, rect = new Phaser.Rectangle(x1, y1, width, height), 
                            segments.push(rect);
                            return segments;
                        }
                    }), Object.defineProperty(Phaser.Rope.prototype, "destroyPhase", {
                        get: function() {
                            return !!this._cache[8];
                        }
                    }), Phaser.Text = function(game, x, y, text, style) {
                        x = x || 0, y = y || 0, text = text || " ", style = style || {}, text = 0 === text.length ? " " : text.toString(), 
                        this.game = game, this.exists = !0, this.name = "", this.type = Phaser.TEXT, this.z = 0, 
                        this.world = new Phaser.Point(x, y), this._text = text, this._font = "", this._fontSize = 32, 
                        this._fontWeight = "normal", this._lineSpacing = 0, this._charCount = 0, this.events = new Phaser.Events(this), 
                        this.input = null, this.cameraOffset = new Phaser.Point(), this.colors = [], this.setStyle(style), 
                        PIXI.Text.call(this, text, this.style), this.position.set(x, y), this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ], 
                        " " !== text && this.updateText();
                    }, Phaser.Text.prototype = Object.create(PIXI.Text.prototype), Phaser.Text.prototype.constructor = Phaser.Text, 
                    Phaser.Text.prototype.preUpdate = function() {
                        if (this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, 
                        !this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                        this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this.getBounds())), 
                        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), 
                        this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++);
                        for (var i = 0, len = this.children.length; len > i; i++) this.children[i].preUpdate();
                        return !0;
                    }, Phaser.Text.prototype.update = function() {}, Phaser.Text.prototype.postUpdate = function() {
                        1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, 
                        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
                        for (var i = 0, len = this.children.length; len > i; i++) this.children[i].postUpdate();
                    }, Phaser.Text.prototype.destroy = function(destroyChildren) {
                        if (null !== this.game && !this.destroyPhase) {
                            "undefined" == typeof destroyChildren && (destroyChildren = !0), this._cache[8] = 1, 
                            this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof Phaser.Group ? this.parent.remove(this) : this.parent.removeChild(this)), 
                            this.texture.destroy(!0), this.canvas.parentNode ? this.canvas.parentNode.removeChild(this.canvas) : (this.canvas = null, 
                            this.context = null);
                            var i = this.children.length;
                            if (destroyChildren) for (;i--; ) this.children[i].destroy(destroyChildren); else for (;i--; ) this.removeChild(this.children[i]);
                            this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, 
                            this._cache[8] = 0;
                        }
                    }, Phaser.Text.prototype.setShadow = function(x, y, color, blur) {
                        "undefined" == typeof x && (x = 0), "undefined" == typeof y && (y = 0), "undefined" == typeof color && (color = "rgba(0, 0, 0, 1)"), 
                        "undefined" == typeof blur && (blur = 0), this.style.shadowOffsetX = x, this.style.shadowOffsetY = y, 
                        this.style.shadowColor = color, this.style.shadowBlur = blur, this.dirty = !0;
                    }, Phaser.Text.prototype.setStyle = function(style) {
                        style = style || {}, style.font = style.font || "bold 20pt Arial", style.fill = style.fill || "black", 
                        style.align = style.align || "left", style.stroke = style.stroke || "black", style.strokeThickness = style.strokeThickness || 0, 
                        style.wordWrap = style.wordWrap || !1, style.wordWrapWidth = style.wordWrapWidth || 100, 
                        style.shadowOffsetX = style.shadowOffsetX || 0, style.shadowOffsetY = style.shadowOffsetY || 0, 
                        style.shadowColor = style.shadowColor || "rgba(0,0,0,0)", style.shadowBlur = style.shadowBlur || 0, 
                        this.style = style, this.dirty = !0;
                    }, Phaser.Text.prototype.updateText = function() {
                        this.texture.baseTexture.resolution = this.resolution, this.context.font = this.style.font;
                        var outputText = this.text;
                        this.style.wordWrap && (outputText = this.runWordWrap(this.text));
                        for (var lines = outputText.split(/(?:\r\n|\r|\n)/), lineWidths = [], maxLineWidth = 0, fontProperties = this.determineFontProperties(this.style.font), i = 0; i < lines.length; i++) {
                            var lineWidth = this.context.measureText(lines[i]).width;
                            lineWidths[i] = lineWidth, maxLineWidth = Math.max(maxLineWidth, lineWidth);
                        }
                        var width = maxLineWidth + this.style.strokeThickness;
                        this.canvas.width = width * this.resolution;
                        var lineHeight = fontProperties.fontSize + this.style.strokeThickness + this._lineSpacing, height = (lineHeight + this._lineSpacing) * lines.length;
                        this.canvas.height = height * this.resolution, this.context.scale(this.resolution, this.resolution), 
                        navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), 
                        this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, 
                        this.context.textBaseline = "alphabetic", this.context.shadowOffsetX = this.style.shadowOffsetX, 
                        this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, 
                        this.context.shadowBlur = this.style.shadowBlur, this.context.lineWidth = this.style.strokeThickness, 
                        this.context.lineCap = "round", this.context.lineJoin = "round";
                        var linePositionX, linePositionY;
                        for (this._charCount = 0, i = 0; i < lines.length; i++) linePositionX = this.style.strokeThickness / 2, 
                        linePositionY = this.style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent, 
                        "right" === this.style.align ? linePositionX += maxLineWidth - lineWidths[i] : "center" === this.style.align && (linePositionX += (maxLineWidth - lineWidths[i]) / 2), 
                        this.colors.length > 0 ? this.updateLine(lines[i], linePositionX, linePositionY) : (this.style.stroke && this.style.strokeThickness && this.context.strokeText(lines[i], linePositionX, linePositionY), 
                        this.style.fill && this.context.fillText(lines[i], linePositionX, linePositionY));
                        this.updateTexture();
                    }, Phaser.Text.prototype.updateLine = function(line, x, y) {
                        for (var i = 0; i < line.length; i++) {
                            var letter = line[i];
                            this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount], 
                            this.context.strokeStyle = this.colors[this._charCount]), this.style.stroke && this.style.strokeThickness && this.context.strokeText(letter, x, y), 
                            this.style.fill && this.context.fillText(letter, x, y), x += this.context.measureText(letter).width, 
                            this._charCount++;
                        }
                    }, Phaser.Text.prototype.clearColors = function() {
                        this.colors = [], this.dirty = !0;
                    }, Phaser.Text.prototype.addColor = function(color, position) {
                        this.colors[position] = color, this.dirty = !0;
                    }, Phaser.Text.prototype.runWordWrap = function(text) {
                        for (var result = "", lines = text.split("\n"), i = 0; i < lines.length; i++) {
                            for (var spaceLeft = this.style.wordWrapWidth, words = lines[i].split(" "), j = 0; j < words.length; j++) {
                                var wordWidth = this.context.measureText(words[j]).width, wordWidthWithSpace = wordWidth + this.context.measureText(" ").width;
                                wordWidthWithSpace > spaceLeft ? (j > 0 && (result += "\n"), result += words[j] + " ", 
                                spaceLeft = this.style.wordWrapWidth - wordWidth) : (spaceLeft -= wordWidthWithSpace, 
                                result += words[j] + " ");
                            }
                            i < lines.length - 1 && (result += "\n");
                        }
                        return result;
                    }, Object.defineProperty(Phaser.Text.prototype, "angle", {
                        get: function() {
                            return Phaser.Math.radToDeg(this.rotation);
                        },
                        set: function(value) {
                            this.rotation = Phaser.Math.degToRad(value);
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "text", {
                        get: function() {
                            return this._text;
                        },
                        set: function(value) {
                            value !== this._text && (this._text = value.toString() || " ", this.dirty = !0, 
                            this.parent && this.updateTransform());
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "font", {
                        get: function() {
                            return this._font;
                        },
                        set: function(value) {
                            value !== this._font && (this._font = value.trim(), this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'", 
                            this.dirty = !0, this.parent && this.updateTransform());
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "fontSize", {
                        get: function() {
                            return this._fontSize;
                        },
                        set: function(value) {
                            value = parseInt(value, 10), value !== this._fontSize && (this._fontSize = value, 
                            this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'", 
                            this.dirty = !0, this.parent && this.updateTransform());
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "fontWeight", {
                        get: function() {
                            return this._fontWeight;
                        },
                        set: function(value) {
                            value !== this._fontWeight && (this._fontWeight = value, this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'", 
                            this.dirty = !0, this.parent && this.updateTransform());
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "fill", {
                        get: function() {
                            return this.style.fill;
                        },
                        set: function(value) {
                            value !== this.style.fill && (this.style.fill = value, this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "align", {
                        get: function() {
                            return this.style.align;
                        },
                        set: function(value) {
                            value !== this.style.align && (this.style.align = value, this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "stroke", {
                        get: function() {
                            return this.style.stroke;
                        },
                        set: function(value) {
                            value !== this.style.stroke && (this.style.stroke = value, this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "strokeThickness", {
                        get: function() {
                            return this.style.strokeThickness;
                        },
                        set: function(value) {
                            value !== this.style.strokeThickness && (this.style.strokeThickness = value, this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "wordWrap", {
                        get: function() {
                            return this.style.wordWrap;
                        },
                        set: function(value) {
                            value !== this.style.wordWrap && (this.style.wordWrap = value, this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "wordWrapWidth", {
                        get: function() {
                            return this.style.wordWrapWidth;
                        },
                        set: function(value) {
                            value !== this.style.wordWrapWidth && (this.style.wordWrapWidth = value, this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "lineSpacing", {
                        get: function() {
                            return this._lineSpacing;
                        },
                        set: function(value) {
                            value !== this._lineSpacing && (this._lineSpacing = parseFloat(value), this.dirty = !0, 
                            this.parent && this.updateTransform());
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "shadowOffsetX", {
                        get: function() {
                            return this.style.shadowOffsetX;
                        },
                        set: function(value) {
                            value !== this.style.shadowOffsetX && (this.style.shadowOffsetX = value, this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "shadowOffsetY", {
                        get: function() {
                            return this.style.shadowOffsetY;
                        },
                        set: function(value) {
                            value !== this.style.shadowOffsetY && (this.style.shadowOffsetY = value, this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "shadowColor", {
                        get: function() {
                            return this.style.shadowColor;
                        },
                        set: function(value) {
                            value !== this.style.shadowColor && (this.style.shadowColor = value, this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "shadowBlur", {
                        get: function() {
                            return this.style.shadowBlur;
                        },
                        set: function(value) {
                            value !== this.style.shadowBlur && (this.style.shadowBlur = value, this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "inputEnabled", {
                        get: function() {
                            return this.input && this.input.enabled;
                        },
                        set: function(value) {
                            value ? null === this.input ? (this.input = new Phaser.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop();
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "fixedToCamera", {
                        get: function() {
                            return !!this._cache[7];
                        },
                        set: function(value) {
                            value ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0;
                        }
                    }), Object.defineProperty(Phaser.Text.prototype, "destroyPhase", {
                        get: function() {
                            return !!this._cache[8];
                        }
                    }), Phaser.BitmapText = function(game, x, y, font, text, size) {
                        x = x || 0, y = y || 0, font = font || "", text = text || "", size = size || 32, 
                        this.game = game, this.exists = !0, this.name = "", this.type = Phaser.BITMAPTEXT, 
                        this.z = 0, this.world = new Phaser.Point(x, y), this._text = text, this._font = font, 
                        this._fontSize = size, this._align = "left", this._tint = 16777215, this.events = new Phaser.Events(this), 
                        this.input = null, this.cameraOffset = new Phaser.Point(), PIXI.BitmapText.call(this, text), 
                        this.position.set(x, y), this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
                    }, Phaser.BitmapText.prototype = Object.create(PIXI.BitmapText.prototype), Phaser.BitmapText.prototype.constructor = Phaser.BitmapText, 
                    Phaser.BitmapText.prototype.setStyle = function() {
                        this.style = {
                            align: this._align
                        }, this.fontName = this._font, this.fontSize = this._fontSize, this.dirty = !0;
                    }, Phaser.BitmapText.prototype.preUpdate = function() {
                        return this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, 
                        this.exists && this.parent.exists ? (this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this.getBounds())), 
                        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), 
                        this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++), !0) : (this.renderOrderID = -1, 
                        !1);
                    }, Phaser.BitmapText.prototype.update = function() {}, Phaser.BitmapText.prototype.postUpdate = function() {
                        1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, 
                        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
                    }, Phaser.BitmapText.prototype.destroy = function(destroyChildren) {
                        if (null !== this.game && !this.destroyPhase) {
                            "undefined" == typeof destroyChildren && (destroyChildren = !0), this._cache[8] = 1, 
                            this.parent && (this.parent instanceof Phaser.Group ? this.parent.remove(this) : this.parent.removeChild(this));
                            var i = this.children.length;
                            if (destroyChildren) for (;i--; ) this.children[i].destroy ? this.children[i].destroy(destroyChildren) : this.removeChild(this.children[i]); else for (;i--; ) this.removeChild(this.children[i]);
                            this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, 
                            this._cache[8] = 0;
                        }
                    }, Object.defineProperty(Phaser.BitmapText.prototype, "align", {
                        get: function() {
                            return this._align;
                        },
                        set: function(value) {
                            value !== this._align && (this._align = value, this.setStyle());
                        }
                    }), Object.defineProperty(Phaser.BitmapText.prototype, "tint", {
                        get: function() {
                            return this._tint;
                        },
                        set: function(value) {
                            value !== this._tint && (this._tint = value, this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.BitmapText.prototype, "angle", {
                        get: function() {
                            return Phaser.Math.radToDeg(this.rotation);
                        },
                        set: function(value) {
                            this.rotation = Phaser.Math.degToRad(value);
                        }
                    }), Object.defineProperty(Phaser.BitmapText.prototype, "font", {
                        get: function() {
                            return this._font;
                        },
                        set: function(value) {
                            value !== this._font && (this._font = value.trim(), this.style.font = this._fontSize + "px '" + this._font + "'", 
                            this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.BitmapText.prototype, "fontSize", {
                        get: function() {
                            return this._fontSize;
                        },
                        set: function(value) {
                            value = parseInt(value, 10), value !== this._fontSize && (this._fontSize = value, 
                            this.style.font = this._fontSize + "px '" + this._font + "'", this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.BitmapText.prototype, "text", {
                        get: function() {
                            return this._text;
                        },
                        set: function(value) {
                            value !== this._text && (this._text = value.toString() || " ", this.dirty = !0);
                        }
                    }), Object.defineProperty(Phaser.BitmapText.prototype, "inputEnabled", {
                        get: function() {
                            return this.input && this.input.enabled;
                        },
                        set: function(value) {
                            value ? null === this.input ? (this.input = new Phaser.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop();
                        }
                    }), Object.defineProperty(Phaser.BitmapText.prototype, "fixedToCamera", {
                        get: function() {
                            return !!this._cache[7];
                        },
                        set: function(value) {
                            value ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0;
                        }
                    }), Object.defineProperty(Phaser.BitmapText.prototype, "destroyPhase", {
                        get: function() {
                            return !!this._cache[8];
                        }
                    }), Phaser.Button = function(game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) {
                        x = x || 0, y = y || 0, key = key || null, callback = callback || null, callbackContext = callbackContext || this, 
                        Phaser.Image.call(this, game, x, y, key, outFrame), this.type = Phaser.BUTTON, this._onOverFrame = null, 
                        this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, 
                        this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", 
                        this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", 
                        this.onInputOver = new Phaser.Signal(), this.onInputOut = new Phaser.Signal(), this.onInputDown = new Phaser.Signal(), 
                        this.onInputUp = new Phaser.Signal(), this.onOverMouseOnly = !1, this.freezeFrames = !1, 
                        this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.setFrames(overFrame, outFrame, downFrame, upFrame), 
                        null !== callback && this.onInputUp.add(callback, callbackContext), this.events.onInputOver.add(this.onInputOverHandler, this), 
                        this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), 
                        this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this);
                    }, Phaser.Button.prototype = Object.create(Phaser.Image.prototype), Phaser.Button.prototype.constructor = Phaser.Button;
                    var STATE_OVER = "Over", STATE_OUT = "Out", STATE_DOWN = "Down", STATE_UP = "Up";
                    Phaser.Button.prototype.clearFrames = function() {
                        this.setFrames(null, null, null, null);
                    }, Phaser.Button.prototype.removedFromWorld = function() {
                        this.inputEnabled = !1;
                    }, Phaser.Button.prototype.setStateFrame = function(state, frame, switchImmediately) {
                        var frameKey = "_on" + state + "Frame";
                        null != frame ? (this[frameKey] = frame, switchImmediately && this.changeStateFrame(state)) : this[frameKey] = null;
                    }, Phaser.Button.prototype.changeStateFrame = function(state) {
                        if (this.freezeFrames) return !1;
                        var frameKey = "_on" + state + "Frame", frame = this[frameKey];
                        return "string" == typeof frame ? (this.frameName = frame, !0) : "number" == typeof frame ? (this.frame = frame, 
                        !0) : !1;
                    }, Phaser.Button.prototype.setFrames = function(overFrame, outFrame, downFrame, upFrame) {
                        this.setStateFrame(STATE_OVER, overFrame, this.input.pointerOver()), this.setStateFrame(STATE_OUT, outFrame, !this.input.pointerOver()), 
                        this.setStateFrame(STATE_DOWN, downFrame, this.input.pointerDown()), this.setStateFrame(STATE_UP, upFrame, this.input.pointerUp());
                    }, Phaser.Button.prototype.setStateSound = function(state, sound, marker) {
                        var soundKey = "on" + state + "Sound", markerKey = "on" + state + "SoundMarker";
                        sound instanceof Phaser.Sound || sound instanceof Phaser.AudioSprite ? (this[soundKey] = sound, 
                        this[markerKey] = "string" == typeof marker ? marker : "") : (this[soundKey] = null, 
                        this[markerKey] = "");
                    }, Phaser.Button.prototype.playStateSound = function(state) {
                        var soundKey = "on" + state + "Sound", sound = this[soundKey];
                        if (sound) {
                            var markerKey = "on" + state + "SoundMarker", marker = this[markerKey];
                            return sound.play(marker), !0;
                        }
                        return !1;
                    }, Phaser.Button.prototype.setSounds = function(overSound, overMarker, downSound, downMarker, outSound, outMarker, upSound, upMarker) {
                        this.setStateSound(STATE_OVER, overSound, overMarker), this.setStateSound(STATE_OUT, outSound, outMarker), 
                        this.setStateSound(STATE_DOWN, downSound, downMarker), this.setStateSound(STATE_UP, upSound, upMarker);
                    }, Phaser.Button.prototype.setOverSound = function(sound, marker) {
                        this.setStateSound(STATE_OVER, sound, marker);
                    }, Phaser.Button.prototype.setOutSound = function(sound, marker) {
                        this.setStateSound(STATE_OUT, sound, marker);
                    }, Phaser.Button.prototype.setDownSound = function(sound, marker) {
                        this.setStateSound(STATE_DOWN, sound, marker);
                    }, Phaser.Button.prototype.setUpSound = function(sound, marker) {
                        this.setStateSound(STATE_UP, sound, marker);
                    }, Phaser.Button.prototype.onInputOverHandler = function(sprite, pointer) {
                        pointer.justReleased() || (this.changeStateFrame(STATE_OVER), (!this.onOverMouseOnly || pointer.isMouse) && (this.playStateSound(STATE_OVER), 
                        this.onInputOver && this.onInputOver.dispatch(this, pointer)));
                    }, Phaser.Button.prototype.onInputOutHandler = function(sprite, pointer) {
                        this.changeStateFrame(STATE_OUT), this.playStateSound(STATE_OUT), this.onInputOut && this.onInputOut.dispatch(this, pointer);
                    }, Phaser.Button.prototype.onInputDownHandler = function(sprite, pointer) {
                        this.changeStateFrame(STATE_DOWN), this.playStateSound(STATE_DOWN), this.onInputDown && this.onInputDown.dispatch(this, pointer);
                    }, Phaser.Button.prototype.onInputUpHandler = function(sprite, pointer, isOver) {
                        if (this.playStateSound(STATE_UP), this.onInputUp && this.onInputUp.dispatch(this, pointer, isOver), 
                        !this.freezeFrames) if (this.forceOut) this.changeStateFrame(STATE_OUT); else {
                            var changedUp = this.changeStateFrame(STATE_UP);
                            changedUp || this.changeStateFrame(isOver ? STATE_OVER : STATE_OUT);
                        }
                    }, Phaser.Graphics = function(game, x, y) {
                        x = x || 0, y = y || 0, this.game = game, this.exists = !0, this.name = "", this.type = Phaser.GRAPHICS, 
                        this.z = 0, this.world = new Phaser.Point(x, y), this.cameraOffset = new Phaser.Point(), 
                        PIXI.Graphics.call(this), this.position.set(x, y), this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
                    }, Phaser.Graphics.prototype = Object.create(PIXI.Graphics.prototype), Phaser.Graphics.prototype.constructor = Phaser.Graphics, 
                    Phaser.Graphics.prototype.preUpdate = function() {
                        return this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, 
                        this.exists && this.parent.exists ? (this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this.getBounds())), 
                        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), 
                        this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++), !0) : (this.renderOrderID = -1, 
                        !1);
                    }, Phaser.Graphics.prototype.update = function() {}, Phaser.Graphics.prototype.postUpdate = function() {
                        1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, 
                        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
                    }, Phaser.Graphics.prototype.destroy = function(destroyChildren) {
                        if (null !== this.game && !this.destroyPhase) {
                            "undefined" == typeof destroyChildren && (destroyChildren = !0), this._cache[8] = 1, 
                            this.clear(), this.parent && (this.parent instanceof Phaser.Group ? this.parent.remove(this) : this.parent.removeChild(this));
                            var i = this.children.length;
                            if (destroyChildren) for (;i--; ) this.children[i].destroy(destroyChildren); else for (;i--; ) this.removeChild(this.children[i]);
                            this.exists = !1, this.visible = !1, this.game = null, this._cache[8] = 0;
                        }
                    }, Phaser.Graphics.prototype.drawCircle = function(x, y, diameter) {
                        return this.drawShape(new Phaser.Circle(x, y, diameter)), this;
                    }, Phaser.Graphics.prototype.drawTriangle = function(points, cull) {
                        "undefined" == typeof cull && (cull = !1);
                        var triangle = new Phaser.Polygon(points);
                        if (cull) {
                            var cameraToFace = new Phaser.Point(this.game.camera.x - points[0].x, this.game.camera.y - points[0].y), ab = new Phaser.Point(points[1].x - points[0].x, points[1].y - points[0].y), cb = new Phaser.Point(points[1].x - points[2].x, points[1].y - points[2].y), faceNormal = cb.cross(ab);
                            cameraToFace.dot(faceNormal) > 0 && this.drawPolygon(triangle);
                        } else this.drawPolygon(triangle);
                    }, Phaser.Graphics.prototype.drawTriangles = function(vertices, indices, cull) {
                        "undefined" == typeof cull && (cull = !1);
                        var i, point1 = new Phaser.Point(), point2 = new Phaser.Point(), point3 = new Phaser.Point(), points = [];
                        if (indices) if (vertices[0] instanceof Phaser.Point) for (i = 0; i < indices.length / 3; i++) points.push(vertices[indices[3 * i]]), 
                        points.push(vertices[indices[3 * i + 1]]), points.push(vertices[indices[3 * i + 2]]), 
                        3 === points.length && (this.drawTriangle(points, cull), points = []); else for (i = 0; i < indices.length; i++) point1.x = vertices[2 * indices[i]], 
                        point1.y = vertices[2 * indices[i] + 1], points.push(point1.copyTo({})), 3 === points.length && (this.drawTriangle(points, cull), 
                        points = []); else if (vertices[0] instanceof Phaser.Point) for (i = 0; i < vertices.length / 3; i++) this.drawTriangle([ vertices[3 * i], vertices[3 * i + 1], vertices[3 * i + 2] ], cull); else for (i = 0; i < vertices.length / 6; i++) point1.x = vertices[6 * i + 0], 
                        point1.y = vertices[6 * i + 1], point2.x = vertices[6 * i + 2], point2.y = vertices[6 * i + 3], 
                        point3.x = vertices[6 * i + 4], point3.y = vertices[6 * i + 5], this.drawTriangle([ point1, point2, point3 ], cull);
                    }, Object.defineProperty(Phaser.Graphics.prototype, "angle", {
                        get: function() {
                            return Phaser.Math.radToDeg(this.rotation);
                        },
                        set: function(value) {
                            this.rotation = Phaser.Math.degToRad(value);
                        }
                    }), Object.defineProperty(Phaser.Graphics.prototype, "fixedToCamera", {
                        get: function() {
                            return !!this._cache[7];
                        },
                        set: function(value) {
                            value ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0;
                        }
                    }), Object.defineProperty(Phaser.Graphics.prototype, "destroyPhase", {
                        get: function() {
                            return !!this._cache[8];
                        }
                    }), Phaser.RenderTexture = function(game, width, height, key, scaleMode, resolution) {
                        "undefined" == typeof key && (key = ""), "undefined" == typeof scaleMode && (scaleMode = Phaser.scaleModes.DEFAULT), 
                        "undefined" == typeof resolution && (resolution = 1), this.game = game, this.key = key, 
                        this.type = Phaser.RENDERTEXTURE, this.matrix = new PIXI.Matrix(), PIXI.RenderTexture.call(this, width, height, this.game.renderer, scaleMode, resolution), 
                        this.render = Phaser.RenderTexture.prototype.render;
                    }, Phaser.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype), 
                    Phaser.RenderTexture.prototype.constructor = Phaser.RenderTexture, Phaser.RenderTexture.prototype.renderXY = function(displayObject, x, y, clear) {
                        this.matrix.tx = x, this.matrix.ty = y, this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(displayObject, this.matrix, clear) : this.renderCanvas(displayObject, this.matrix, clear);
                    }, Phaser.RenderTexture.prototype.render = function(displayObject, position, clear) {
                        this.matrix.tx = position.x, this.matrix.ty = position.y, this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(displayObject, this.matrix, clear) : this.renderCanvas(displayObject, this.matrix, clear);
                    }, Phaser.SpriteBatch = function(game, parent, name, addToStage) {
                        ("undefined" == typeof parent || null === parent) && (parent = game.world), PIXI.SpriteBatch.call(this), 
                        Phaser.Group.call(this, game, parent, name, addToStage), this.type = Phaser.SPRITEBATCH;
                    }, Phaser.SpriteBatch.prototype = Phaser.Utils.extend(!0, Phaser.SpriteBatch.prototype, Phaser.Group.prototype, PIXI.SpriteBatch.prototype), 
                    Phaser.SpriteBatch.prototype.constructor = Phaser.SpriteBatch, Phaser.RetroFont = function(game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
                        if (!game.cache.checkImageKey(key)) return !1;
                        ("undefined" == typeof charsPerRow || null === charsPerRow) && (charsPerRow = game.cache.getImage(key).width / characterWidth), 
                        this.characterWidth = characterWidth, this.characterHeight = characterHeight, this.characterSpacingX = xSpacing || 0, 
                        this.characterSpacingY = ySpacing || 0, this.characterPerRow = charsPerRow, this.offsetX = xOffset || 0, 
                        this.offsetY = yOffset || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, 
                        this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = game.cache.getImage(key), 
                        this._text = "", this.grabData = [], this.frameData = new Phaser.FrameData();
                        for (var currentX = this.offsetX, currentY = this.offsetY, r = 0, c = 0; c < chars.length; c++) {
                            var uuid = game.rnd.uuid(), frame = this.frameData.addFrame(new Phaser.Frame(c, currentX, currentY, this.characterWidth, this.characterHeight, "", uuid));
                            this.grabData[chars.charCodeAt(c)] = frame.index, PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[key], {
                                x: currentX,
                                y: currentY,
                                width: this.characterWidth,
                                height: this.characterHeight
                            }), r++, r == this.characterPerRow ? (r = 0, currentX = this.offsetX, currentY += this.characterHeight + this.characterSpacingY) : currentX += this.characterWidth + this.characterSpacingX;
                        }
                        game.cache.updateFrameData(key, this.frameData), this.stamp = new Phaser.Image(game, 0, 0, key, 0), 
                        Phaser.RenderTexture.call(this, game, 100, 100, "", Phaser.scaleModes.NEAREST), 
                        this.type = Phaser.RETROFONT;
                    }, Phaser.RetroFont.prototype = Object.create(Phaser.RenderTexture.prototype), Phaser.RetroFont.prototype.constructor = Phaser.RetroFont, 
                    Phaser.RetroFont.ALIGN_LEFT = "left", Phaser.RetroFont.ALIGN_RIGHT = "right", Phaser.RetroFont.ALIGN_CENTER = "center", 
                    Phaser.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", 
                    Phaser.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", 
                    Phaser.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", Phaser.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", 
                    Phaser.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", 
                    Phaser.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", 
                    Phaser.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", 
                    Phaser.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", Phaser.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", 
                    Phaser.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", Phaser.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", 
                    Phaser.RetroFont.prototype.setFixedWidth = function(width, lineAlignment) {
                        "undefined" == typeof lineAlignment && (lineAlignment = "left"), this.fixedWidth = width, 
                        this.align = lineAlignment;
                    }, Phaser.RetroFont.prototype.setText = function(content, multiLine, characterSpacing, lineSpacing, lineAlignment, allowLowerCase) {
                        this.multiLine = multiLine || !1, this.customSpacingX = characterSpacing || 0, this.customSpacingY = lineSpacing || 0, 
                        this.align = lineAlignment || "left", this.autoUpperCase = allowLowerCase ? !1 : !0, 
                        content.length > 0 && (this.text = content);
                    }, Phaser.RetroFont.prototype.buildRetroFontText = function() {
                        var cx = 0, cy = 0;
                        if (this.clear(), this.multiLine) {
                            var lines = this._text.split("\n");
                            this.fixedWidth > 0 ? this.resize(this.fixedWidth, lines.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), lines.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
                            for (var i = 0; i < lines.length; i++) {
                                switch (this.align) {
                                  case Phaser.RetroFont.ALIGN_LEFT:
                                    cx = 0;
                                    break;

                                  case Phaser.RetroFont.ALIGN_RIGHT:
                                    cx = this.width - lines[i].length * (this.characterWidth + this.customSpacingX);
                                    break;

                                  case Phaser.RetroFont.ALIGN_CENTER:
                                    cx = this.width / 2 - lines[i].length * (this.characterWidth + this.customSpacingX) / 2, 
                                    cx += this.customSpacingX / 2;
                                }
                                0 > cx && (cx = 0), this.pasteLine(lines[i], cx, cy, this.customSpacingX), cy += this.characterHeight + this.customSpacingY;
                            }
                        } else {
                            switch (this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), 
                            this.align) {
                              case Phaser.RetroFont.ALIGN_LEFT:
                                cx = 0;
                                break;

                              case Phaser.RetroFont.ALIGN_RIGHT:
                                cx = this.width - this._text.length * (this.characterWidth + this.customSpacingX);
                                break;

                              case Phaser.RetroFont.ALIGN_CENTER:
                                cx = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, 
                                cx += this.customSpacingX / 2;
                            }
                            this.textureBuffer.clear(), this.pasteLine(this._text, cx, 0, this.customSpacingX);
                        }
                    }, Phaser.RetroFont.prototype.pasteLine = function(line, x, y, customSpacingX) {
                        for (var p = new Phaser.Point(), c = 0; c < line.length; c++) if (" " == line.charAt(c)) x += this.characterWidth + customSpacingX; else if (this.grabData[line.charCodeAt(c)] >= 0 && (this.stamp.frame = this.grabData[line.charCodeAt(c)], 
                        p.set(x, y), this.render(this.stamp, p, !1), x += this.characterWidth + customSpacingX, 
                        x > this.width)) break;
                    }, Phaser.RetroFont.prototype.getLongestLine = function() {
                        var longestLine = 0;
                        if (this._text.length > 0) for (var lines = this._text.split("\n"), i = 0; i < lines.length; i++) lines[i].length > longestLine && (longestLine = lines[i].length);
                        return longestLine;
                    }, Phaser.RetroFont.prototype.removeUnsupportedCharacters = function(stripCR) {
                        for (var newString = "", c = 0; c < this._text.length; c++) {
                            var aChar = this._text[c], code = aChar.charCodeAt(0);
                            (this.grabData[code] >= 0 || !stripCR && "\n" === aChar) && (newString = newString.concat(aChar));
                        }
                        return newString;
                    }, Phaser.RetroFont.prototype.updateOffset = function(x, y) {
                        if (this.offsetX !== x || this.offsetY !== y) {
                            for (var diffX = x - this.offsetX, diffY = y - this.offsetY, frames = this.game.cache.getFrameData(this.stamp.key).getFrames(), i = frames.length; i--; ) frames[i].x += diffX, 
                            frames[i].y += diffY, PIXI.TextureCache[frames[i].uuid].frame.x = frames[i].x, PIXI.TextureCache[frames[i].uuid].frame.y = frames[i].y;
                            this.buildRetroFontText();
                        }
                    }, Object.defineProperty(Phaser.RetroFont.prototype, "text", {
                        get: function() {
                            return this._text;
                        },
                        set: function(value) {
                            var newText;
                            newText = this.autoUpperCase ? value.toUpperCase() : value, newText !== this._text && (this._text = newText, 
                            this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText());
                        }
                    }), Object.defineProperty(Phaser.RetroFont.prototype, "smoothed", {
                        get: function() {
                            return this.stamp.smoothed;
                        },
                        set: function(value) {
                            this.stamp.smoothed = value, this.buildRetroFontText();
                        }
                    }), Phaser.Particle = function(game, x, y, key, frame) {
                        Phaser.Sprite.call(this, game, x, y, key, frame), this.autoScale = !1, this.scaleData = null, 
                        this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0;
                    }, Phaser.Particle.prototype = Object.create(Phaser.Sprite.prototype), Phaser.Particle.prototype.constructor = Phaser.Particle, 
                    Phaser.Particle.prototype.update = function() {
                        this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), 
                        this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1);
                    }, Phaser.Particle.prototype.onEmit = function() {}, Phaser.Particle.prototype.setAlphaData = function(data) {
                        this.alphaData = data, this._a = data.length - 1, this.alpha = this.alphaData[this._a].v, 
                        this.autoAlpha = !0;
                    }, Phaser.Particle.prototype.setScaleData = function(data) {
                        this.scaleData = data, this._s = data.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), 
                        this.autoScale = !0;
                    }, Phaser.Particle.prototype.reset = function(x, y, health) {
                        return "undefined" == typeof health && (health = 1), this.world.setTo(x, y), this.position.x = x, 
                        this.position.y = y, this.alive = !0, this.exists = !0, this.visible = !0, this.renderable = !0, 
                        this._outOfBoundsFired = !1, this.health = health, this.body && this.body.reset(x, y, !1, !1), 
                        this._cache[4] = 1, this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, 
                        this;
                    }, Phaser.Device = function() {
                        this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, 
                        this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, 
                        this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, 
                        this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, 
                        this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, 
                        this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, 
                        this.getUserMedia = !1, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, 
                        this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.epiphany = !1, this.firefox = !1, 
                        this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.mobileSafari = !1, 
                        this.midori = !1, this.opera = !1, this.safari = !1, this.webApp = !1, this.silk = !1, 
                        this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, 
                        this.wav = !1, this.m4a = !1, this.webm = !1, this.iPhone = !1, this.iPhone4 = !1, 
                        this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, 
                        this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", 
                        this.fullscreenKeyboard = !1;
                    }, Phaser.Device = new Phaser.Device(), Phaser.Device.onInitialized = new Phaser.Signal(), 
                    Phaser.Device.whenReady = function(callback, context, nonPrimer) {
                        var readyCheck = this._readyCheck;
                        if (this.deviceReadyAt || !readyCheck) callback.call(context, this); else if (readyCheck._monitor || nonPrimer) readyCheck._queue = readyCheck._queue || [], 
                        readyCheck._queue.push([ callback, context ]); else {
                            readyCheck._monitor = readyCheck.bind(this), readyCheck._queue = readyCheck._queue || [], 
                            readyCheck._queue.push([ callback, context ]);
                            var cordova = "undefined" != typeof window.cordova, cocoonJS = navigator.isCocoonJS;
                            "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(readyCheck._monitor, 0) : cordova && !cocoonJS ? document.addEventListener("deviceready", readyCheck._monitor, !1) : (document.addEventListener("DOMContentLoaded", readyCheck._monitor, !1), 
                            window.addEventListener("load", readyCheck._monitor, !1));
                        }
                    }, Phaser.Device._readyCheck = function() {
                        var readyCheck = this._readyCheck;
                        if (document.body) {
                            if (!this.deviceReadyAt) {
                                this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", readyCheck._monitor), 
                                document.removeEventListener("DOMContentLoaded", readyCheck._monitor), window.removeEventListener("load", readyCheck._monitor), 
                                this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this);
                                for (var item; item = readyCheck._queue.shift(); ) {
                                    var callback = item[0], context = item[1];
                                    callback.call(context, this);
                                }
                                this._readyCheck = null, this._initialize = null, this.onInitialized = null;
                            }
                        } else window.setTimeout(readyCheck._monitor, 20);
                    }, Phaser.Device._initialize = function() {
                        function _checkOS() {
                            var ua = navigator.userAgent;
                            /Playstation Vita/.test(ua) ? device.vita = !0 : /Kindle/.test(ua) || /\bKF[A-Z][A-Z]+/.test(ua) || /Silk.*Mobile Safari/.test(ua) ? device.kindle = !0 : /Android/.test(ua) ? device.android = !0 : /CrOS/.test(ua) ? device.chromeOS = !0 : /iP[ao]d|iPhone/i.test(ua) ? device.iOS = !0 : /Linux/.test(ua) ? device.linux = !0 : /Mac OS/.test(ua) ? device.macOS = !0 : /Windows/.test(ua) && (device.windows = !0, 
                            /Windows Phone/i.test(ua) && (device.windowsPhone = !0));
                            var silk = /Silk/.test(ua);
                            (device.windows || device.macOS || device.linux && !silk || device.chromeOS) && (device.desktop = !0), 
                            (device.windowsPhone || /Windows NT/i.test(ua) && /Touch/i.test(ua)) && (device.desktop = !1);
                        }
                        function _checkFeatures() {
                            device.canvas = !!window.CanvasRenderingContext2D || device.cocoonJS;
                            try {
                                device.localStorage = !!localStorage.getItem;
                            } catch (error) {
                                device.localStorage = !1;
                            }
                            device.file = !!(window.File && window.FileReader && window.FileList && window.Blob), 
                            device.fileSystem = !!window.requestFileSystem, device.webGL = function() {
                                try {
                                    var canvas = document.createElement("canvas");
                                    return canvas.screencanvas = !1, !!window.WebGLRenderingContext && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
                                } catch (e) {
                                    return !1;
                                }
                            }(), device.webGL = !!device.webGL, device.worker = !!window.Worker, device.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, 
                            device.quirksMode = "CSS1Compat" === document.compatMode ? !1 : !0, device.getUserMedia = !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia), 
                            !device.iOS && (device.ie || device.firefox || device.chrome) && (device.canvasBitBltShift = !0), 
                            (device.safari || device.mobileSafari) && (device.canvasBitBltShift = !1);
                        }
                        function _checkInput() {
                            ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints > 1) && (device.touch = !0), 
                            (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (device.mspointer = !0), 
                            device.cocoonJS || ("onwheel" in window || device.ie && "WheelEvent" in window ? device.wheelEvent = "wheel" : "onmousewheel" in window ? device.wheelEvent = "mousewheel" : device.firefox && "MouseScrollEvent" in window && (device.wheelEvent = "DOMMouseScroll"));
                        }
                        function _checkFullScreenSupport() {
                            for (var fs = [ "requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen" ], element = document.createElement("div"), i = 0; i < fs.length; i++) if (element[fs[i]]) {
                                device.fullscreen = !0, device.requestFullscreen = fs[i];
                                break;
                            }
                            var cfs = [ "cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen" ];
                            if (device.fullscreen) for (var i = 0; i < cfs.length; i++) if (document[cfs[i]]) {
                                device.cancelFullscreen = cfs[i];
                                break;
                            }
                            window.Element && Element.ALLOW_KEYBOARD_INPUT && (device.fullscreenKeyboard = !0);
                        }
                        function _checkBrowser() {
                            var ua = navigator.userAgent;
                            if (/Arora/.test(ua) ? device.arora = !0 : /Chrome/.test(ua) ? device.chrome = !0 : /Epiphany/.test(ua) ? device.epiphany = !0 : /Firefox/.test(ua) ? device.firefox = !0 : /AppleWebKit/.test(ua) && device.iOS ? device.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(ua) ? (device.ie = !0, 
                            device.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(ua) ? device.midori = !0 : /Opera/.test(ua) ? device.opera = !0 : /Safari/.test(ua) ? device.safari = !0 : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(ua) && (device.ie = !0, 
                            device.trident = !0, device.tridentVersion = parseInt(RegExp.$1, 10), device.ieVersion = parseInt(RegExp.$3, 10)), 
                            /Silk/.test(ua) && (device.silk = !0), navigator.standalone && (device.webApp = !0), 
                            "undefined" != typeof window.cordova && (device.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (device.node = !0), 
                            device.node) try {
                                device.nodeWebkit = "undefined" != typeof __browserify_shim_require__("nw.gui");
                            } catch (error) {
                                device.nodeWebkit = !1;
                            }
                            if (navigator.isCocoonJS && (device.cocoonJS = !0), device.cocoonJS) try {
                                device.cocoonJSApp = "undefined" != typeof CocoonJS;
                            } catch (error) {
                                device.cocoonJSApp = !1;
                            }
                            "undefined" != typeof window.ejecta && (device.ejecta = !0), /Crosswalk/.test(ua) && (device.crosswalk = !0);
                        }
                        function _checkAudio() {
                            device.audioData = !!window.Audio, device.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                            var audioElement = document.createElement("audio"), result = !1;
                            try {
                                (result = !!audioElement.canPlayType) && (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (device.ogg = !0), 
                                (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || audioElement.canPlayType("audio/opus;").replace(/^no$/, "")) && (device.opus = !0), 
                                audioElement.canPlayType("audio/mpeg;").replace(/^no$/, "") && (device.mp3 = !0), 
                                audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (device.wav = !0), 
                                (audioElement.canPlayType("audio/x-m4a;") || audioElement.canPlayType("audio/aac;").replace(/^no$/, "")) && (device.m4a = !0), 
                                audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (device.webm = !0));
                            } catch (e) {}
                        }
                        function _checkDevice() {
                            device.pixelRatio = window.devicePixelRatio || 1, device.iPhone = -1 != navigator.userAgent.toLowerCase().indexOf("iphone"), 
                            device.iPhone4 = 2 == device.pixelRatio && device.iPhone, device.iPad = -1 != navigator.userAgent.toLowerCase().indexOf("ipad"), 
                            device.typedArray = "undefined" != typeof Int8Array ? !0 : !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (device.littleEndian = _checkIsLittleEndian(), 
                            device.LITTLE_ENDIAN = device.littleEndian), device.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== device.littleEndian && _checkIsUint8ClampedImageData(), 
                            navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, 
                            navigator.vibrate && (device.vibration = !0);
                        }
                        function _checkIsLittleEndian() {
                            var a = new ArrayBuffer(4), b = new Uint8Array(a), c = new Uint32Array(a);
                            return b[0] = 161, b[1] = 178, b[2] = 195, b[3] = 212, 3569595041 == c[0] ? !0 : 2712847316 == c[0] ? !1 : null;
                        }
                        function _checkIsUint8ClampedImageData() {
                            if ("undefined" == typeof Uint8ClampedArray) return !1;
                            var elem = document.createElement("canvas"), ctx = elem.getContext("2d");
                            if (!ctx) return !1;
                            var image = ctx.createImageData(1, 1);
                            return image.data instanceof Uint8ClampedArray;
                        }
                        function _checkCSS3D() {
                            var has3d, el = document.createElement("p"), transforms = {
                                webkitTransform: "-webkit-transform",
                                OTransform: "-o-transform",
                                msTransform: "-ms-transform",
                                MozTransform: "-moz-transform",
                                transform: "transform"
                            };
                            document.body.insertBefore(el, null);
                            for (var t in transforms) void 0 !== el.style[t] && (el.style[t] = "translate3d(1px,1px,1px)", 
                            has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]));
                            document.body.removeChild(el), device.css3D = void 0 !== has3d && has3d.length > 0 && "none" !== has3d;
                        }
                        var device = this;
                        _checkOS(), _checkAudio(), _checkBrowser(), _checkCSS3D(), _checkDevice(), _checkFeatures(), 
                        _checkFullScreenSupport(), _checkInput();
                    }, Phaser.Device.canPlayAudio = function(type) {
                        return "mp3" == type && this.mp3 ? !0 : "ogg" == type && (this.ogg || this.opus) ? !0 : "m4a" == type && this.m4a ? !0 : "opus" == type && this.opus ? !0 : "wav" == type && this.wav ? !0 : "webm" == type && this.webm ? !0 : !1;
                    }, Phaser.Device.isConsoleOpen = function() {
                        return window.console && window.console.firebug ? !0 : window.console && (console.profile(), 
                        console.profileEnd(), console.clear && console.clear(), console.profiles) ? console.profiles.length > 0 : !1;
                    }, Phaser.Device.isAndroidStockBrowser = function() {
                        var matches = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
                        return matches && matches[1] < 537;
                    }, Phaser.DOM = {
                        getOffset: function(element, point) {
                            point = point || new Phaser.Point();
                            var box = element.getBoundingClientRect(), scrollTop = Phaser.DOM.scrollY, scrollLeft = Phaser.DOM.scrollX, clientTop = document.documentElement.clientTop, clientLeft = document.documentElement.clientLeft;
                            return point.x = box.left + scrollLeft - clientLeft, point.y = box.top + scrollTop - clientTop, 
                            point;
                        },
                        getBounds: function(element, cushion) {
                            return "undefined" == typeof cushion && (cushion = 0), element = element && !element.nodeType ? element[0] : element, 
                            element && 1 === element.nodeType ? this.calibrate(element.getBoundingClientRect(), cushion) : !1;
                        },
                        calibrate: function(coords, cushion) {
                            cushion = +cushion || 0;
                            var output = {
                                width: 0,
                                height: 0,
                                left: 0,
                                right: 0,
                                top: 0,
                                bottom: 0
                            };
                            return output.width = (output.right = coords.right + cushion) - (output.left = coords.left - cushion), 
                            output.height = (output.bottom = coords.bottom + cushion) - (output.top = coords.top - cushion), 
                            output;
                        },
                        getAspectRatio: function(object) {
                            object = null == object ? this.visualBounds : 1 === object.nodeType ? this.getBounds(object) : object;
                            var w = object.width, h = object.height;
                            return "function" == typeof w && (w = w.call(object)), "function" == typeof h && (h = h.call(object)), 
                            w / h;
                        },
                        inLayoutViewport: function(element, cushion) {
                            var r = this.getBounds(element, cushion);
                            return !!r && r.bottom >= 0 && r.right >= 0 && r.top <= this.layoutBounds.width && r.left <= this.layoutBounds.height;
                        },
                        getScreenOrientation: function(primaryFallback) {
                            var screen = window.screen, orientation = screen.orientation || screen.mozOrientation || screen.msOrientation;
                            if (orientation && "string" == typeof orientation.type) return orientation.type;
                            if ("string" == typeof orientation) return orientation;
                            var PORTRAIT = "portrait-primary", LANDSCAPE = "landscape-primary";
                            if ("screen" === primaryFallback) return screen.height > screen.width ? PORTRAIT : LANDSCAPE;
                            if ("viewport" === primaryFallback) return this.visualBounds.height > this.visualBounds.width ? PORTRAIT : LANDSCAPE;
                            if ("window.orientation" === primaryFallback && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? PORTRAIT : LANDSCAPE;
                            if (window.matchMedia) {
                                if (window.matchMedia("(orientation: portrait)").matches) return PORTRAIT;
                                if (window.matchMedia("(orientation: landscape)").matches) return LANDSCAPE;
                            }
                            return this.visualBounds.height > this.visualBounds.width ? PORTRAIT : LANDSCAPE;
                        },
                        visualBounds: new Phaser.Rectangle(),
                        layoutBounds: new Phaser.Rectangle(),
                        documentBounds: new Phaser.Rectangle()
                    }, Phaser.Device.whenReady(function(device) {
                        var scrollX = window && "pageXOffset" in window ? function() {
                            return window.pageXOffset;
                        } : function() {
                            return document.documentElement.scrollLeft;
                        }, scrollY = window && "pageYOffset" in window ? function() {
                            return window.pageYOffset;
                        } : function() {
                            return document.documentElement.scrollTop;
                        };
                        Object.defineProperty(Phaser.DOM, "scrollX", {
                            get: scrollX
                        }), Object.defineProperty(Phaser.DOM, "scrollY", {
                            get: scrollY
                        }), Object.defineProperty(Phaser.DOM.visualBounds, "x", {
                            get: scrollX
                        }), Object.defineProperty(Phaser.DOM.visualBounds, "y", {
                            get: scrollY
                        }), Object.defineProperty(Phaser.DOM.layoutBounds, "x", {
                            value: 0
                        }), Object.defineProperty(Phaser.DOM.layoutBounds, "y", {
                            value: 0
                        });
                        var treatAsDesktop = device.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight;
                        if (treatAsDesktop) {
                            var clientWidth = function() {
                                return Math.max(window.innerWidth, document.documentElement.clientWidth);
                            }, clientHeight = function() {
                                return Math.max(window.innerHeight, document.documentElement.clientHeight);
                            };
                            Object.defineProperty(Phaser.DOM.visualBounds, "width", {
                                get: clientWidth
                            }), Object.defineProperty(Phaser.DOM.visualBounds, "height", {
                                get: clientHeight
                            }), Object.defineProperty(Phaser.DOM.layoutBounds, "width", {
                                get: clientWidth
                            }), Object.defineProperty(Phaser.DOM.layoutBounds, "height", {
                                get: clientHeight
                            });
                        } else Object.defineProperty(Phaser.DOM.visualBounds, "width", {
                            get: function() {
                                return window.innerWidth;
                            }
                        }), Object.defineProperty(Phaser.DOM.visualBounds, "height", {
                            get: function() {
                                return window.innerHeight;
                            }
                        }), Object.defineProperty(Phaser.DOM.layoutBounds, "width", {
                            get: function() {
                                var a = document.documentElement.clientWidth, b = window.innerWidth;
                                return b > a ? b : a;
                            }
                        }), Object.defineProperty(Phaser.DOM.layoutBounds, "height", {
                            get: function() {
                                var a = document.documentElement.clientHeight, b = window.innerHeight;
                                return b > a ? b : a;
                            }
                        });
                        Object.defineProperty(Phaser.DOM.documentBounds, "x", {
                            value: 0
                        }), Object.defineProperty(Phaser.DOM.documentBounds, "y", {
                            value: 0
                        }), Object.defineProperty(Phaser.DOM.documentBounds, "width", {
                            get: function() {
                                var d = document.documentElement;
                                return Math.max(d.clientWidth, d.offsetWidth, d.scrollWidth);
                            }
                        }), Object.defineProperty(Phaser.DOM.documentBounds, "height", {
                            get: function() {
                                var d = document.documentElement;
                                return Math.max(d.clientHeight, d.offsetHeight, d.scrollHeight);
                            }
                        });
                    }, null, !0), Phaser.Canvas = {
                        create: function(width, height, id) {
                            width = width || 256, height = height || 256;
                            var canvas = document.createElement("canvas");
                            return "string" == typeof id && "" !== id && (canvas.id = id), canvas.width = width, 
                            canvas.height = height, canvas.style.display = "block", canvas;
                        },
                        setBackgroundColor: function(canvas, color) {
                            return color = color || "rgb(0,0,0)", canvas.style.backgroundColor = color, canvas;
                        },
                        setTouchAction: function(canvas, value) {
                            return value = value || "none", canvas.style.msTouchAction = value, canvas.style["ms-touch-action"] = value, 
                            canvas.style["touch-action"] = value, canvas;
                        },
                        setUserSelect: function(canvas, value) {
                            return value = value || "none", canvas.style["-webkit-touch-callout"] = value, canvas.style["-webkit-user-select"] = value, 
                            canvas.style["-khtml-user-select"] = value, canvas.style["-moz-user-select"] = value, 
                            canvas.style["-ms-user-select"] = value, canvas.style["user-select"] = value, canvas.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", 
                            canvas;
                        },
                        addToDOM: function(canvas, parent, overflowHidden) {
                            var target;
                            return "undefined" == typeof overflowHidden && (overflowHidden = !0), parent && ("string" == typeof parent ? target = document.getElementById(parent) : "object" == typeof parent && 1 === parent.nodeType && (target = parent)), 
                            target || (target = document.body), overflowHidden && target.style && (target.style.overflow = "hidden"), 
                            target.appendChild(canvas), canvas;
                        },
                        removeFromDOM: function(canvas) {
                            canvas.parentNode && canvas.parentNode.removeChild(canvas);
                        },
                        setTransform: function(context, translateX, translateY, scaleX, scaleY, skewX, skewY) {
                            return context.setTransform(scaleX, skewX, skewY, scaleY, translateX, translateY), 
                            context;
                        },
                        setSmoothingEnabled: function(context, value) {
                            return context.imageSmoothingEnabled = value, context.mozImageSmoothingEnabled = value, 
                            context.oImageSmoothingEnabled = value, context.webkitImageSmoothingEnabled = value, 
                            context.msImageSmoothingEnabled = value, context;
                        },
                        getSmoothingEnabled: function(context) {
                            return context.imageSmoothingEnabled || context.mozImageSmoothingEnabled || context.oImageSmoothingEnabled || context.webkitImageSmoothingEnabled || context.msImageSmoothingEnabled;
                        },
                        setImageRenderingCrisp: function(canvas) {
                            return canvas.style["image-rendering"] = "optimizeSpeed", canvas.style["image-rendering"] = "crisp-edges", 
                            canvas.style["image-rendering"] = "-moz-crisp-edges", canvas.style["image-rendering"] = "-webkit-optimize-contrast", 
                            canvas.style["image-rendering"] = "optimize-contrast", canvas.style["image-rendering"] = "pixelated", 
                            canvas.style.msInterpolationMode = "nearest-neighbor", canvas;
                        },
                        setImageRenderingBicubic: function(canvas) {
                            return canvas.style["image-rendering"] = "auto", canvas.style.msInterpolationMode = "bicubic", 
                            canvas;
                        }
                    }, Phaser.Canvas.getOffset = Phaser.DOM.getOffset, Phaser.Canvas.getAspectRatio = Phaser.DOM.getAspectRatio, 
                    Phaser.RequestAnimationFrame = function(game, forceSetTimeOut) {
                        "undefined" == typeof forceSetTimeOut && (forceSetTimeOut = !1), this.game = game, 
                        this.isRunning = !1, this.forceSetTimeOut = forceSetTimeOut;
                        for (var vendors = [ "ms", "moz", "webkit", "o" ], x = 0; x < vendors.length && !window.requestAnimationFrame; x++) window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"], 
                        window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"];
                        this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null;
                    }, Phaser.RequestAnimationFrame.prototype = {
                        start: function() {
                            this.isRunning = !0;
                            var _this = this;
                            !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, 
                            this._onLoop = function() {
                                return _this.updateSetTimeout();
                            }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, 
                            this._onLoop = function(time) {
                                return _this.updateRAF(time);
                            }, this._timeOutID = window.requestAnimationFrame(this._onLoop));
                        },
                        updateRAF: function(rafTime) {
                            this.game.update(Math.floor(rafTime)), this._timeOutID = window.requestAnimationFrame(this._onLoop);
                        },
                        updateSetTimeout: function() {
                            this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall);
                        },
                        stop: function() {
                            this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), 
                            this.isRunning = !1;
                        },
                        isSetTimeOut: function() {
                            return this._isSetTimeOut;
                        },
                        isRAF: function() {
                            return this._isSetTimeOut === !1;
                        }
                    }, Phaser.RequestAnimationFrame.prototype.constructor = Phaser.RequestAnimationFrame, 
                    Phaser.Math = {
                        PI2: 2 * Math.PI,
                        fuzzyEqual: function(a, b, epsilon) {
                            return "undefined" == typeof epsilon && (epsilon = 1e-4), Math.abs(a - b) < epsilon;
                        },
                        fuzzyLessThan: function(a, b, epsilon) {
                            return "undefined" == typeof epsilon && (epsilon = 1e-4), b + epsilon > a;
                        },
                        fuzzyGreaterThan: function(a, b, epsilon) {
                            return "undefined" == typeof epsilon && (epsilon = 1e-4), a > b - epsilon;
                        },
                        fuzzyCeil: function(val, epsilon) {
                            return "undefined" == typeof epsilon && (epsilon = 1e-4), Math.ceil(val - epsilon);
                        },
                        fuzzyFloor: function(val, epsilon) {
                            return "undefined" == typeof epsilon && (epsilon = 1e-4), Math.floor(val + epsilon);
                        },
                        average: function() {
                            for (var sum = 0, i = 0; i < arguments.length; i++) sum += +arguments[i];
                            return sum / arguments.length;
                        },
                        truncate: function(n) {
                            return Math.trunc(n);
                        },
                        shear: function(n) {
                            return n % 1;
                        },
                        snapTo: function(input, gap, start) {
                            return "undefined" == typeof start && (start = 0), 0 === gap ? input : (input -= start, 
                            input = gap * Math.round(input / gap), start + input);
                        },
                        snapToFloor: function(input, gap, start) {
                            return "undefined" == typeof start && (start = 0), 0 === gap ? input : (input -= start, 
                            input = gap * Math.floor(input / gap), start + input);
                        },
                        snapToCeil: function(input, gap, start) {
                            return "undefined" == typeof start && (start = 0), 0 === gap ? input : (input -= start, 
                            input = gap * Math.ceil(input / gap), start + input);
                        },
                        snapToInArray: function(input, arr, sort) {
                            return "undefined" == typeof sort && (sort = !0), sort && arr.sort(), Phaser.ArrayUtils.findClosest(input, arr);
                        },
                        roundTo: function(value, place, base) {
                            "undefined" == typeof place && (place = 0), "undefined" == typeof base && (base = 10);
                            var p = Math.pow(base, -place);
                            return Math.round(value * p) / p;
                        },
                        floorTo: function(value, place, base) {
                            "undefined" == typeof place && (place = 0), "undefined" == typeof base && (base = 10);
                            var p = Math.pow(base, -place);
                            return Math.floor(value * p) / p;
                        },
                        ceilTo: function(value, place, base) {
                            "undefined" == typeof place && (place = 0), "undefined" == typeof base && (base = 10);
                            var p = Math.pow(base, -place);
                            return Math.ceil(value * p) / p;
                        },
                        interpolateFloat: function(a, b, weight) {
                            return (b - a) * weight + a;
                        },
                        angleBetween: function(x1, y1, x2, y2) {
                            return Math.atan2(y2 - y1, x2 - x1);
                        },
                        angleBetweenY: function(x1, y1, x2, y2) {
                            return Math.atan2(x2 - x1, y2 - y1);
                        },
                        angleBetweenPoints: function(point1, point2) {
                            return Math.atan2(point2.y - point1.y, point2.x - point1.x);
                        },
                        angleBetweenPointsY: function(point1, point2) {
                            return Math.atan2(point2.x - point1.x, point2.y - point1.y);
                        },
                        reverseAngle: function(angleRad) {
                            return this.normalizeAngle(angleRad + Math.PI, !0);
                        },
                        normalizeAngle: function(angleRad) {
                            return angleRad %= 2 * Math.PI, angleRad >= 0 ? angleRad : angleRad + 2 * Math.PI;
                        },
                        normalizeLatitude: function(lat) {
                            return Phaser.Math.clamp(lat, -90, 90);
                        },
                        normalizeLongitude: function(lng) {
                            return Phaser.Math.wrap(lng, -180, 180);
                        },
                        chanceRoll: function(chance) {
                            return Phaser.Utils.chanceRoll(chance);
                        },
                        numberArray: function(start, end) {
                            return Phaser.ArrayUtils.numberArray(start, end);
                        },
                        numberArrayStep: function(start, end, step) {
                            return Phaser.ArrayUtils.numberArrayStep(start, end, step);
                        },
                        maxAdd: function(value, amount, max) {
                            return Math.min(value + amount, max);
                        },
                        minSub: function(value, amount, min) {
                            return Math.max(value - amount, min);
                        },
                        wrap: function(value, min, max) {
                            var range = max - min;
                            if (0 >= range) return 0;
                            var result = (value - min) % range;
                            return 0 > result && (result += range), result + min;
                        },
                        wrapValue: function(value, amount, max) {
                            var diff;
                            return value = Math.abs(value), amount = Math.abs(amount), max = Math.abs(max), 
                            diff = (value + amount) % max;
                        },
                        limitValue: function(value, min, max) {
                            return Phaser.Math.clamp(value, min, max);
                        },
                        randomSign: function() {
                            return Phaser.Utils.randomChoice(-1, 1);
                        },
                        isOdd: function(n) {
                            return 1 & n;
                        },
                        isEven: function(n) {
                            return !(1 & n);
                        },
                        min: function() {
                            if (1 === arguments.length && "object" == typeof arguments[0]) var data = arguments[0]; else var data = arguments;
                            for (var i = 1, min = 0, len = data.length; len > i; i++) data[i] < data[min] && (min = i);
                            return data[min];
                        },
                        max: function() {
                            if (1 === arguments.length && "object" == typeof arguments[0]) var data = arguments[0]; else var data = arguments;
                            for (var i = 1, max = 0, len = data.length; len > i; i++) data[i] > data[max] && (max = i);
                            return data[max];
                        },
                        minProperty: function(property) {
                            if (2 === arguments.length && "object" == typeof arguments[1]) var data = arguments[1]; else var data = arguments.slice(1);
                            for (var i = 1, min = 0, len = data.length; len > i; i++) data[i][property] < data[min][property] && (min = i);
                            return data[min][property];
                        },
                        maxProperty: function(property) {
                            if (2 === arguments.length && "object" == typeof arguments[1]) var data = arguments[1]; else var data = arguments.slice(1);
                            for (var i = 1, max = 0, len = data.length; len > i; i++) data[i][property] > data[max][property] && (max = i);
                            return data[max][property];
                        },
                        wrapAngle: function(angle, radians) {
                            return radians ? this.wrap(angle, -Math.PI, Math.PI) : this.wrap(angle, -180, 180);
                        },
                        angleLimit: function(angle, min, max) {
                            var result = angle;
                            return angle > max ? result = max : min > angle && (result = min), result;
                        },
                        linearInterpolation: function(v, k) {
                            var m = v.length - 1, f = m * k, i = Math.floor(f);
                            return 0 > k ? this.linear(v[0], v[1], f) : k > 1 ? this.linear(v[m], v[m - 1], m - f) : this.linear(v[i], v[i + 1 > m ? m : i + 1], f - i);
                        },
                        bezierInterpolation: function(v, k) {
                            for (var b = 0, n = v.length - 1, i = 0; n >= i; i++) b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * this.bernstein(n, i);
                            return b;
                        },
                        catmullRomInterpolation: function(v, k) {
                            var m = v.length - 1, f = m * k, i = Math.floor(f);
                            return v[0] === v[m] ? (0 > k && (i = Math.floor(f = m * (1 + k))), this.catmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i)) : 0 > k ? v[0] - (this.catmullRom(v[0], v[0], v[1], v[1], -f) - v[0]) : k > 1 ? v[m] - (this.catmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]) : this.catmullRom(v[i ? i - 1 : 0], v[i], v[i + 1 > m ? m : i + 1], v[i + 2 > m ? m : i + 2], f - i);
                        },
                        linear: function(p0, p1, t) {
                            return (p1 - p0) * t + p0;
                        },
                        bernstein: function(n, i) {
                            return this.factorial(n) / this.factorial(i) / this.factorial(n - i);
                        },
                        factorial: function(value) {
                            if (0 === value) return 1;
                            for (var res = value; --value; ) res *= value;
                            return res;
                        },
                        catmullRom: function(p0, p1, p2, p3, t) {
                            var v0 = .5 * (p2 - p0), v1 = .5 * (p3 - p1), t2 = t * t, t3 = t * t2;
                            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
                        },
                        difference: function(a, b) {
                            return Math.abs(a - b);
                        },
                        getRandom: function(objects, startIndex, length) {
                            return Phaser.ArrayUtils.getRandomItem(objects, startIndex, length);
                        },
                        removeRandom: function(objects, startIndex, length) {
                            return Phaser.ArrayUtils.removeRandomItem(objects, startIndex, length);
                        },
                        floor: function(value) {
                            return Math.trunc(value);
                        },
                        ceil: function(value) {
                            return Phaser.Math.roundAwayFromZero(value);
                        },
                        roundAwayFromZero: function(value) {
                            return value > 0 ? Math.ceil(value) : Math.floor(value);
                        },
                        sinCosGenerator: function(length, sinAmplitude, cosAmplitude, frequency) {
                            "undefined" == typeof sinAmplitude && (sinAmplitude = 1), "undefined" == typeof cosAmplitude && (cosAmplitude = 1), 
                            "undefined" == typeof frequency && (frequency = 1);
                            for (var sin = sinAmplitude, cos = cosAmplitude, frq = frequency * Math.PI / length, cosTable = [], sinTable = [], c = 0; length > c; c++) cos -= sin * frq, 
                            sin += cos * frq, cosTable[c] = cos, sinTable[c] = sin;
                            return {
                                sin: sinTable,
                                cos: cosTable,
                                length: length
                            };
                        },
                        shift: function(array) {
                            var s = array.shift();
                            return array.push(s), s;
                        },
                        shuffleArray: function(array) {
                            return Phaser.ArrayUtils.shuffle(array);
                        },
                        distance: function(x1, y1, x2, y2) {
                            var dx = x1 - x2, dy = y1 - y2;
                            return Math.sqrt(dx * dx + dy * dy);
                        },
                        distancePow: function(x1, y1, x2, y2, pow) {
                            return "undefined" == typeof pow && (pow = 2), Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
                        },
                        distanceRounded: function(x1, y1, x2, y2) {
                            return Math.round(Phaser.Math.distance(x1, y1, x2, y2));
                        },
                        clamp: function(x, a, b) {
                            return a > x ? a : x > b ? b : x;
                        },
                        clampBottom: function(x, a) {
                            return a > x ? a : x;
                        },
                        within: function(a, b, tolerance) {
                            return Math.abs(a - b) <= tolerance;
                        },
                        mapLinear: function(x, a1, a2, b1, b2) {
                            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
                        },
                        smoothstep: function(x, min, max) {
                            return x = Math.max(0, Math.min(1, (x - min) / (max - min))), x * x * (3 - 2 * x);
                        },
                        smootherstep: function(x, min, max) {
                            return x = Math.max(0, Math.min(1, (x - min) / (max - min))), x * x * x * (x * (6 * x - 15) + 10);
                        },
                        sign: function(x) {
                            return 0 > x ? -1 : x > 0 ? 1 : 0;
                        },
                        percent: function(a, b, base) {
                            return "undefined" == typeof base && (base = 0), a > b || base > b ? 1 : base > a || base > a ? 0 : (a - base) / b;
                        }
                    };
                    var degreeToRadiansFactor = Math.PI / 180, radianToDegreesFactor = 180 / Math.PI;
                    Phaser.Math.degToRad = function(degrees) {
                        return degrees * degreeToRadiansFactor;
                    }, Phaser.Math.radToDeg = function(radians) {
                        return radians * radianToDegreesFactor;
                    }, Phaser.RandomDataGenerator = function(seeds) {
                        "undefined" == typeof seeds && (seeds = []), this.c = 1, this.s0 = 0, this.s1 = 0, 
                        this.s2 = 0, this.sow(seeds);
                    }, Phaser.RandomDataGenerator.prototype = {
                        rnd: function() {
                            var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                            return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, 
                            this.s2;
                        },
                        sow: function(seeds) {
                            if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), 
                            this.c = 1, seeds) for (var i = 0; i < seeds.length && null != seeds[i]; i++) {
                                var seed = seeds[i];
                                this.s0 -= this.hash(seed), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(seed), 
                                this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(seed), this.s2 += ~~(this.s2 < 0);
                            }
                        },
                        hash: function(data) {
                            var h, i, n;
                            for (n = 4022871197, data = data.toString(), i = 0; i < data.length; i++) n += data.charCodeAt(i), 
                            h = .02519603282416938 * n, n = h >>> 0, h -= n, h *= n, n = h >>> 0, h -= n, n += 4294967296 * h;
                            return 2.3283064365386963e-10 * (n >>> 0);
                        },
                        integer: function() {
                            return 4294967296 * this.rnd.apply(this);
                        },
                        frac: function() {
                            return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0);
                        },
                        real: function() {
                            return this.integer() + this.frac();
                        },
                        integerInRange: function(min, max) {
                            return Math.floor(this.realInRange(0, max - min + 1) + min);
                        },
                        between: function(min, max) {
                            return this.integerInRange(min, max);
                        },
                        realInRange: function(min, max) {
                            return this.frac() * (max - min) + min;
                        },
                        normal: function() {
                            return 1 - 2 * this.frac();
                        },
                        uuid: function() {
                            var a = "", b = "";
                            for (b = a = ""; a++ < 36; b += ~a % 5 | 3 * a & 4 ? (15 ^ a ? 8 ^ this.frac() * (20 ^ a ? 16 : 4) : 4).toString(16) : "-") ;
                            return b;
                        },
                        pick: function(ary) {
                            return ary[this.integerInRange(0, ary.length - 1)];
                        },
                        weightedPick: function(ary) {
                            return ary[~~(Math.pow(this.frac(), 2) * (ary.length - 1))];
                        },
                        timestamp: function(min, max) {
                            return this.realInRange(min || 9466848e5, max || 1577862e6);
                        },
                        angle: function() {
                            return this.integerInRange(-180, 180);
                        }
                    }, Phaser.RandomDataGenerator.prototype.constructor = Phaser.RandomDataGenerator, 
                    Phaser.QuadTree = function(x, y, width, height, maxObjects, maxLevels, level) {
                        this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], 
                        this.nodes = [], this._empty = [], this.reset(x, y, width, height, maxObjects, maxLevels, level);
                    }, Phaser.QuadTree.prototype = {
                        reset: function(x, y, width, height, maxObjects, maxLevels, level) {
                            this.maxObjects = maxObjects || 10, this.maxLevels = maxLevels || 4, this.level = level || 0, 
                            this.bounds = {
                                x: Math.round(x),
                                y: Math.round(y),
                                width: width,
                                height: height,
                                subWidth: Math.floor(width / 2),
                                subHeight: Math.floor(height / 2),
                                right: Math.round(x) + Math.floor(width / 2),
                                bottom: Math.round(y) + Math.floor(height / 2)
                            }, this.objects.length = 0, this.nodes.length = 0;
                        },
                        populate: function(group) {
                            group.forEach(this.populateHandler, this, !0);
                        },
                        populateHandler: function(sprite) {
                            sprite.body && sprite.exists && this.insert(sprite.body);
                        },
                        split: function() {
                            this.nodes[0] = new Phaser.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), 
                            this.nodes[1] = new Phaser.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), 
                            this.nodes[2] = new Phaser.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), 
                            this.nodes[3] = new Phaser.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
                        },
                        insert: function(body) {
                            var index, i = 0;
                            if (null != this.nodes[0] && (index = this.getIndex(body), -1 !== index)) return void this.nodes[index].insert(body);
                            if (this.objects.push(body), this.objects.length > this.maxObjects && this.level < this.maxLevels) for (null == this.nodes[0] && this.split(); i < this.objects.length; ) index = this.getIndex(this.objects[i]), 
                            -1 !== index ? this.nodes[index].insert(this.objects.splice(i, 1)[0]) : i++;
                        },
                        getIndex: function(rect) {
                            var index = -1;
                            return rect.x < this.bounds.right && rect.right < this.bounds.right ? rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom ? index = 1 : rect.y > this.bounds.bottom && (index = 2) : rect.x > this.bounds.right && (rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom ? index = 0 : rect.y > this.bounds.bottom && (index = 3)), 
                            index;
                        },
                        retrieve: function(source) {
                            if (source instanceof Phaser.Rectangle) var returnObjects = this.objects, index = this.getIndex(source); else {
                                if (!source.body) return this._empty;
                                var returnObjects = this.objects, index = this.getIndex(source.body);
                            }
                            return this.nodes[0] && (-1 !== index ? returnObjects = returnObjects.concat(this.nodes[index].retrieve(source)) : (returnObjects = returnObjects.concat(this.nodes[0].retrieve(source)), 
                            returnObjects = returnObjects.concat(this.nodes[1].retrieve(source)), returnObjects = returnObjects.concat(this.nodes[2].retrieve(source)), 
                            returnObjects = returnObjects.concat(this.nodes[3].retrieve(source)))), returnObjects;
                        },
                        clear: function() {
                            this.objects.length = 0;
                            for (var i = this.nodes.length; i--; ) this.nodes[i].clear(), this.nodes.splice(i, 1);
                            this.nodes.length = 0;
                        }
                    }, Phaser.QuadTree.prototype.constructor = Phaser.QuadTree, Phaser.Net = function(game) {
                        this.game = game;
                    }, Phaser.Net.prototype = {
                        getHostName: function() {
                            return window.location && window.location.hostname ? window.location.hostname : null;
                        },
                        checkDomainName: function(domain) {
                            return -1 !== window.location.hostname.indexOf(domain);
                        },
                        updateQueryString: function(key, value, redirect, url) {
                            "undefined" == typeof redirect && (redirect = !1), ("undefined" == typeof url || "" === url) && (url = window.location.href);
                            var output = "", re = new RegExp("([?|&])" + key + "=.*?(&|#|$)(.*)", "gi");
                            if (re.test(url)) output = "undefined" != typeof value && null !== value ? url.replace(re, "$1" + key + "=" + value + "$2$3") : url.replace(re, "$1$3").replace(/(&|\?)$/, ""); else if ("undefined" != typeof value && null !== value) {
                                var separator = -1 !== url.indexOf("?") ? "&" : "?", hash = url.split("#");
                                url = hash[0] + separator + key + "=" + value, hash[1] && (url += "#" + hash[1]), 
                                output = url;
                            } else output = url;
                            return redirect ? void (window.location.href = output) : output;
                        },
                        getQueryString: function(parameter) {
                            "undefined" == typeof parameter && (parameter = "");
                            var output = {}, keyValues = location.search.substring(1).split("&");
                            for (var i in keyValues) {
                                var key = keyValues[i].split("=");
                                if (key.length > 1) {
                                    if (parameter && parameter == this.decodeURI(key[0])) return this.decodeURI(key[1]);
                                    output[this.decodeURI(key[0])] = this.decodeURI(key[1]);
                                }
                            }
                            return output;
                        },
                        decodeURI: function(value) {
                            return decodeURIComponent(value.replace(/\+/g, " "));
                        }
                    }, Phaser.Net.prototype.constructor = Phaser.Net, Phaser.TweenManager = function(game) {
                        this.game = game, this._tweens = [], this._add = [], this.easeMap = {
                            Power0: Phaser.Easing.Power0,
                            Power1: Phaser.Easing.Power1,
                            Power2: Phaser.Easing.Power2,
                            Power3: Phaser.Easing.Power3,
                            Power4: Phaser.Easing.Power4,
                            Linear: Phaser.Easing.Linear.None,
                            Quad: Phaser.Easing.Quadratic.Out,
                            Cubic: Phaser.Easing.Cubic.Out,
                            Quart: Phaser.Easing.Quartic.Out,
                            Quint: Phaser.Easing.Quintic.Out,
                            Sine: Phaser.Easing.Sinusoidal.Out,
                            Expo: Phaser.Easing.Exponential.Out,
                            Circ: Phaser.Easing.Circular.Out,
                            Elastic: Phaser.Easing.Elastic.Out,
                            Back: Phaser.Easing.Back.Out,
                            Bounce: Phaser.Easing.Bounce.Out,
                            "Quad.easeIn": Phaser.Easing.Quadratic.In,
                            "Cubic.easeIn": Phaser.Easing.Cubic.In,
                            "Quart.easeIn": Phaser.Easing.Quartic.In,
                            "Quint.easeIn": Phaser.Easing.Quintic.In,
                            "Sine.easeIn": Phaser.Easing.Sinusoidal.In,
                            "Expo.easeIn": Phaser.Easing.Exponential.In,
                            "Circ.easeIn": Phaser.Easing.Circular.In,
                            "Elastic.easeIn": Phaser.Easing.Elastic.In,
                            "Back.easeIn": Phaser.Easing.Back.In,
                            "Bounce.easeIn": Phaser.Easing.Bounce.In,
                            "Quad.easeOut": Phaser.Easing.Quadratic.Out,
                            "Cubic.easeOut": Phaser.Easing.Cubic.Out,
                            "Quart.easeOut": Phaser.Easing.Quartic.Out,
                            "Quint.easeOut": Phaser.Easing.Quintic.Out,
                            "Sine.easeOut": Phaser.Easing.Sinusoidal.Out,
                            "Expo.easeOut": Phaser.Easing.Exponential.Out,
                            "Circ.easeOut": Phaser.Easing.Circular.Out,
                            "Elastic.easeOut": Phaser.Easing.Elastic.Out,
                            "Back.easeOut": Phaser.Easing.Back.Out,
                            "Bounce.easeOut": Phaser.Easing.Bounce.Out,
                            "Quad.easeInOut": Phaser.Easing.Quadratic.InOut,
                            "Cubic.easeInOut": Phaser.Easing.Cubic.InOut,
                            "Quart.easeInOut": Phaser.Easing.Quartic.InOut,
                            "Quint.easeInOut": Phaser.Easing.Quintic.InOut,
                            "Sine.easeInOut": Phaser.Easing.Sinusoidal.InOut,
                            "Expo.easeInOut": Phaser.Easing.Exponential.InOut,
                            "Circ.easeInOut": Phaser.Easing.Circular.InOut,
                            "Elastic.easeInOut": Phaser.Easing.Elastic.InOut,
                            "Back.easeInOut": Phaser.Easing.Back.InOut,
                            "Bounce.easeInOut": Phaser.Easing.Bounce.InOut
                        }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this);
                    }, Phaser.TweenManager.prototype = {
                        getAll: function() {
                            return this._tweens;
                        },
                        removeAll: function() {
                            for (var i = 0; i < this._tweens.length; i++) this._tweens[i].pendingDelete = !0;
                            this._add = [];
                        },
                        removeFrom: function(obj, children) {
                            "undefined" == typeof children && (children = !0);
                            var i, len;
                            if (Array.isArray(obj)) for (i = 0, len = obj.length; len > i; i++) this.removeFrom(obj[i]); else if (obj.type === Phaser.GROUP && children) for (var i = 0, len = obj.children.length; len > i; i++) this.removeFrom(obj.children[i]); else {
                                for (i = 0, len = this._tweens.length; len > i; i++) obj === this._tweens[i].target && this.remove(this._tweens[i]);
                                for (i = 0, len = this._add.length; len > i; i++) obj === this._add[i].target && this.remove(this._add[i]);
                            }
                        },
                        add: function(tween) {
                            tween._manager = this, this._add.push(tween);
                        },
                        create: function(object) {
                            return new Phaser.Tween(object, this.game, this);
                        },
                        remove: function(tween) {
                            var i = this._tweens.indexOf(tween);
                            -1 !== i ? this._tweens[i].pendingDelete = !0 : (i = this._add.indexOf(tween), -1 !== i && (this._add[i].pendingDelete = !0));
                        },
                        update: function() {
                            var addTweens = this._add.length, numTweens = this._tweens.length;
                            if (0 === numTweens && 0 === addTweens) return !1;
                            for (var i = 0; numTweens > i; ) this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1), 
                            numTweens--);
                            return addTweens > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), 
                            !0;
                        },
                        isTweening: function(object) {
                            return this._tweens.some(function(tween) {
                                return tween.target === object;
                            });
                        },
                        _pauseAll: function() {
                            for (var i = this._tweens.length - 1; i >= 0; i--) this._tweens[i]._pause();
                        },
                        _resumeAll: function() {
                            for (var i = this._tweens.length - 1; i >= 0; i--) this._tweens[i]._resume();
                        },
                        pauseAll: function() {
                            for (var i = this._tweens.length - 1; i >= 0; i--) this._tweens[i].pause();
                        },
                        resumeAll: function() {
                            for (var i = this._tweens.length - 1; i >= 0; i--) this._tweens[i].resume(!0);
                        }
                    }, Phaser.TweenManager.prototype.constructor = Phaser.TweenManager, Phaser.Tween = function(target, game, manager) {
                        this.game = game, this.target = target, this.manager = manager, this.timeline = [], 
                        this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.repeatDelay = 0, 
                        this.pendingDelete = !1, this.onStart = new Phaser.Signal(), this.onLoop = new Phaser.Signal(), 
                        this.onRepeat = new Phaser.Signal(), this.onChildComplete = new Phaser.Signal(), 
                        this.onComplete = new Phaser.Signal(), this.isRunning = !1, this.current = 0, this.properties = {}, 
                        this.chainedTween = null, this.isPaused = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, 
                        this._pausedTime = 0, this._codePaused = !1;
                    }, Phaser.Tween.prototype = {
                        to: function(properties, duration, ease, autoStart, delay, repeat, yoyo) {
                            return "undefined" == typeof duration && (duration = 1e3), "undefined" == typeof ease && (ease = Phaser.Easing.Default), 
                            "undefined" == typeof autoStart && (autoStart = !1), "undefined" == typeof delay && (delay = 0), 
                            "undefined" == typeof repeat && (repeat = 0), "undefined" == typeof yoyo && (yoyo = !1), 
                            "string" == typeof ease && this.manager.easeMap[ease] && (ease = this.manager.easeMap[ease]), 
                            this.isRunning ? (console.warn("Phaser.Tween.to cannot be called after Tween.start"), 
                            this) : (this.timeline.push(new Phaser.TweenData(this).to(properties, duration, ease, delay, repeat, yoyo)), 
                            autoStart && this.start(), this);
                        },
                        from: function(properties, duration, ease, autoStart, delay, repeat, yoyo) {
                            return "undefined" == typeof duration && (duration = 1e3), "undefined" == typeof ease && (ease = Phaser.Easing.Default), 
                            "undefined" == typeof autoStart && (autoStart = !1), "undefined" == typeof delay && (delay = 0), 
                            "undefined" == typeof repeat && (repeat = 0), "undefined" == typeof yoyo && (yoyo = !1), 
                            "string" == typeof ease && this.manager.easeMap[ease] && (ease = this.manager.easeMap[ease]), 
                            this.isRunning ? (console.warn("Phaser.Tween.from cannot be called after Tween.start"), 
                            this) : (this.timeline.push(new Phaser.TweenData(this).from(properties, duration, ease, delay, repeat, yoyo)), 
                            autoStart && this.start(), this);
                        },
                        start: function(index) {
                            if ("undefined" == typeof index && (index = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
                            for (var i = 0; i < this.timeline.length; i++) for (var property in this.timeline[i].vEnd) this.properties[property] = this.target[property] || 0, 
                            Array.isArray(this.properties[property]) || (this.properties[property] *= 1);
                            for (var i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
                            return this.manager.add(this), this.isRunning = !0, (0 > index || index > this.timeline.length - 1) && (index = 0), 
                            this.current = index, this.timeline[this.current].start(), this.onStart.dispatch(this.target, this), 
                            this;
                        },
                        stop: function(complete) {
                            return "undefined" == typeof complete && (complete = !1), this.isRunning = !1, this._onUpdateCallback = null, 
                            this._onUpdateCallbackContext = null, complete && (this.onComplete.dispatch(this.target, this), 
                            this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this;
                        },
                        delay: function(duration, index) {
                            if (0 === this.timeline.length) return this;
                            if ("undefined" == typeof index && (index = 0), -1 === index) for (var i = 0; i < this.timeline.length; i++) this.timeline[i].delay = duration; else this.timeline[index].delay = duration;
                            return this;
                        },
                        repeat: function(total, index) {
                            if (0 === this.timeline.length) return this;
                            if ("undefined" == typeof index && (index = 0), -1 === index) for (var i = 0; i < this.timeline.length; i++) this.timeline[i].repeatCounter = total; else this.timeline[index].repeatCounter = total;
                            return this;
                        },
                        yoyo: function(enable, index) {
                            if (0 === this.timeline.length) return this;
                            if ("undefined" == typeof index && (index = 0), -1 === index) for (var i = 0; i < this.timeline.length; i++) this.timeline[i].yoyo = enable; else this.timeline[index].yoyo = enable;
                            return this;
                        },
                        easing: function(ease, index) {
                            if ("undefined" == typeof index && (index = 0), "string" == typeof ease && this.manager.easeMap[ease] && (ease = this.manager.easeMap[ease]), 
                            -1 === index) for (var i = 0; i < this.timeline.length; i++) this.timeline[i].easingFunction = ease; else this.timeline[index].easingFunction = ease;
                            return this;
                        },
                        interpolation: function(interpolation, index) {
                            if ("undefined" == typeof index && (index = 0), -1 === index) for (var i = 0; i < this.timeline.length; i++) this.timeline[i].interpolationFunction = interpolation; else this.timeline[index].interpolationFunction = interpolation;
                            return this;
                        },
                        repeatAll: function(total) {
                            return "undefined" == typeof total && (total = 0), this.repeatCounter = total, this;
                        },
                        chain: function() {
                            for (var i = arguments.length; i--; ) i > 0 ? arguments[i - 1].chainedTween = arguments[i] : this.chainedTween = arguments[i];
                            return this;
                        },
                        loop: function(value) {
                            return "undefined" == typeof value && (value = !0), value ? this.repeatAll(-1) : this.repeatCounter = 0, 
                            this;
                        },
                        onUpdateCallback: function(callback, callbackContext) {
                            return this._onUpdateCallback = callback, this._onUpdateCallbackContext = callbackContext, 
                            this;
                        },
                        pause: function() {
                            this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time;
                        },
                        _pause: function() {
                            this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time);
                        },
                        resume: function() {
                            if (this.isPaused) {
                                this.isPaused = !1, this._codePaused = !1;
                                for (var i = 0; i < this.timeline.length; i++) this.timeline[i].isRunning || (this.timeline[i].startTime += this.game.time.time - this._pausedTime);
                            }
                        },
                        _resume: function() {
                            this._codePaused || this.resume();
                        },
                        update: function(time) {
                            if (this.pendingDelete) return !1;
                            if (this.isPaused) return !0;
                            var status = this.timeline[this.current].update(time);
                            if (status === Phaser.TweenData.PENDING) return !0;
                            if (status === Phaser.TweenData.RUNNING) return null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), 
                            this.isRunning;
                            if (status === Phaser.TweenData.LOOPED) return this.onLoop.dispatch(this.target, this), 
                            !0;
                            if (status === Phaser.TweenData.COMPLETE) {
                                var complete = !1;
                                return this.reverse ? (this.current--, this.current < 0 && (this.current = this.timeline.length - 1, 
                                complete = !0)) : (this.current++, this.current === this.timeline.length && (this.current = 0, 
                                complete = !0)), complete ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), 
                                this.onRepeat.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, 
                                this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), 
                                !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this.chainedTween && this.chainedTween.start(), 
                                !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), 
                                !0);
                            }
                        },
                        generateData: function(frameRate, data) {
                            if (null === this.game || null === this.target) return null;
                            "undefined" == typeof data && (data = []);
                            for (var i = 0; i < this.timeline.length; i++) for (var property in this.timeline[i].vEnd) this.properties[property] = this.target[property] || 0, 
                            Array.isArray(this.properties[property]) || (this.properties[property] *= 1);
                            for (var i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
                            for (var i = 0; i < this.timeline.length; i++) data = data.concat(this.timeline[i].generateData(frameRate));
                            return data;
                        }
                    }, Object.defineProperty(Phaser.Tween.prototype, "totalDuration", {
                        get: function() {
                            for (var total = 0, i = 0; i < this.timeline.length; i++) total += this.timeline[i].duration;
                            return total;
                        }
                    }), Phaser.Tween.prototype.constructor = Phaser.Tween, Phaser.TweenData = function(parent) {
                        this.parent = parent, this.game = parent.game, this.vStart = {}, this.vStartCache = {}, 
                        this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, 
                        this.repeatCounter = 0, this.repeatDelay = 0, this.yoyo = !1, this.inReverse = !1, 
                        this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = Phaser.Easing.Default, 
                        this.interpolationFunction = Phaser.Math.linearInterpolation, this.isRunning = !1, 
                        this.isFrom = !1;
                    }, Phaser.TweenData.PENDING = 0, Phaser.TweenData.RUNNING = 1, Phaser.TweenData.LOOPED = 2, 
                    Phaser.TweenData.COMPLETE = 3, Phaser.TweenData.prototype = {
                        to: function(properties, duration, ease, delay, repeat, yoyo) {
                            return this.vEnd = properties, this.duration = duration, this.easingFunction = ease, 
                            this.delay = delay, this.repeatCounter = repeat, this.yoyo = yoyo, this.isFrom = !1, 
                            this;
                        },
                        from: function(properties, duration, ease, delay, repeat, yoyo) {
                            return this.vEnd = properties, this.duration = duration, this.easingFunction = ease, 
                            this.delay = delay, this.repeatCounter = repeat, this.yoyo = yoyo, this.isFrom = !0, 
                            this;
                        },
                        start: function() {
                            if (this.startTime = this.game.time.time + this.delay, this.dt = this.parent.reverse ? this.duration : 0, 
                            this.isRunning = this.delay > 0 ? !1 : !0, this.isFrom) for (var property in this.vStartCache) this.vStart[property] = this.vEndCache[property], 
                            this.vEnd[property] = this.vStartCache[property], this.parent.target[property] = this.vStart[property];
                            return this.value = 0, this.yoyoCounter = 0, this;
                        },
                        loadValues: function() {
                            for (var property in this.parent.properties) {
                                if (this.vStart[property] = this.parent.properties[property], Array.isArray(this.vEnd[property])) {
                                    if (0 === this.vEnd[property].length) continue;
                                    this.vEnd[property] = [ this.parent.properties[property] ].concat(this.vEnd[property]);
                                }
                                "undefined" != typeof this.vEnd[property] ? ("string" == typeof this.vEnd[property] && (this.vEnd[property] = this.vStart[property] + parseFloat(this.vEnd[property], 10)), 
                                this.parent.properties[property] = this.vEnd[property]) : this.vEnd[property] = this.vStart[property], 
                                this.vStartCache[property] = this.vStart[property], this.vEndCache[property] = this.vEnd[property];
                            }
                            return this;
                        },
                        update: function() {
                            if (!this.isRunning) {
                                if (!(this.game.time.time >= this.startTime)) return Phaser.TweenData.PENDING;
                                this.isRunning = !0;
                            }
                            this.parent.reverse ? (this.dt -= this.game.time.physicsElapsedMS * this.parent.timeScale, 
                            this.dt = Math.max(this.dt, 0)) : (this.dt += this.game.time.physicsElapsedMS * this.parent.timeScale, 
                            this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, 
                            this.value = this.easingFunction(this.percent);
                            for (var property in this.vEnd) {
                                var start = this.vStart[property], end = this.vEnd[property];
                                this.parent.target[property] = Array.isArray(end) ? this.interpolationFunction(end, this.value) : start + (end - start) * this.value;
                            }
                            return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : Phaser.TweenData.RUNNING;
                        },
                        generateData: function(frameRate) {
                            this.dt = this.parent.reverse ? this.duration : 0;
                            var data = [], complete = !1, fps = 1 / frameRate * 1e3;
                            do {
                                this.parent.reverse ? (this.dt -= fps, this.dt = Math.max(this.dt, 0)) : (this.dt += fps, 
                                this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, 
                                this.value = this.easingFunction(this.percent);
                                var blob = {};
                                for (var property in this.vEnd) {
                                    var start = this.vStart[property], end = this.vEnd[property];
                                    blob[property] = Array.isArray(end) ? this.interpolationFunction(end, this.value) : start + (end - start) * this.value;
                                }
                                data.push(blob), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (complete = !0);
                            } while (!complete);
                            if (this.yoyo) {
                                var reversed = data.slice();
                                reversed.reverse(), data = data.concat(reversed);
                            }
                            return data;
                        },
                        repeat: function() {
                            if (this.yoyo) {
                                if (this.inReverse && 0 === this.repeatCounter) return Phaser.TweenData.COMPLETE;
                                this.inReverse = !this.inReverse;
                            } else if (0 === this.repeatCounter) return Phaser.TweenData.COMPLETE;
                            if (this.inReverse) for (var property in this.vStartCache) this.vStart[property] = this.vEndCache[property], 
                            this.vEnd[property] = this.vStartCache[property]; else {
                                for (var property in this.vStartCache) this.vStart[property] = this.vStartCache[property], 
                                this.vEnd[property] = this.vEndCache[property];
                                this.repeatCounter > 0 && this.repeatCounter--;
                            }
                            return this.startTime = this.game.time.time + this.delay, this.dt = this.parent.reverse ? this.duration : 0, 
                            Phaser.TweenData.LOOPED;
                        }
                    }, Phaser.TweenData.prototype.constructor = Phaser.TweenData, Phaser.Easing = {
                        Linear: {
                            None: function(k) {
                                return k;
                            }
                        },
                        Quadratic: {
                            In: function(k) {
                                return k * k;
                            },
                            Out: function(k) {
                                return k * (2 - k);
                            },
                            InOut: function(k) {
                                return (k *= 2) < 1 ? .5 * k * k : -.5 * (--k * (k - 2) - 1);
                            }
                        },
                        Cubic: {
                            In: function(k) {
                                return k * k * k;
                            },
                            Out: function(k) {
                                return --k * k * k + 1;
                            },
                            InOut: function(k) {
                                return (k *= 2) < 1 ? .5 * k * k * k : .5 * ((k -= 2) * k * k + 2);
                            }
                        },
                        Quartic: {
                            In: function(k) {
                                return k * k * k * k;
                            },
                            Out: function(k) {
                                return 1 - --k * k * k * k;
                            },
                            InOut: function(k) {
                                return (k *= 2) < 1 ? .5 * k * k * k * k : -.5 * ((k -= 2) * k * k * k - 2);
                            }
                        },
                        Quintic: {
                            In: function(k) {
                                return k * k * k * k * k;
                            },
                            Out: function(k) {
                                return --k * k * k * k * k + 1;
                            },
                            InOut: function(k) {
                                return (k *= 2) < 1 ? .5 * k * k * k * k * k : .5 * ((k -= 2) * k * k * k * k + 2);
                            }
                        },
                        Sinusoidal: {
                            In: function(k) {
                                return 0 === k ? 0 : 1 === k ? 1 : 1 - Math.cos(k * Math.PI / 2);
                            },
                            Out: function(k) {
                                return 0 === k ? 0 : 1 === k ? 1 : Math.sin(k * Math.PI / 2);
                            },
                            InOut: function(k) {
                                return 0 === k ? 0 : 1 === k ? 1 : .5 * (1 - Math.cos(Math.PI * k));
                            }
                        },
                        Exponential: {
                            In: function(k) {
                                return 0 === k ? 0 : Math.pow(1024, k - 1);
                            },
                            Out: function(k) {
                                return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
                            },
                            InOut: function(k) {
                                return 0 === k ? 0 : 1 === k ? 1 : (k *= 2) < 1 ? .5 * Math.pow(1024, k - 1) : .5 * (-Math.pow(2, -10 * (k - 1)) + 2);
                            }
                        },
                        Circular: {
                            In: function(k) {
                                return 1 - Math.sqrt(1 - k * k);
                            },
                            Out: function(k) {
                                return Math.sqrt(1 - --k * k);
                            },
                            InOut: function(k) {
                                return (k *= 2) < 1 ? -.5 * (Math.sqrt(1 - k * k) - 1) : .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
                            }
                        },
                        Elastic: {
                            In: function(k) {
                                var s, a = .1, p = .4;
                                return 0 === k ? 0 : 1 === k ? 1 : (!a || 1 > a ? (a = 1, s = p / 4) : s = p * Math.asin(1 / a) / (2 * Math.PI), 
                                -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin(2 * (k - s) * Math.PI / p)));
                            },
                            Out: function(k) {
                                var s, a = .1, p = .4;
                                return 0 === k ? 0 : 1 === k ? 1 : (!a || 1 > a ? (a = 1, s = p / 4) : s = p * Math.asin(1 / a) / (2 * Math.PI), 
                                a * Math.pow(2, -10 * k) * Math.sin(2 * (k - s) * Math.PI / p) + 1);
                            },
                            InOut: function(k) {
                                var s, a = .1, p = .4;
                                return 0 === k ? 0 : 1 === k ? 1 : (!a || 1 > a ? (a = 1, s = p / 4) : s = p * Math.asin(1 / a) / (2 * Math.PI), 
                                (k *= 2) < 1 ? -.5 * a * Math.pow(2, 10 * (k -= 1)) * Math.sin(2 * (k - s) * Math.PI / p) : a * Math.pow(2, -10 * (k -= 1)) * Math.sin(2 * (k - s) * Math.PI / p) * .5 + 1);
                            }
                        },
                        Back: {
                            In: function(k) {
                                var s = 1.70158;
                                return k * k * ((s + 1) * k - s);
                            },
                            Out: function(k) {
                                var s = 1.70158;
                                return --k * k * ((s + 1) * k + s) + 1;
                            },
                            InOut: function(k) {
                                var s = 2.5949095;
                                return (k *= 2) < 1 ? .5 * k * k * ((s + 1) * k - s) : .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
                            }
                        },
                        Bounce: {
                            In: function(k) {
                                return 1 - Phaser.Easing.Bounce.Out(1 - k);
                            },
                            Out: function(k) {
                                return 1 / 2.75 > k ? 7.5625 * k * k : 2 / 2.75 > k ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : 2.5 / 2.75 > k ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
                            },
                            InOut: function(k) {
                                return .5 > k ? .5 * Phaser.Easing.Bounce.In(2 * k) : .5 * Phaser.Easing.Bounce.Out(2 * k - 1) + .5;
                            }
                        }
                    }, Phaser.Easing.Default = Phaser.Easing.Linear.None, Phaser.Easing.Power0 = Phaser.Easing.Linear.None, 
                    Phaser.Easing.Power1 = Phaser.Easing.Quadratic.Out, Phaser.Easing.Power2 = Phaser.Easing.Cubic.Out, 
                    Phaser.Easing.Power3 = Phaser.Easing.Quartic.Out, Phaser.Easing.Power4 = Phaser.Easing.Quintic.Out, 
                    Phaser.Time = function(game) {
                        this.game = game, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, 
                        this.elapsedMS = 0, this.physicsElapsed = 0, this.physicsElapsedMS = 0, this.desiredFps = 60, 
                        this.suggestedFps = null, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, 
                        this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, 
                        this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new Phaser.Timer(this.game, !1), 
                        this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, 
                        this._pauseStarted = 0, this._justResumed = !1, this._timers = [];
                    }, Phaser.Time.prototype = {
                        boot: function() {
                            this._started = Date.now(), this.time = Date.now(), this.events.start();
                        },
                        add: function(timer) {
                            return this._timers.push(timer), timer;
                        },
                        create: function(autoDestroy) {
                            "undefined" == typeof autoDestroy && (autoDestroy = !0);
                            var timer = new Phaser.Timer(this.game, autoDestroy);
                            return this._timers.push(timer), timer;
                        },
                        removeAll: function() {
                            for (var i = 0; i < this._timers.length; i++) this._timers[i].destroy();
                            this._timers = [], this.events.removeAll();
                        },
                        update: function(time) {
                            var previousDateNow = this.time;
                            if (this.time = Date.now(), this.elapsedMS = this.time - previousDateNow, this.prevTime = this.now, 
                            this.now = time, this.elapsed = this.now - this.prevTime, this.timeToCall = Math.floor(Math.max(0, 1e3 / this.desiredFps - (this.timeCallExpected - time))), 
                            this.timeCallExpected = time + this.timeToCall, this._frameCount++, this._elapsedAccumulator += this.elapsed, 
                            this._frameCount >= 2 * this.desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), 
                            this._frameCount = 0, this._elapsedAccumulator = 0), this.physicsElapsed = 1 / this.desiredFps, 
                            this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.advancedTiming && (this.msMin = Math.min(this.msMin, this.elapsed), 
                            this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), 
                            this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), 
                            this._timeLastSecond = this.now, this.frames = 0)), !this.game.paused) {
                                this.events.update(this.time);
                                for (var i = 0, len = this._timers.length; len > i; ) this._timers[i].update(this.time) ? i++ : (this._timers.splice(i, 1), 
                                len--);
                            }
                        },
                        gamePaused: function() {
                            this._pauseStarted = Date.now(), this.events.pause();
                            for (var i = this._timers.length; i--; ) this._timers[i]._pause();
                        },
                        gameResumed: function() {
                            this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
                            for (var i = this._timers.length; i--; ) this._timers[i]._resume();
                        },
                        totalElapsedSeconds: function() {
                            return .001 * (this.time - this._started);
                        },
                        elapsedSince: function(since) {
                            return this.time - since;
                        },
                        elapsedSecondsSince: function(since) {
                            return .001 * (this.time - since);
                        },
                        reset: function() {
                            this._started = this.time, this.removeAll();
                        }
                    }, Phaser.Time.prototype.constructor = Phaser.Time, Phaser.Timer = function(game, autoDestroy) {
                        "undefined" == typeof autoDestroy && (autoDestroy = !0), this.game = game, this.running = !1, 
                        this.autoDestroy = autoDestroy, this.expired = !1, this.elapsed = 0, this.events = [], 
                        this.onComplete = new Phaser.Signal(), this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, 
                        this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, 
                        this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, 
                        this._newTick = 0;
                    }, Phaser.Timer.MINUTE = 6e4, Phaser.Timer.SECOND = 1e3, Phaser.Timer.HALF = 500, 
                    Phaser.Timer.QUARTER = 250, Phaser.Timer.prototype = {
                        create: function(delay, loop, repeatCount, callback, callbackContext, args) {
                            delay = Math.round(delay);
                            var tick = delay;
                            tick += 0 === this._now ? this.game.time.time : this._now;
                            var event = new Phaser.TimerEvent(this, delay, tick, repeatCount, loop, callback, callbackContext, args);
                            return this.events.push(event), this.order(), this.expired = !1, event;
                        },
                        add: function(delay, callback, callbackContext) {
                            return this.create(delay, !1, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));
                        },
                        repeat: function(delay, repeatCount, callback, callbackContext) {
                            return this.create(delay, !1, repeatCount, callback, callbackContext, Array.prototype.splice.call(arguments, 4));
                        },
                        loop: function(delay, callback, callbackContext) {
                            return this.create(delay, !0, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));
                        },
                        start: function(delay) {
                            if (!this.running) {
                                this._started = this.game.time.time + (delay || 0), this.running = !0;
                                for (var i = 0; i < this.events.length; i++) this.events[i].tick = this.events[i].delay + this._started;
                            }
                        },
                        stop: function(clearEvents) {
                            this.running = !1, "undefined" == typeof clearEvents && (clearEvents = !0), clearEvents && (this.events.length = 0);
                        },
                        remove: function(event) {
                            for (var i = 0; i < this.events.length; i++) if (this.events[i] === event) return this.events[i].pendingDelete = !0, 
                            !0;
                            return !1;
                        },
                        order: function() {
                            this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick);
                        },
                        sortHandler: function(a, b) {
                            return a.tick < b.tick ? -1 : a.tick > b.tick ? 1 : 0;
                        },
                        clearPendingEvents: function() {
                            for (this._i = this.events.length; this._i--; ) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                            this._len = this.events.length, this._i = 0;
                        },
                        update: function(time) {
                            if (this.paused) return !0;
                            if (this.elapsed = time - this._now, this._now = time, this.elapsed > this.timeCap && this.adjustEvents(time - this.elapsed), 
                            this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                                for (;this._i < this._len && this.running && this._now >= this.events[this._i].tick; ) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), 
                                this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), this.events[this._i].loop === !0 ? (this.events[this._i].tick = this._newTick, 
                                this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : this.events[this._i].repeatCount > 0 ? (this.events[this._i].repeatCount--, 
                                this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : (this._marked++, 
                                this.events[this._i].pendingDelete = !0, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)), 
                                this._i++;
                                this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this));
                            }
                            return this.expired && this.autoDestroy ? !1 : !0;
                        },
                        pause: function() {
                            this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, 
                            this.paused = !0));
                        },
                        _pause: function() {
                            !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0);
                        },
                        adjustEvents: function(baseTime) {
                            for (var i = 0; i < this.events.length; i++) if (!this.events[i].pendingDelete) {
                                var t = this.events[i].tick - baseTime;
                                0 > t && (t = 0), this.events[i].tick = this._now + t;
                            }
                            var d = this.nextTick - baseTime;
                            this.nextTick = 0 > d ? this._now : this._now + d;
                        },
                        resume: function() {
                            if (this.paused) {
                                var now = this.game.time.time;
                                this._pauseTotal += now - this._now, this._now = now, this.adjustEvents(this._pauseStarted), 
                                this.paused = !1, this._codePaused = !1;
                            }
                        },
                        _resume: function() {
                            this._codePaused || this.resume();
                        },
                        removeAll: function() {
                            this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0;
                        },
                        destroy: function() {
                            this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, 
                            this._i = 0;
                        }
                    }, Object.defineProperty(Phaser.Timer.prototype, "next", {
                        get: function() {
                            return this.nextTick;
                        }
                    }), Object.defineProperty(Phaser.Timer.prototype, "duration", {
                        get: function() {
                            return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0;
                        }
                    }), Object.defineProperty(Phaser.Timer.prototype, "length", {
                        get: function() {
                            return this.events.length;
                        }
                    }), Object.defineProperty(Phaser.Timer.prototype, "ms", {
                        get: function() {
                            return this.running ? this._now - this._started - this._pauseTotal : 0;
                        }
                    }), Object.defineProperty(Phaser.Timer.prototype, "seconds", {
                        get: function() {
                            return this.running ? .001 * this.ms : 0;
                        }
                    }), Phaser.Timer.prototype.constructor = Phaser.Timer, Phaser.TimerEvent = function(timer, delay, tick, repeatCount, loop, callback, callbackContext, args) {
                        this.timer = timer, this.delay = delay, this.tick = tick, this.repeatCount = repeatCount - 1, 
                        this.loop = loop, this.callback = callback, this.callbackContext = callbackContext, 
                        this.args = args, this.pendingDelete = !1;
                    }, Phaser.TimerEvent.prototype.constructor = Phaser.TimerEvent, Phaser.AnimationManager = function(sprite) {
                        this.sprite = sprite, this.game = sprite.game, this.currentFrame = null, this.currentAnim = null, 
                        this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, 
                        this._outputFrames = [];
                    }, Phaser.AnimationManager.prototype = {
                        loadFrameData: function(frameData, frame) {
                            if ("undefined" == typeof frameData) return !1;
                            if (this.isLoaded) for (var anim in this._anims) this._anims[anim].updateFrameData(frameData);
                            return this._frameData = frameData, "undefined" == typeof frame || null === frame ? this.frame = 0 : "string" == typeof frame ? this.frameName = frame : this.frame = frame, 
                            this.isLoaded = !0, !0;
                        },
                        copyFrameData: function(frameData, frame) {
                            if (this._frameData = frameData.clone(), this.isLoaded) for (var anim in this._anims) this._anims[anim].updateFrameData(this._frameData);
                            return "undefined" == typeof frame || null === frame ? this.frame = 0 : "string" == typeof frame ? this.frameName = frame : this.frame = frame, 
                            this.isLoaded = !0, !0;
                        },
                        add: function(name, frames, frameRate, loop, useNumericIndex) {
                            return frames = frames || [], frameRate = frameRate || 60, "undefined" == typeof loop && (loop = !1), 
                            "undefined" == typeof useNumericIndex && (useNumericIndex = frames && "number" == typeof frames[0] ? !0 : !1), 
                            this._outputFrames.length = 0, this._frameData.getFrameIndexes(frames, useNumericIndex, this._outputFrames), 
                            this._anims[name] = new Phaser.Animation(this.game, this.sprite, name, this._frameData, this._outputFrames, frameRate, loop), 
                            this.currentAnim = this._anims[name], this.currentFrame = this.currentAnim.currentFrame, 
                            this.sprite.__tilePattern && (this.sprite.__tilePattern = !1, this.tilingTexture = !1), 
                            this._anims[name];
                        },
                        validateFrames: function(frames, useNumericIndex) {
                            "undefined" == typeof useNumericIndex && (useNumericIndex = !0);
                            for (var i = 0; i < frames.length; i++) if (useNumericIndex === !0) {
                                if (frames[i] > this._frameData.total) return !1;
                            } else if (this._frameData.checkFrameName(frames[i]) === !1) return !1;
                            return !0;
                        },
                        play: function(name, frameRate, loop, killOnComplete) {
                            return this._anims[name] ? this.currentAnim === this._anims[name] ? this.currentAnim.isPlaying === !1 ? (this.currentAnim.paused = !1, 
                            this.currentAnim.play(frameRate, loop, killOnComplete)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), 
                            this.currentAnim = this._anims[name], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, 
                            this.currentAnim.play(frameRate, loop, killOnComplete)) : void 0;
                        },
                        stop: function(name, resetFrame) {
                            "undefined" == typeof resetFrame && (resetFrame = !1), "string" == typeof name ? this._anims[name] && (this.currentAnim = this._anims[name], 
                            this.currentAnim.stop(resetFrame)) : this.currentAnim && this.currentAnim.stop(resetFrame);
                        },
                        update: function() {
                            return this.updateIfVisible && !this.sprite.visible ? !1 : this.currentAnim && this.currentAnim.update() === !0 ? (this.currentFrame = this.currentAnim.currentFrame, 
                            !0) : !1;
                        },
                        next: function(quantity) {
                            this.currentAnim && (this.currentAnim.next(quantity), this.currentFrame = this.currentAnim.currentFrame);
                        },
                        previous: function(quantity) {
                            this.currentAnim && (this.currentAnim.previous(quantity), this.currentFrame = this.currentAnim.currentFrame);
                        },
                        getAnimation: function(name) {
                            return "string" == typeof name && this._anims[name] ? this._anims[name] : null;
                        },
                        refreshFrame: function() {
                            this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]), this.sprite.__tilePattern && (this.__tilePattern = !1, 
                            this.tilingTexture = !1);
                        },
                        destroy: function() {
                            var anim = null;
                            for (var anim in this._anims) this._anims.hasOwnProperty(anim) && this._anims[anim].destroy();
                            this._anims = {}, this._outputFrames = [], this._frameData = null, this._frameIndex = 0, 
                            this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null;
                        }
                    }, Phaser.AnimationManager.prototype.constructor = Phaser.AnimationManager, Object.defineProperty(Phaser.AnimationManager.prototype, "frameData", {
                        get: function() {
                            return this._frameData;
                        }
                    }), Object.defineProperty(Phaser.AnimationManager.prototype, "frameTotal", {
                        get: function() {
                            return this._frameData.total;
                        }
                    }), Object.defineProperty(Phaser.AnimationManager.prototype, "paused", {
                        get: function() {
                            return this.currentAnim.isPaused;
                        },
                        set: function(value) {
                            this.currentAnim.paused = value;
                        }
                    }), Object.defineProperty(Phaser.AnimationManager.prototype, "name", {
                        get: function() {
                            return this.currentAnim ? this.currentAnim.name : void 0;
                        }
                    }), Object.defineProperty(Phaser.AnimationManager.prototype, "frame", {
                        get: function() {
                            return this.currentFrame ? this._frameIndex : void 0;
                        },
                        set: function(value) {
                            "number" == typeof value && this._frameData && null !== this._frameData.getFrame(value) && (this.currentFrame = this._frameData.getFrame(value), 
                            this.currentFrame && (this._frameIndex = value, this.sprite.setFrame(this.currentFrame), 
                            this.sprite.__tilePattern && (this.__tilePattern = !1, this.tilingTexture = !1)));
                        }
                    }), Object.defineProperty(Phaser.AnimationManager.prototype, "frameName", {
                        get: function() {
                            return this.currentFrame ? this.currentFrame.name : void 0;
                        },
                        set: function(value) {
                            "string" == typeof value && null !== this._frameData.getFrameByName(value) ? (this.currentFrame = this._frameData.getFrameByName(value), 
                            this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame), 
                            this.sprite.__tilePattern && (this.__tilePattern = !1, this.tilingTexture = !1))) : console.warn("Cannot set frameName: " + value);
                        }
                    }), Phaser.Animation = function(game, parent, name, frameData, frames, frameRate, loop) {
                        "undefined" == typeof loop && (loop = !1), this.game = game, this._parent = parent, 
                        this._frameData = frameData, this.name = name, this._frames = [], this._frames = this._frames.concat(frames), 
                        this.delay = 1e3 / frameRate, this.loop = loop, this.loopCount = 0, this.killOnComplete = !1, 
                        this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, 
                        this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), 
                        this.onStart = new Phaser.Signal(), this.onUpdate = null, this.onComplete = new Phaser.Signal(), 
                        this.onLoop = new Phaser.Signal(), this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this);
                    }, Phaser.Animation.prototype = {
                        play: function(frameRate, loop, killOnComplete) {
                            return "number" == typeof frameRate && (this.delay = 1e3 / frameRate), "boolean" == typeof loop && (this.loop = loop), 
                            "undefined" != typeof killOnComplete && (this.killOnComplete = killOnComplete), 
                            this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, 
                            this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, 
                            this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), 
                            this._parent.setFrame(this.currentFrame), this._parent.__tilePattern && (this._parent.__tilePattern = !1, 
                            this._parent.tilingTexture = !1), this._parent.events.onAnimationStart$dispatch(this._parent, this), 
                            this.onStart.dispatch(this._parent, this), this;
                        },
                        restart: function() {
                            this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, 
                            this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, 
                            this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), 
                            this._parent.setFrame(this.currentFrame), this.onStart.dispatch(this._parent, this);
                        },
                        setFrame: function(frameId, useLocalFrameIndex) {
                            var frameIndex;
                            if ("undefined" == typeof useLocalFrameIndex && (useLocalFrameIndex = !1), "string" == typeof frameId) for (var i = 0; i < this._frames.length; i++) this._frameData.getFrame(this._frames[i]).name === frameId && (frameIndex = i); else if ("number" == typeof frameId) if (useLocalFrameIndex) frameIndex = frameId; else for (var i = 0; i < this._frames.length; i++) this._frames[i] === frameIndex && (frameIndex = i);
                            frameIndex && (this._frameIndex = frameIndex - 1, this._timeNextFrame = this.game.time.time, 
                            this.update());
                        },
                        stop: function(resetFrame, dispatchComplete) {
                            "undefined" == typeof resetFrame && (resetFrame = !1), "undefined" == typeof dispatchComplete && (dispatchComplete = !1), 
                            this.isPlaying = !1, this.isFinished = !0, this.paused = !1, resetFrame && (this.currentFrame = this._frameData.getFrame(this._frames[0]), 
                            this._parent.setFrame(this.currentFrame)), dispatchComplete && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), 
                            this.onComplete.dispatch(this._parent, this));
                        },
                        onPause: function() {
                            this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time);
                        },
                        onResume: function() {
                            this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff);
                        },
                        update: function() {
                            return this.isPaused ? !1 : this.isPlaying && this.game.time.time >= this._timeNextFrame ? (this._frameSkip = 1, 
                            this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, 
                            this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), 
                            this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), 
                            this._frameIndex += this._frameSkip, this._frameIndex >= this._frames.length && (this.loop ? (this._frameIndex %= this._frames.length, 
                            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.loopCount++, 
                            this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this)) : this.complete()), 
                            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (this._parent.setFrame(this.currentFrame), 
                            this._parent.__tilePattern && (this._parent.__tilePattern = !1, this._parent.tilingTexture = !1), 
                            this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame)), !0) : !1;
                        },
                        next: function(quantity) {
                            "undefined" == typeof quantity && (quantity = 1);
                            var frame = this._frameIndex + quantity;
                            frame >= this._frames.length && (this.loop ? frame %= this._frames.length : frame = this._frames.length - 1), 
                            frame !== this._frameIndex && (this._frameIndex = frame, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), 
                            this.currentFrame && (this._parent.setFrame(this.currentFrame), this._parent.__tilePattern && (this._parent.__tilePattern = !1, 
                            this._parent.tilingTexture = !1)), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame));
                        },
                        previous: function(quantity) {
                            "undefined" == typeof quantity && (quantity = 1);
                            var frame = this._frameIndex - quantity;
                            0 > frame && (this.loop ? frame = this._frames.length + frame : frame++), frame !== this._frameIndex && (this._frameIndex = frame, 
                            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (this._parent.setFrame(this.currentFrame), 
                            this._parent.__tilePattern && (this._parent.__tilePattern = !1, this._parent.tilingTexture = !1)), 
                            this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame));
                        },
                        updateFrameData: function(frameData) {
                            this._frameData = frameData, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null;
                        },
                        destroy: function() {
                            this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), 
                            this.game = null, this._parent = null, this._frames = null, this._frameData = null, 
                            this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), 
                            this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose();
                        },
                        complete: function() {
                            this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), 
                            this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill();
                        }
                    }, Phaser.Animation.prototype.constructor = Phaser.Animation, Object.defineProperty(Phaser.Animation.prototype, "paused", {
                        get: function() {
                            return this.isPaused;
                        },
                        set: function(value) {
                            this.isPaused = value, value ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay);
                        }
                    }), Object.defineProperty(Phaser.Animation.prototype, "frameTotal", {
                        get: function() {
                            return this._frames.length;
                        }
                    }), Object.defineProperty(Phaser.Animation.prototype, "frame", {
                        get: function() {
                            return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex;
                        },
                        set: function(value) {
                            this.currentFrame = this._frameData.getFrame(this._frames[value]), null !== this.currentFrame && (this._frameIndex = value, 
                            this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame));
                        }
                    }), Object.defineProperty(Phaser.Animation.prototype, "speed", {
                        get: function() {
                            return Math.round(1e3 / this.delay);
                        },
                        set: function(value) {
                            value >= 1 && (this.delay = 1e3 / value);
                        }
                    }), Object.defineProperty(Phaser.Animation.prototype, "enableUpdate", {
                        get: function() {
                            return null !== this.onUpdate;
                        },
                        set: function(value) {
                            value && null === this.onUpdate ? this.onUpdate = new Phaser.Signal() : value || null === this.onUpdate || (this.onUpdate.dispose(), 
                            this.onUpdate = null);
                        }
                    }), Phaser.Animation.generateFrameNames = function(prefix, start, stop, suffix, zeroPad) {
                        "undefined" == typeof suffix && (suffix = "");
                        var output = [], frame = "";
                        if (stop > start) for (var i = start; stop >= i; i++) frame = "number" == typeof zeroPad ? Phaser.Utils.pad(i.toString(), zeroPad, "0", 1) : i.toString(), 
                        frame = prefix + frame + suffix, output.push(frame); else for (var i = start; i >= stop; i--) frame = "number" == typeof zeroPad ? Phaser.Utils.pad(i.toString(), zeroPad, "0", 1) : i.toString(), 
                        frame = prefix + frame + suffix, output.push(frame);
                        return output;
                    }, Phaser.Frame = function(index, x, y, width, height, name, uuid) {
                        this.index = index, this.x = x, this.y = y, this.width = width, this.height = height, 
                        this.name = name, this.uuid = uuid, this.centerX = Math.floor(width / 2), this.centerY = Math.floor(height / 2), 
                        this.distance = Phaser.Math.distance(0, 0, width, height), this.rotated = !1, this.rotationDirection = "cw", 
                        this.trimmed = !1, this.sourceSizeW = width, this.sourceSizeH = height, this.spriteSourceSizeX = 0, 
                        this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, 
                        this.right = this.x + this.width, this.bottom = this.y + this.height;
                    }, Phaser.Frame.prototype = {
                        setTrim: function(trimmed, actualWidth, actualHeight, destX, destY, destWidth, destHeight) {
                            this.trimmed = trimmed, trimmed && (this.sourceSizeW = actualWidth, this.sourceSizeH = actualHeight, 
                            this.centerX = Math.floor(actualWidth / 2), this.centerY = Math.floor(actualHeight / 2), 
                            this.spriteSourceSizeX = destX, this.spriteSourceSizeY = destY, this.spriteSourceSizeW = destWidth, 
                            this.spriteSourceSizeH = destHeight);
                        },
                        clone: function() {
                            var output = new Phaser.Frame(this.index, this.x, this.y, this.width, this.height, this.name, this.uuid);
                            for (var prop in this) this.hasOwnProperty(prop) && (output[prop] = this[prop]);
                            return output;
                        },
                        getRect: function(out) {
                            return "undefined" == typeof out ? out = new Phaser.Rectangle(this.x, this.y, this.width, this.height) : out.setTo(this.x, this.y, this.width, this.height), 
                            out;
                        }
                    }, Phaser.Frame.prototype.constructor = Phaser.Frame, Phaser.FrameData = function() {
                        this._frames = [], this._frameNames = [];
                    }, Phaser.FrameData.prototype = {
                        addFrame: function(frame) {
                            return frame.index = this._frames.length, this._frames.push(frame), "" !== frame.name && (this._frameNames[frame.name] = frame.index), 
                            frame;
                        },
                        getFrame: function(index) {
                            return index > this._frames.length && (index = 0), this._frames[index];
                        },
                        getFrameByName: function(name) {
                            return "number" == typeof this._frameNames[name] ? this._frames[this._frameNames[name]] : null;
                        },
                        checkFrameName: function(name) {
                            return null == this._frameNames[name] ? !1 : !0;
                        },
                        clone: function() {
                            for (var output = new Phaser.FrameData(), i = 0; i < this._frames.length; i++) output._frames.push(this._frames[i].clone());
                            for (var p in this._frameNames) this._frameNames.hasOwnProperty(p) && output._frameNames.push(this._frameNames[p]);
                            return output;
                        },
                        getFrameRange: function(start, end, output) {
                            "undefined" == typeof output && (output = []);
                            for (var i = start; end >= i; i++) output.push(this._frames[i]);
                            return output;
                        },
                        getFrames: function(frames, useNumericIndex, output) {
                            if ("undefined" == typeof useNumericIndex && (useNumericIndex = !0), "undefined" == typeof output && (output = []), 
                            "undefined" == typeof frames || 0 === frames.length) for (var i = 0; i < this._frames.length; i++) output.push(this._frames[i]); else for (var i = 0, len = frames.length; len > i; i++) output.push(useNumericIndex ? this.getFrame(frames[i]) : this.getFrameByName(frames[i]));
                            return output;
                        },
                        getFrameIndexes: function(frames, useNumericIndex, output) {
                            if ("undefined" == typeof useNumericIndex && (useNumericIndex = !0), "undefined" == typeof output && (output = []), 
                            "undefined" == typeof frames || 0 === frames.length) for (var i = 0, len = this._frames.length; len > i; i++) output.push(this._frames[i].index); else for (var i = 0, len = frames.length; len > i; i++) useNumericIndex ? output.push(frames[i]) : this.getFrameByName(frames[i]) && output.push(this.getFrameByName(frames[i]).index);
                            return output;
                        }
                    }, Phaser.FrameData.prototype.constructor = Phaser.FrameData, Object.defineProperty(Phaser.FrameData.prototype, "total", {
                        get: function() {
                            return this._frames.length;
                        }
                    }), Phaser.AnimationParser = {
                        spriteSheet: function(game, key, frameWidth, frameHeight, frameMax, margin, spacing) {
                            var img = game.cache.getImage(key);
                            if (null == img) return null;
                            var width = img.width, height = img.height;
                            0 >= frameWidth && (frameWidth = Math.floor(-width / Math.min(-1, frameWidth))), 
                            0 >= frameHeight && (frameHeight = Math.floor(-height / Math.min(-1, frameHeight)));
                            var row = Math.floor((width - margin) / (frameWidth + spacing)), column = Math.floor((height - margin) / (frameHeight + spacing)), total = row * column;
                            if (-1 !== frameMax && (total = frameMax), 0 === width || 0 === height || frameWidth > width || frameHeight > height || 0 === total) return console.warn("Phaser.AnimationParser.spriteSheet: '" + key + "'s width/height zero or width/height < given frameWidth/frameHeight"), 
                            null;
                            for (var data = new Phaser.FrameData(), x = margin, y = margin, i = 0; total > i; i++) {
                                var uuid = game.rnd.uuid();
                                data.addFrame(new Phaser.Frame(i, x, y, frameWidth, frameHeight, "", uuid)), PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[key], {
                                    x: x,
                                    y: y,
                                    width: frameWidth,
                                    height: frameHeight
                                }), x += frameWidth + spacing, x + frameWidth > width && (x = margin, y += frameHeight + spacing);
                            }
                            return data;
                        },
                        JSONData: function(game, json, cacheKey) {
                            if (!json.frames) return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"), 
                            void console.log(json);
                            for (var newFrame, data = new Phaser.FrameData(), frames = json.frames, i = 0; i < frames.length; i++) {
                                var uuid = game.rnd.uuid();
                                newFrame = data.addFrame(new Phaser.Frame(i, frames[i].frame.x, frames[i].frame.y, frames[i].frame.w, frames[i].frame.h, frames[i].filename, uuid)), 
                                PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {
                                    x: frames[i].frame.x,
                                    y: frames[i].frame.y,
                                    width: frames[i].frame.w,
                                    height: frames[i].frame.h
                                }), frames[i].trimmed && newFrame.setTrim(frames[i].trimmed, frames[i].sourceSize.w, frames[i].sourceSize.h, frames[i].spriteSourceSize.x, frames[i].spriteSourceSize.y, frames[i].spriteSourceSize.w, frames[i].spriteSourceSize.h);
                            }
                            return data;
                        },
                        JSONDataHash: function(game, json, cacheKey) {
                            if (!json.frames) return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"), 
                            void console.log(json);
                            var newFrame, data = new Phaser.FrameData(), frames = json.frames, i = 0;
                            for (var key in frames) {
                                var uuid = game.rnd.uuid();
                                newFrame = data.addFrame(new Phaser.Frame(i, frames[key].frame.x, frames[key].frame.y, frames[key].frame.w, frames[key].frame.h, key, uuid)), 
                                PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {
                                    x: frames[key].frame.x,
                                    y: frames[key].frame.y,
                                    width: frames[key].frame.w,
                                    height: frames[key].frame.h
                                }), frames[key].trimmed && newFrame.setTrim(frames[key].trimmed, frames[key].sourceSize.w, frames[key].sourceSize.h, frames[key].spriteSourceSize.x, frames[key].spriteSourceSize.y, frames[key].spriteSourceSize.w, frames[key].spriteSourceSize.h), 
                                i++;
                            }
                            return data;
                        },
                        XMLData: function(game, xml, cacheKey) {
                            if (!xml.getElementsByTagName("TextureAtlas")) return void console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
                            for (var newFrame, uuid, name, frame, x, y, width, height, frameX, frameY, frameWidth, frameHeight, data = new Phaser.FrameData(), frames = xml.getElementsByTagName("SubTexture"), i = 0; i < frames.length; i++) uuid = game.rnd.uuid(), 
                            frame = frames[i].attributes, name = frame.name.value, x = parseInt(frame.x.value, 10), 
                            y = parseInt(frame.y.value, 10), width = parseInt(frame.width.value, 10), height = parseInt(frame.height.value, 10), 
                            frameX = null, frameY = null, frame.frameX && (frameX = Math.abs(parseInt(frame.frameX.value, 10)), 
                            frameY = Math.abs(parseInt(frame.frameY.value, 10)), frameWidth = parseInt(frame.frameWidth.value, 10), 
                            frameHeight = parseInt(frame.frameHeight.value, 10)), newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name, uuid)), 
                            PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {
                                x: x,
                                y: y,
                                width: width,
                                height: height
                            }), (null !== frameX || null !== frameY) && newFrame.setTrim(!0, width, height, frameX, frameY, frameWidth, frameHeight);
                            return data;
                        }
                    }, Phaser.Cache = function(game) {
                        this.game = game, this.autoResolveURL = !1, this._canvases = {}, this._images = {}, 
                        this._textures = {}, this._sounds = {}, this._text = {}, this._json = {}, this._xml = {}, 
                        this._physics = {}, this._tilemaps = {}, this._binary = {}, this._bitmapDatas = {}, 
                        this._bitmapFont = {}, this._urlMap = {}, this._urlResolver = new Image(), this._urlTemp = null, 
                        this.addDefaultImage(), this.addMissingImage(), this.onSoundUnlock = new Phaser.Signal(), 
                        this._cacheMap = [], this._cacheMap[Phaser.Cache.CANVAS] = this._canvases, this._cacheMap[Phaser.Cache.IMAGE] = this._images, 
                        this._cacheMap[Phaser.Cache.TEXTURE] = this._textures, this._cacheMap[Phaser.Cache.SOUND] = this._sounds, 
                        this._cacheMap[Phaser.Cache.TEXT] = this._text, this._cacheMap[Phaser.Cache.PHYSICS] = this._physics, 
                        this._cacheMap[Phaser.Cache.TILEMAP] = this._tilemaps, this._cacheMap[Phaser.Cache.BINARY] = this._binary, 
                        this._cacheMap[Phaser.Cache.BITMAPDATA] = this._bitmapDatas, this._cacheMap[Phaser.Cache.BITMAPFONT] = this._bitmapFont, 
                        this._cacheMap[Phaser.Cache.JSON] = this._json, this._cacheMap[Phaser.Cache.XML] = this._xml;
                    }, Phaser.Cache.CANVAS = 1, Phaser.Cache.IMAGE = 2, Phaser.Cache.TEXTURE = 3, Phaser.Cache.SOUND = 4, 
                    Phaser.Cache.TEXT = 5, Phaser.Cache.PHYSICS = 6, Phaser.Cache.TILEMAP = 7, Phaser.Cache.BINARY = 8, 
                    Phaser.Cache.BITMAPDATA = 9, Phaser.Cache.BITMAPFONT = 10, Phaser.Cache.JSON = 11, 
                    Phaser.Cache.XML = 12, Phaser.Cache.prototype = {
                        addCanvas: function(key, canvas, context) {
                            this._canvases[key] = {
                                canvas: canvas,
                                context: context
                            };
                        },
                        addBinary: function(key, binaryData) {
                            this._binary[key] = binaryData;
                        },
                        addBitmapData: function(key, bitmapData, frameData) {
                            return bitmapData.key = key, "undefined" == typeof frameData && (frameData = new Phaser.FrameData(), 
                            frameData.addFrame(bitmapData.textureFrame)), this._bitmapDatas[key] = {
                                data: bitmapData,
                                frameData: frameData
                            }, bitmapData;
                        },
                        addRenderTexture: function(key, texture) {
                            var frame = new Phaser.Frame(0, 0, 0, texture.width, texture.height, "", "");
                            this._textures[key] = {
                                texture: texture,
                                frame: frame
                            };
                        },
                        addSpriteSheet: function(key, url, data, frameWidth, frameHeight, frameMax, margin, spacing) {
                            this._images[key] = {
                                url: url,
                                data: data,
                                frameWidth: frameWidth,
                                frameHeight: frameHeight,
                                margin: margin,
                                spacing: spacing
                            }, PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data), PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]), 
                            this._images[key].frameData = Phaser.AnimationParser.spriteSheet(this.game, key, frameWidth, frameHeight, frameMax, margin, spacing), 
                            this._resolveURL(url, this._images[key]);
                        },
                        addTilemap: function(key, url, mapData, format) {
                            this._tilemaps[key] = {
                                url: url,
                                data: mapData,
                                format: format
                            }, this._resolveURL(url, this._tilemaps[key]);
                        },
                        addTextureAtlas: function(key, url, data, atlasData, format) {
                            this._images[key] = {
                                url: url,
                                data: data
                            }, PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data), PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]), 
                            format == Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY ? this._images[key].frameData = Phaser.AnimationParser.JSONData(this.game, atlasData, key) : format == Phaser.Loader.TEXTURE_ATLAS_JSON_HASH ? this._images[key].frameData = Phaser.AnimationParser.JSONDataHash(this.game, atlasData, key) : format == Phaser.Loader.TEXTURE_ATLAS_XML_STARLING && (this._images[key].frameData = Phaser.AnimationParser.XMLData(this.game, atlasData, key)), 
                            this._resolveURL(url, this._images[key]);
                        },
                        addBitmapFont: function(key, url, data, xmlData, xSpacing, ySpacing) {
                            this._images[key] = {
                                url: url,
                                data: data
                            }, PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data), PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]), 
                            Phaser.LoaderParser.bitmapFont(this.game, xmlData, key, xSpacing, ySpacing), this._bitmapFont[key] = PIXI.BitmapText.fonts[key], 
                            this._resolveURL(url, this._bitmapFont[key]);
                        },
                        addPhysicsData: function(key, url, JSONData, format) {
                            this._physics[key] = {
                                url: url,
                                data: JSONData,
                                format: format
                            }, this._resolveURL(url, this._physics[key]);
                        },
                        addDefaultImage: function() {
                            var img = new Image();
                            img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==", 
                            this._images.__default = {
                                url: null,
                                data: img
                            }, this._images.__default.frame = new Phaser.Frame(0, 0, 0, 32, 32, "", ""), this._images.__default.frameData = new Phaser.FrameData(), 
                            this._images.__default.frameData.addFrame(new Phaser.Frame(0, 0, 0, 32, 32, null, this.game.rnd.uuid())), 
                            PIXI.BaseTextureCache.__default = new PIXI.BaseTexture(img), PIXI.TextureCache.__default = new PIXI.Texture(PIXI.BaseTextureCache.__default);
                        },
                        addMissingImage: function() {
                            var img = new Image();
                            img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==", 
                            this._images.__missing = {
                                url: null,
                                data: img
                            }, this._images.__missing.frame = new Phaser.Frame(0, 0, 0, 32, 32, "", ""), this._images.__missing.frameData = new Phaser.FrameData(), 
                            this._images.__missing.frameData.addFrame(new Phaser.Frame(0, 0, 0, 32, 32, null, this.game.rnd.uuid())), 
                            PIXI.BaseTextureCache.__missing = new PIXI.BaseTexture(img), PIXI.TextureCache.__missing = new PIXI.Texture(PIXI.BaseTextureCache.__missing);
                        },
                        addText: function(key, url, data) {
                            this._text[key] = {
                                url: url,
                                data: data
                            }, this._resolveURL(url, this._text[key]);
                        },
                        addJSON: function(key, url, data) {
                            this._json[key] = {
                                url: url,
                                data: data
                            }, this._resolveURL(url, this._json[key]);
                        },
                        addXML: function(key, url, data) {
                            this._xml[key] = {
                                url: url,
                                data: data
                            }, this._resolveURL(url, this._xml[key]);
                        },
                        addImage: function(key, url, data) {
                            this._images[key] = {
                                url: url,
                                data: data
                            }, this._images[key].frame = new Phaser.Frame(0, 0, 0, data.width, data.height, key, this.game.rnd.uuid()), 
                            this._images[key].frameData = new Phaser.FrameData(), this._images[key].frameData.addFrame(new Phaser.Frame(0, 0, 0, data.width, data.height, url, this.game.rnd.uuid())), 
                            PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data), PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]), 
                            this._resolveURL(url, this._images[key]);
                        },
                        addSound: function(key, url, data, webAudio, audioTag) {
                            webAudio = webAudio || !0, audioTag = audioTag || !1;
                            var decoded = !1;
                            audioTag && (decoded = !0), this._sounds[key] = {
                                url: url,
                                data: data,
                                isDecoding: !1,
                                decoded: decoded,
                                webAudio: webAudio,
                                audioTag: audioTag,
                                locked: this.game.sound.touchLocked
                            }, this._resolveURL(url, this._sounds[key]);
                        },
                        reloadSound: function(key) {
                            var _this = this;
                            this._sounds[key] && (this._sounds[key].data.src = this._sounds[key].url, this._sounds[key].data.addEventListener("canplaythrough", function() {
                                return _this.reloadSoundComplete(key);
                            }, !1), this._sounds[key].data.load());
                        },
                        reloadSoundComplete: function(key) {
                            this._sounds[key] && (this._sounds[key].locked = !1, this.onSoundUnlock.dispatch(key));
                        },
                        updateSound: function(key, property, value) {
                            this._sounds[key] && (this._sounds[key][property] = value);
                        },
                        decodedSound: function(key, data) {
                            this._sounds[key].data = data, this._sounds[key].decoded = !0, this._sounds[key].isDecoding = !1;
                        },
                        getCanvas: function(key) {
                            return this._canvases[key] ? this._canvases[key].canvas : (console.warn('Phaser.Cache.getCanvas: Invalid key: "' + key + '"'), 
                            null);
                        },
                        getBitmapData: function(key) {
                            return this._bitmapDatas[key] ? this._bitmapDatas[key].data : (console.warn('Phaser.Cache.getBitmapData: Invalid key: "' + key + '"'), 
                            null);
                        },
                        getBitmapFont: function(key) {
                            return this._bitmapFont[key] ? this._bitmapFont[key] : (console.warn('Phaser.Cache.getBitmapFont: Invalid key: "' + key + '"'), 
                            null);
                        },
                        getPhysicsData: function(key, object, fixtureKey) {
                            if ("undefined" == typeof object || null === object) {
                                if (this._physics[key]) return this._physics[key].data;
                                console.warn('Phaser.Cache.getPhysicsData: Invalid key: "' + key + '"');
                            } else if (this._physics[key] && this._physics[key].data[object]) {
                                var fixtures = this._physics[key].data[object];
                                if (!fixtures || !fixtureKey) return fixtures;
                                for (var fixture in fixtures) if (fixture = fixtures[fixture], fixture.fixtureKey === fixtureKey) return fixture;
                                console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + fixtureKey + " in " + key + '"');
                            } else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + key + " / " + object + '"');
                            return null;
                        },
                        checkKey: function(type, key) {
                            return this._cacheMap[type][key] ? !0 : !1;
                        },
                        checkCanvasKey: function(key) {
                            return this.checkKey(Phaser.Cache.CANVAS, key);
                        },
                        checkImageKey: function(key) {
                            return this.checkKey(Phaser.Cache.IMAGE, key);
                        },
                        checkTextureKey: function(key) {
                            return this.checkKey(Phaser.Cache.TEXTURE, key);
                        },
                        checkSoundKey: function(key) {
                            return this.checkKey(Phaser.Cache.SOUND, key);
                        },
                        checkTextKey: function(key) {
                            return this.checkKey(Phaser.Cache.TEXT, key);
                        },
                        checkPhysicsKey: function(key) {
                            return this.checkKey(Phaser.Cache.PHYSICS, key);
                        },
                        checkTilemapKey: function(key) {
                            return this.checkKey(Phaser.Cache.TILEMAP, key);
                        },
                        checkBinaryKey: function(key) {
                            return this.checkKey(Phaser.Cache.BINARY, key);
                        },
                        checkBitmapDataKey: function(key) {
                            return this.checkKey(Phaser.Cache.BITMAPDATA, key);
                        },
                        checkBitmapFontKey: function(key) {
                            return this.checkKey(Phaser.Cache.BITMAPFONT, key);
                        },
                        checkJSONKey: function(key) {
                            return this.checkKey(Phaser.Cache.JSON, key);
                        },
                        checkXMLKey: function(key) {
                            return this.checkKey(Phaser.Cache.XML, key);
                        },
                        checkURL: function(url) {
                            return this._urlMap[this._resolveURL(url)] ? !0 : !1;
                        },
                        getImage: function(key) {
                            return this._images[key] ? this._images[key].data : (console.warn('Phaser.Cache.getImage: Invalid key: "' + key + '"'), 
                            null);
                        },
                        getTilemapData: function(key) {
                            return this._tilemaps[key] ? this._tilemaps[key] : (console.warn('Phaser.Cache.getTilemapData: Invalid key: "' + key + '"'), 
                            null);
                        },
                        getFrameData: function(key, map) {
                            return "undefined" == typeof map && (map = Phaser.Cache.IMAGE), this._cacheMap[map][key] ? this._cacheMap[map][key].frameData : null;
                        },
                        updateFrameData: function(key, frameData) {
                            this._images[key] && (this._images[key].frameData = frameData);
                        },
                        getFrameByIndex: function(key, frame) {
                            return this._images[key] ? this._images[key].frameData.getFrame(frame) : null;
                        },
                        getFrameByName: function(key, frame) {
                            return this._images[key] ? this._images[key].frameData.getFrameByName(frame) : null;
                        },
                        getFrame: function(key) {
                            return this._images[key] ? this._images[key].frame : null;
                        },
                        getTextureFrame: function(key) {
                            return this._textures[key] ? this._textures[key].frame : null;
                        },
                        getRenderTexture: function(key) {
                            return this._textures[key] ? this._textures[key] : (console.warn('Phaser.Cache.getTexture: Invalid key: "' + key + '"'), 
                            null);
                        },
                        getTexture: function(key) {
                            return this._textures[key] ? this._textures[key] : void console.warn('Phaser.Cache.getTexture: Invalid key: "' + key + '"');
                        },
                        getSound: function(key) {
                            return this._sounds[key] ? this._sounds[key] : (console.warn('Phaser.Cache.getSound: Invalid key: "' + key + '"'), 
                            null);
                        },
                        getSoundData: function(key) {
                            return this._sounds[key] ? this._sounds[key].data : (console.warn('Phaser.Cache.getSoundData: Invalid key: "' + key + '"'), 
                            null);
                        },
                        isSoundDecoded: function(key) {
                            return this._sounds[key] ? this._sounds[key].decoded : void 0;
                        },
                        isSoundReady: function(key) {
                            return this._sounds[key] && this._sounds[key].decoded && this.game.sound.touchLocked === !1;
                        },
                        getFrameCount: function(key) {
                            return this._images[key] ? this._images[key].frameData.total : 0;
                        },
                        getText: function(key) {
                            return this._text[key] ? this._text[key].data : (console.warn('Phaser.Cache.getText: Invalid key: "' + key + '"'), 
                            null);
                        },
                        getJSON: function(key) {
                            return this._json[key] ? this._json[key].data : (console.warn('Phaser.Cache.getJSON: Invalid key: "' + key + '"'), 
                            null);
                        },
                        getXML: function(key) {
                            return this._xml[key] ? this._xml[key].data : (console.warn('Phaser.Cache.getXML: Invalid key: "' + key + '"'), 
                            null);
                        },
                        getBinary: function(key) {
                            return this._binary[key] ? this._binary[key] : (console.warn('Phaser.Cache.getBinary: Invalid key: "' + key + '"'), 
                            null);
                        },
                        getURL: function(url) {
                            var url = this._resolveURL(url);
                            return url ? this._urlMap[url] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + url + '" or Cache.autoResolveURL was false'), 
                            null);
                        },
                        getUrl: function(url) {
                            return this.getURL(url);
                        },
                        getKeys: function(type) {
                            var array = null;
                            switch (type) {
                              case Phaser.Cache.CANVAS:
                                array = this._canvases;
                                break;

                              case Phaser.Cache.IMAGE:
                                array = this._images;
                                break;

                              case Phaser.Cache.TEXTURE:
                                array = this._textures;
                                break;

                              case Phaser.Cache.SOUND:
                                array = this._sounds;
                                break;

                              case Phaser.Cache.TEXT:
                                array = this._text;
                                break;

                              case Phaser.Cache.PHYSICS:
                                array = this._physics;
                                break;

                              case Phaser.Cache.TILEMAP:
                                array = this._tilemaps;
                                break;

                              case Phaser.Cache.BINARY:
                                array = this._binary;
                                break;

                              case Phaser.Cache.BITMAPDATA:
                                array = this._bitmapDatas;
                                break;

                              case Phaser.Cache.BITMAPFONT:
                                array = this._bitmapFont;
                                break;

                              case Phaser.Cache.JSON:
                                array = this._json;
                                break;

                              case Phaser.Cache.XML:
                                array = this._xml;
                            }
                            if (array) {
                                var output = [];
                                for (var item in array) "__default" !== item && "__missing" !== item && output.push(item);
                                return output;
                            }
                        },
                        removeCanvas: function(key) {
                            delete this._canvases[key];
                        },
                        removeImage: function(key, removeFromPixi) {
                            "undefined" == typeof removeFromPixi && (removeFromPixi = !0), delete this._images[key], 
                            removeFromPixi && PIXI.BaseTextureCache[key].destroy();
                        },
                        removeSound: function(key) {
                            delete this._sounds[key];
                        },
                        removeText: function(key) {
                            delete this._text[key];
                        },
                        removeJSON: function(key) {
                            delete this._json[key];
                        },
                        removeXML: function(key) {
                            delete this._xml[key];
                        },
                        removePhysics: function(key) {
                            delete this._physics[key];
                        },
                        removeTilemap: function(key) {
                            delete this._tilemaps[key];
                        },
                        removeBinary: function(key) {
                            delete this._binary[key];
                        },
                        removeBitmapData: function(key) {
                            delete this._bitmapDatas[key];
                        },
                        removeBitmapFont: function(key) {
                            delete this._bitmapFont[key];
                        },
                        _resolveURL: function(url, data) {
                            return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + url, 
                            this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", data && (this._urlMap[this._urlTemp] = data), 
                            this._urlTemp) : null;
                        },
                        destroy: function() {
                            for (var item in this._canvases) delete this._canvases[item];
                            for (var item in this._images) "__default" !== item && "__missing" !== item && delete this._images[item];
                            for (var item in this._sounds) delete this._sounds[item];
                            for (var item in this._text) delete this._text[item];
                            for (var item in this._json) delete this._json[item];
                            for (var item in this._xml) delete this._xml[item];
                            for (var item in this._textures) delete this._textures[item];
                            for (var item in this._physics) delete this._physics[item];
                            for (var item in this._tilemaps) delete this._tilemaps[item];
                            for (var item in this._binary) delete this._binary[item];
                            for (var item in this._bitmapDatas) delete this._bitmapDatas[item];
                            for (var item in this._bitmapFont) delete this._bitmapFont[item];
                            this._urlMap = null, this._urlResolver = null, this._urlTemp = null;
                        }
                    }, Phaser.Cache.prototype.constructor = Phaser.Cache, Phaser.Loader = function(game) {
                        this.game = game, this.isLoading = !1, this.hasLoaded = !1, this.progress = 0, this.progressFloat = 0, 
                        this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.onLoadStart = new Phaser.Signal(), 
                        this.onFileStart = new Phaser.Signal(), this.onFileComplete = new Phaser.Signal(), 
                        this.onFileError = new Phaser.Signal(), this.onLoadComplete = new Phaser.Signal(), 
                        this.onPackComplete = new Phaser.Signal(), this.useXDomainRequest = !1, this._packList = [], 
                        this._packIndex = 0, this._fileList = [], this._fileIndex = 0, this._progressChunk = 0, 
                        this._xhr = new XMLHttpRequest(), this._ajax = null;
                    }, Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, Phaser.Loader.TEXTURE_ATLAS_JSON_HASH = 1, 
                    Phaser.Loader.TEXTURE_ATLAS_XML_STARLING = 2, Phaser.Loader.PHYSICS_LIME_CORONA_JSON = 3, 
                    Phaser.Loader.PHYSICS_PHASER_JSON = 4, Phaser.Loader.prototype = {
                        setPreloadSprite: function(sprite, direction) {
                            direction = direction || 0, this.preloadSprite = {
                                sprite: sprite,
                                direction: direction,
                                width: sprite.width,
                                height: sprite.height,
                                rect: null
                            }, this.preloadSprite.rect = 0 === direction ? new Phaser.Rectangle(0, 0, 1, sprite.height) : new Phaser.Rectangle(0, 0, sprite.width, 1), 
                            sprite.crop(this.preloadSprite.rect), sprite.visible = !0;
                        },
                        resize: function() {
                            this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height);
                        },
                        checkKeyExists: function(type, key) {
                            if (this._fileList.length > 0) for (var i = 0; i < this._fileList.length; i++) if (this._fileList[i].type === type && this._fileList[i].key === key) return !0;
                            return !1;
                        },
                        getAssetIndex: function(type, key) {
                            if (this._fileList.length > 0) for (var i = 0; i < this._fileList.length; i++) if (this._fileList[i].type === type && this._fileList[i].key === key) return i;
                            return -1;
                        },
                        getAsset: function(type, key) {
                            if (this._fileList.length > 0) for (var i = 0; i < this._fileList.length; i++) if (this._fileList[i].type === type && this._fileList[i].key === key) return {
                                index: i,
                                file: this._fileList[i]
                            };
                            return !1;
                        },
                        reset: function() {
                            this.preloadSprite = null, this.isLoading = !1, this._packList.length = 0, this._packIndex = 0, 
                            this._fileList.length = 0, this._fileIndex = 0;
                        },
                        addToFileList: function(type, key, url, properties) {
                            var entry = {
                                type: type,
                                key: key,
                                url: url,
                                data: null,
                                error: !1,
                                loaded: !1
                            };
                            if ("undefined" != typeof properties) for (var prop in properties) entry[prop] = properties[prop];
                            this.checkKeyExists(type, key) === !1 && this._fileList.push(entry);
                        },
                        replaceInFileList: function(type, key, url, properties) {
                            var entry = {
                                type: type,
                                key: key,
                                url: url,
                                data: null,
                                error: !1,
                                loaded: !1
                            };
                            if ("undefined" != typeof properties) for (var prop in properties) entry[prop] = properties[prop];
                            var index = this.getAssetIndex(type, key);
                            -1 === index ? this._fileList.push(entry) : this._fileList[index] = entry;
                        },
                        pack: function(key, url, data, callbackContext) {
                            return "undefined" == typeof url && (url = null), "undefined" == typeof data && (data = null), 
                            "undefined" == typeof callbackContext && (callbackContext = this), null === url && null === data ? (console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."), 
                            this) : (data && "string" == typeof data && (data = JSON.parse(data)), this._packList.push({
                                key: key,
                                url: url,
                                data: data,
                                loaded: !1,
                                error: !1,
                                callbackContext: callbackContext
                            }), this);
                        },
                        image: function(key, url, overwrite) {
                            return "undefined" == typeof overwrite && (overwrite = !1), overwrite ? this.replaceInFileList("image", key, url) : this.addToFileList("image", key, url), 
                            this;
                        },
                        text: function(key, url, overwrite) {
                            return "undefined" == typeof overwrite && (overwrite = !1), overwrite ? this.replaceInFileList("text", key, url) : this.addToFileList("text", key, url), 
                            this;
                        },
                        json: function(key, url, overwrite) {
                            return "undefined" == typeof overwrite && (overwrite = !1), overwrite ? this.replaceInFileList("json", key, url) : this.addToFileList("json", key, url), 
                            this;
                        },
                        xml: function(key, url, overwrite) {
                            return "undefined" == typeof overwrite && (overwrite = !1), overwrite ? this.replaceInFileList("xml", key, url) : this.addToFileList("xml", key, url), 
                            this;
                        },
                        script: function(key, url, callback, callbackContext) {
                            return "undefined" == typeof callback && (callback = !1), callback !== !1 && "undefined" == typeof callbackContext && (callbackContext = callback), 
                            this.addToFileList("script", key, url, {
                                callback: callback,
                                callbackContext: callbackContext
                            }), this;
                        },
                        binary: function(key, url, callback, callbackContext) {
                            return "undefined" == typeof callback && (callback = !1), callback !== !1 && "undefined" == typeof callbackContext && (callbackContext = callback), 
                            this.addToFileList("binary", key, url, {
                                callback: callback,
                                callbackContext: callbackContext
                            }), this;
                        },
                        spritesheet: function(key, url, frameWidth, frameHeight, frameMax, margin, spacing) {
                            return "undefined" == typeof frameMax && (frameMax = -1), "undefined" == typeof margin && (margin = 0), 
                            "undefined" == typeof spacing && (spacing = 0), this.addToFileList("spritesheet", key, url, {
                                frameWidth: frameWidth,
                                frameHeight: frameHeight,
                                frameMax: frameMax,
                                margin: margin,
                                spacing: spacing
                            }), this;
                        },
                        audio: function(key, urls, autoDecode) {
                            return "undefined" == typeof autoDecode && (autoDecode = !0), this.addToFileList("audio", key, urls, {
                                buffer: null,
                                autoDecode: autoDecode
                            }), this;
                        },
                        audiosprite: function(key, urls, atlasURL) {
                            return this.audio(key, urls), this.json(key + "-audioatlas", atlasURL), this;
                        },
                        tilemap: function(key, url, data, format) {
                            if ("undefined" == typeof url && (url = null), "undefined" == typeof data && (data = null), 
                            "undefined" == typeof format && (format = Phaser.Tilemap.CSV), null == url && null == data) return console.warn("Phaser.Loader.tilemap - Both url and data are null. One must be set."), 
                            this;
                            if (data) {
                                switch (format) {
                                  case Phaser.Tilemap.CSV:
                                    break;

                                  case Phaser.Tilemap.TILED_JSON:
                                    "string" == typeof data && (data = JSON.parse(data));
                                }
                                this.game.cache.addTilemap(key, null, data, format);
                            } else this.addToFileList("tilemap", key, url, {
                                format: format
                            });
                            return this;
                        },
                        physics: function(key, url, data, format) {
                            return "undefined" == typeof url && (url = null), "undefined" == typeof data && (data = null), 
                            "undefined" == typeof format && (format = Phaser.Physics.LIME_CORONA_JSON), null == url && null == data ? (console.warn("Phaser.Loader.physics - Both url and data are null. One must be set."), 
                            this) : (data ? ("string" == typeof data && (data = JSON.parse(data)), this.game.cache.addPhysicsData(key, null, data, format)) : this.addToFileList("physics", key, url, {
                                format: format
                            }), this);
                        },
                        bitmapFont: function(key, textureURL, xmlURL, xmlData, xSpacing, ySpacing) {
                            if ("undefined" == typeof xmlURL && (xmlURL = null), "undefined" == typeof xmlData && (xmlData = null), 
                            "undefined" == typeof xSpacing && (xSpacing = 0), "undefined" == typeof ySpacing && (ySpacing = 0), 
                            xmlURL) this.addToFileList("bitmapfont", key, textureURL, {
                                xmlURL: xmlURL,
                                xSpacing: xSpacing,
                                ySpacing: ySpacing
                            }); else if ("string" == typeof xmlData) {
                                var xml;
                                try {
                                    if (window.DOMParser) {
                                        var domparser = new DOMParser();
                                        xml = domparser.parseFromString(xmlData, "text/xml");
                                    } else xml = new ActiveXObject("Microsoft.XMLDOM"), xml.async = "false", xml.loadXML(xmlData);
                                } catch (e) {
                                    xml = void 0;
                                }
                                if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) throw new Error("Phaser.Loader. Invalid Bitmap Font XML given");
                                this.addToFileList("bitmapfont", key, textureURL, {
                                    xmlURL: null,
                                    xmlData: xml,
                                    xSpacing: xSpacing,
                                    ySpacing: ySpacing
                                });
                            }
                            return this;
                        },
                        atlasJSONArray: function(key, textureURL, atlasURL, atlasData) {
                            return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY);
                        },
                        atlasJSONHash: function(key, textureURL, atlasURL, atlasData) {
                            return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_JSON_HASH);
                        },
                        atlasXML: function(key, textureURL, atlasURL, atlasData) {
                            return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_XML_STARLING);
                        },
                        atlas: function(key, textureURL, atlasURL, atlasData, format) {
                            if ("undefined" == typeof atlasURL && (atlasURL = null), "undefined" == typeof atlasData && (atlasData = null), 
                            "undefined" == typeof format && (format = Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY), 
                            atlasURL) this.addToFileList("textureatlas", key, textureURL, {
                                atlasURL: atlasURL,
                                format: format
                            }); else {
                                switch (format) {
                                  case Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                                    "string" == typeof atlasData && (atlasData = JSON.parse(atlasData));
                                    break;

                                  case Phaser.Loader.TEXTURE_ATLAS_XML_STARLING:
                                    if ("string" == typeof atlasData) {
                                        var xml;
                                        try {
                                            if (window.DOMParser) {
                                                var domparser = new DOMParser();
                                                xml = domparser.parseFromString(atlasData, "text/xml");
                                            } else xml = new ActiveXObject("Microsoft.XMLDOM"), xml.async = "false", xml.loadXML(atlasData);
                                        } catch (e) {
                                            xml = void 0;
                                        }
                                        if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                        atlasData = xml;
                                    }
                                }
                                this.addToFileList("textureatlas", key, textureURL, {
                                    atlasURL: null,
                                    atlasData: atlasData,
                                    format: format
                                });
                            }
                            return this;
                        },
                        removeFile: function(type, key) {
                            var file = this.getAsset(type, key);
                            file !== !1 && this._fileList.splice(file.index, 1);
                        },
                        removeAll: function() {
                            this._fileList.length = 0;
                        },
                        start: function() {
                            this.isLoading || (this._packList.length > 0 ? (this._packIndex = 0, this.loadPack()) : this.beginLoad());
                        },
                        beginLoad: function() {
                            this.progress = 0, this.progressFloat = 0, this.hasLoaded = !1, this.isLoading = !0, 
                            this.onLoadStart.dispatch(this._fileList.length), this._fileList.length > 0 ? (this._fileIndex = 0, 
                            this._progressChunk = 100 / this._fileList.length, this.loadFile()) : (this.progress = 100, 
                            this.progressFloat = 100, this.hasLoaded = !0, this.isLoading = !1, this.onLoadComplete.dispatch());
                        },
                        loadPack: function() {
                            if (!this._packList[this._packIndex]) return void console.warn("Phaser.Loader loadPackList invalid index " + this._packIndex);
                            var pack = this._packList[this._packIndex];
                            null !== pack.data ? this.packLoadComplete(this._packIndex, !1) : this.xhrLoad(this._packIndex, this.baseURL + pack.url, "text", "packLoadComplete", "packLoadError");
                        },
                        packLoadComplete: function(index, parse) {
                            if ("undefined" == typeof parse && (parse = !0), !this._packList[index]) return void console.warn("Phaser.Loader packLoadComplete invalid index " + index);
                            var pack = this._packList[index];
                            if (pack.loaded = !0, parse) var data = JSON.parse(this._xhr.responseText); else var data = this._packList[index].data;
                            if (data[pack.key]) for (var file, i = 0; i < data[pack.key].length; i++) switch (file = data[pack.key][i], 
                            file.type) {
                              case "image":
                                this.image(file.key, file.url, file.overwrite);
                                break;

                              case "text":
                                this.text(file.key, file.url, file.overwrite);
                                break;

                              case "json":
                                this.json(file.key, file.url, file.overwrite);
                                break;

                              case "xml":
                                this.xml(file.key, file.url, file.overwrite);
                                break;

                              case "script":
                                this.script(file.key, file.url, file.callback, pack.callbackContext);
                                break;

                              case "binary":
                                this.binary(file.key, file.url, file.callback, pack.callbackContext);
                                break;

                              case "spritesheet":
                                this.spritesheet(file.key, file.url, file.frameWidth, file.frameHeight, file.frameMax, file.margin, file.spacing);
                                break;

                              case "audio":
                                this.audio(file.key, file.urls, file.autoDecode);
                                break;

                              case "tilemap":
                                this.tilemap(file.key, file.url, file.data, Phaser.Tilemap[file.format]);
                                break;

                              case "physics":
                                this.physics(file.key, file.url, file.data, Phaser.Loader[file.format]);
                                break;

                              case "bitmapFont":
                                this.bitmapFont(file.key, file.textureURL, file.xmlURL, file.xmlData, file.xSpacing, file.ySpacing);
                                break;

                              case "atlasJSONArray":
                                this.atlasJSONArray(file.key, file.textureURL, file.atlasURL, file.atlasData);
                                break;

                              case "atlasJSONHash":
                                this.atlasJSONHash(file.key, file.textureURL, file.atlasURL, file.atlasData);
                                break;

                              case "atlasXML":
                                this.atlasXML(file.key, file.textureURL, file.atlasURL, file.atlasData);
                                break;

                              case "atlas":
                                this.atlas(file.key, file.textureURL, file.atlasURL, file.atlasData, Phaser.Loader[file.format]);
                            }
                            this.nextPack(index, !0);
                        },
                        packError: function(index) {
                            this._packList[index].loaded = !0, this._packList[index].error = !0, this.onFileError.dispatch(this._packList[index].key, this._packList[index]), 
                            console.warn("Phaser.Loader error loading pack file: " + this._packList[index].key + " from URL " + this._packList[index].url), 
                            this.nextPack(index, !1);
                        },
                        nextPack: function(index, success) {
                            this.onPackComplete.dispatch(this._packList[index].key, success, this.totalLoadedPacks(), this._packList.length), 
                            this._packIndex++, this._packIndex < this._packList.length ? this.loadPack() : this.beginLoad();
                        },
                        loadFile: function() {
                            if (!this._fileList[this._fileIndex]) return void console.warn("Phaser.Loader loadFile invalid index " + this._fileIndex);
                            var file = this._fileList[this._fileIndex], _this = this;
                            switch (this.onFileStart.dispatch(this.progress, file.key, file.url), file.type) {
                              case "image":
                              case "spritesheet":
                              case "textureatlas":
                              case "bitmapfont":
                                file.data = new Image(), file.data.name = file.key, file.data.onload = function() {
                                    return _this.fileComplete(_this._fileIndex);
                                }, file.data.onerror = function() {
                                    return _this.fileError(_this._fileIndex);
                                }, this.crossOrigin && (file.data.crossOrigin = this.crossOrigin), file.data.src = this.baseURL + file.url;
                                break;

                              case "audio":
                                file.url = this.getAudioURL(file.url), null !== file.url ? this.game.sound.usingWebAudio ? this.xhrLoad(this._fileIndex, this.baseURL + file.url, "arraybuffer", "fileComplete", "fileError") : this.game.sound.usingAudioTag && (this.game.sound.touchLocked ? (file.data = new Audio(), 
                                file.data.name = file.key, file.data.preload = "auto", file.data.src = this.baseURL + file.url, 
                                this.fileComplete(this._fileIndex)) : (file.data = new Audio(), file.data.name = file.key, 
                                file.data.onerror = function() {
                                    return _this.fileError(_this._fileIndex);
                                }, file.data.preload = "auto", file.data.src = this.baseURL + file.url, file.data.addEventListener("canplaythrough", function() {
                                    Phaser.GAMES[_this.game.id].load.fileComplete(_this._fileIndex);
                                }, !1), file.data.load())) : this.fileError(this._fileIndex);
                                break;

                              case "json":
                                this.useXDomainRequest && window.XDomainRequest ? (this._ajax = new window.XDomainRequest(), 
                                this._ajax.timeout = 3e3, this._ajax.onerror = function() {
                                    return _this.dataLoadError(_this._fileIndex);
                                }, this._ajax.ontimeout = function() {
                                    return _this.dataLoadError(_this._fileIndex);
                                }, this._ajax.onprogress = function() {}, this._ajax.onload = function() {
                                    return _this.jsonLoadComplete(_this._fileIndex);
                                }, this._ajax.open("GET", this.baseURL + file.url, !0), setTimeout(function() {
                                    _this._ajax.send();
                                }, 0)) : this.xhrLoad(this._fileIndex, this.baseURL + file.url, "text", "jsonLoadComplete", "dataLoadError");
                                break;

                              case "xml":
                                this.xhrLoad(this._fileIndex, this.baseURL + file.url, "text", "xmlLoadComplete", "dataLoadError");
                                break;

                              case "tilemap":
                                if (file.format === Phaser.Tilemap.TILED_JSON) this.xhrLoad(this._fileIndex, this.baseURL + file.url, "text", "jsonLoadComplete", "dataLoadError"); else {
                                    if (file.format !== Phaser.Tilemap.CSV) throw new Error("Phaser.Loader. Invalid Tilemap format: " + file.format);
                                    this.xhrLoad(this._fileIndex, this.baseURL + file.url, "text", "csvLoadComplete", "dataLoadError");
                                }
                                break;

                              case "text":
                              case "script":
                              case "physics":
                                this.xhrLoad(this._fileIndex, this.baseURL + file.url, "text", "fileComplete", "fileError");
                                break;

                              case "binary":
                                this.xhrLoad(this._fileIndex, this.baseURL + file.url, "arraybuffer", "fileComplete", "fileError");
                            }
                        },
                        xhrLoad: function(index, url, type, onload, onerror) {
                            this._xhr.open("GET", url, !0), this._xhr.responseType = type;
                            var _this = this;
                            this._xhr.onload = function() {
                                return _this[onload](index);
                            }, this._xhr.onerror = function() {
                                return _this[onerror](index);
                            }, this._xhr.send();
                        },
                        getAudioURL: function(urls) {
                            var extension;
                            "string" == typeof urls && (urls = [ urls ]);
                            for (var i = 0; i < urls.length; i++) {
                                if (extension = urls[i].toLowerCase(), "blob:" === extension.substr(0, 5)) return urls[i];
                                if (extension = extension.substr((Math.max(0, extension.lastIndexOf(".")) || 1 / 0) + 1), 
                                extension.indexOf("?") >= 0 && (extension = extension.substr(0, extension.indexOf("?"))), 
                                this.game.device.canPlayAudio(extension)) return urls[i];
                            }
                            return null;
                        },
                        fileError: function(index) {
                            this._fileList[index].loaded = !0, this._fileList[index].error = !0, this.onFileError.dispatch(this._fileList[index].key, this._fileList[index]), 
                            console.warn("Phaser.Loader error loading file: " + this._fileList[index].key + " from URL " + this._fileList[index].url), 
                            this.nextFile(index, !1);
                        },
                        fileComplete: function(index) {
                            if (!this._fileList[index]) return void console.warn("Phaser.Loader fileComplete invalid index " + index);
                            var file = this._fileList[index];
                            file.loaded = !0;
                            var loadNext = !0;
                            switch (file.type) {
                              case "image":
                                this.game.cache.addImage(file.key, file.url, file.data);
                                break;

                              case "spritesheet":
                                this.game.cache.addSpriteSheet(file.key, file.url, file.data, file.frameWidth, file.frameHeight, file.frameMax, file.margin, file.spacing);
                                break;

                              case "textureatlas":
                                if (null == file.atlasURL) this.game.cache.addTextureAtlas(file.key, file.url, file.data, file.atlasData, file.format); else if (loadNext = !1, 
                                file.format == Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY || file.format == Phaser.Loader.TEXTURE_ATLAS_JSON_HASH) this.xhrLoad(this._fileIndex, this.baseURL + file.atlasURL, "text", "jsonLoadComplete", "dataLoadError"); else {
                                    if (file.format != Phaser.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + file.format);
                                    this.xhrLoad(this._fileIndex, this.baseURL + file.atlasURL, "text", "xmlLoadComplete", "dataLoadError");
                                }
                                break;

                              case "bitmapfont":
                                null == file.xmlURL ? this.game.cache.addBitmapFont(file.key, file.url, file.data, file.xmlData, file.xSpacing, file.ySpacing) : (loadNext = !1, 
                                this.xhrLoad(this._fileIndex, this.baseURL + file.xmlURL, "text", "xmlLoadComplete", "dataLoadError"));
                                break;

                              case "audio":
                                if (this.game.sound.usingWebAudio) {
                                    if (file.data = this._xhr.response, this.game.cache.addSound(file.key, file.url, file.data, !0, !1), 
                                    file.autoDecode) {
                                        var that = this, key = file.key;
                                        this.game.cache.updateSound(key, "isDecoding", !0), this.game.sound.context.decodeAudioData(file.data, function(buffer) {
                                            buffer && (that.game.cache.decodedSound(key, buffer), that.game.sound.onSoundDecode.dispatch(key, that.game.cache.getSound(key)));
                                        });
                                    }
                                } else file.data.removeEventListener("canplaythrough", Phaser.GAMES[this.game.id].load.fileComplete), 
                                this.game.cache.addSound(file.key, file.url, file.data, !1, !0);
                                break;

                              case "text":
                                file.data = this._xhr.responseText, this.game.cache.addText(file.key, file.url, file.data);
                                break;

                              case "physics":
                                var data = JSON.parse(this._xhr.responseText);
                                this.game.cache.addPhysicsData(file.key, file.url, data, file.format);
                                break;

                              case "script":
                                file.data = document.createElement("script"), file.data.language = "javascript", 
                                file.data.type = "text/javascript", file.data.defer = !1, file.data.text = this._xhr.responseText, 
                                document.head.appendChild(file.data), file.callback && (file.data = file.callback.call(file.callbackContext, file.key, this._xhr.responseText));
                                break;

                              case "binary":
                                file.data = file.callback ? file.callback.call(file.callbackContext, file.key, this._xhr.response) : this._xhr.response, 
                                this.game.cache.addBinary(file.key, file.data);
                            }
                            loadNext && this.nextFile(index, !0);
                        },
                        jsonLoadComplete: function(index) {
                            if (!this._fileList[index]) return void console.warn("Phaser.Loader jsonLoadComplete invalid index " + index);
                            var file = this._fileList[index];
                            if (this._ajax && this._ajax.responseText) var data = JSON.parse(this._ajax.responseText); else var data = JSON.parse(this._xhr.responseText);
                            file.loaded = !0, "tilemap" === file.type ? this.game.cache.addTilemap(file.key, file.url, data, file.format) : "json" === file.type ? this.game.cache.addJSON(file.key, file.url, data) : this.game.cache.addTextureAtlas(file.key, file.url, file.data, data, file.format), 
                            this.nextFile(index, !0);
                        },
                        csvLoadComplete: function(index) {
                            if (!this._fileList[index]) return void console.warn("Phaser.Loader csvLoadComplete invalid index " + index);
                            var file = this._fileList[index], data = this._xhr.responseText;
                            file.loaded = !0, this.game.cache.addTilemap(file.key, file.url, data, file.format), 
                            this.nextFile(index, !0);
                        },
                        dataLoadError: function(index) {
                            var file = this._fileList[index];
                            file.loaded = !0, file.error = !0, console.warn("Phaser.Loader dataLoadError: " + file.key), 
                            this.nextFile(index, !0);
                        },
                        xmlLoadComplete: function(index) {
                            "" !== this._xhr.responseType && "text" !== this._xhr.responseType && (console.warn("Invalid XML Response Type", this._fileList[index]), 
                            console.warn(this._xhr));
                            var xml, data = this._xhr.responseText;
                            try {
                                if (window.DOMParser) {
                                    var domparser = new DOMParser();
                                    xml = domparser.parseFromString(data, "text/xml");
                                } else xml = new ActiveXObject("Microsoft.XMLDOM"), xml.async = "false", xml.loadXML(data);
                            } catch (e) {
                                xml = void 0;
                            }
                            if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) throw new Error("Phaser.Loader. Invalid XML given");
                            var file = this._fileList[index];
                            file.loaded = !0, "bitmapfont" === file.type ? this.game.cache.addBitmapFont(file.key, file.url, file.data, xml, file.xSpacing, file.ySpacing) : "textureatlas" === file.type ? this.game.cache.addTextureAtlas(file.key, file.url, file.data, xml, file.format) : "xml" === file.type && this.game.cache.addXML(file.key, file.url, xml), 
                            this.nextFile(index, !0);
                        },
                        nextFile: function(previousIndex, success) {
                            this.progressFloat += this._progressChunk, this.progress = Math.round(this.progressFloat), 
                            this.progress > 100 && (this.progress = 100), null !== this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), 
                            this.preloadSprite.sprite.updateCrop()), this.onFileComplete.dispatch(this.progress, this._fileList[previousIndex].key, success, this.totalLoadedFiles(), this._fileList.length), 
                            this.totalQueuedFiles() > 0 ? (this._fileIndex++, this.loadFile()) : (this.hasLoaded = !0, 
                            this.isLoading = !1, this.removeAll(), this.onLoadComplete.dispatch());
                        },
                        totalLoadedFiles: function() {
                            for (var total = 0, i = 0; i < this._fileList.length; i++) this._fileList[i].loaded && total++;
                            return total;
                        },
                        totalQueuedFiles: function() {
                            for (var total = 0, i = 0; i < this._fileList.length; i++) this._fileList[i].loaded === !1 && total++;
                            return total;
                        },
                        totalLoadedPacks: function() {
                            for (var total = 0, i = 0; i < this._packList.length; i++) this._packList[i].loaded && total++;
                            return total;
                        },
                        totalQueuedPacks: function() {
                            for (var total = 0, i = 0; i < this._packList.length; i++) this._packList[i].loaded === !1 && total++;
                            return total;
                        }
                    }, Phaser.Loader.prototype.constructor = Phaser.Loader, Phaser.LoaderParser = {
                        bitmapFont: function(game, xml, cacheKey, xSpacing, ySpacing) {
                            var data = {}, info = xml.getElementsByTagName("info")[0], common = xml.getElementsByTagName("common")[0];
                            data.font = info.getAttribute("face"), data.size = parseInt(info.getAttribute("size"), 10), 
                            data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10) + ySpacing, data.chars = {};
                            for (var letters = xml.getElementsByTagName("char"), i = 0; i < letters.length; i++) {
                                var charCode = parseInt(letters[i].getAttribute("id"), 10), textureRect = new PIXI.Rectangle(parseInt(letters[i].getAttribute("x"), 10), parseInt(letters[i].getAttribute("y"), 10), parseInt(letters[i].getAttribute("width"), 10), parseInt(letters[i].getAttribute("height"), 10));
                                data.chars[charCode] = {
                                    xOffset: parseInt(letters[i].getAttribute("xoffset"), 10),
                                    yOffset: parseInt(letters[i].getAttribute("yoffset"), 10),
                                    xAdvance: parseInt(letters[i].getAttribute("xadvance"), 10) + xSpacing,
                                    kerning: {},
                                    texture: PIXI.TextureCache[cacheKey] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], textureRect)
                                };
                            }
                            var kernings = xml.getElementsByTagName("kerning");
                            for (i = 0; i < kernings.length; i++) {
                                var first = parseInt(kernings[i].getAttribute("first"), 10), second = parseInt(kernings[i].getAttribute("second"), 10), amount = parseInt(kernings[i].getAttribute("amount"), 10);
                                data.chars[second].kerning[first] = amount;
                            }
                            PIXI.BitmapText.fonts[cacheKey] = data;
                        }
                    }, Phaser.AudioSprite = function(game, key) {
                        this.game = game, this.key = key, this.config = this.game.cache.getJSON(key + "-audioatlas"), 
                        this.autoplayKey = null, this.autoplay = !1, this.sounds = {};
                        for (var k in this.config.spritemap) {
                            var marker = this.config.spritemap[k], sound = this.game.add.sound(this.key);
                            sound.addMarker(k, marker.start, marker.end - marker.start, null, marker.loop), 
                            this.sounds[k] = sound;
                        }
                        this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), 
                        this.autoplay = this.sounds[this.autoplayKey]);
                    }, Phaser.AudioSprite.prototype = {
                        play: function(marker, volume) {
                            return "undefined" == typeof volume && (volume = 1), this.sounds[marker].play(marker, null, volume);
                        },
                        stop: function(marker) {
                            if (marker) this.sounds[marker].stop(); else for (var key in this.sounds) this.sounds[key].stop();
                        },
                        get: function(marker) {
                            return this.sounds[marker];
                        }
                    }, Phaser.AudioSprite.prototype.constructor = Phaser.AudioSprite, Phaser.Sound = function(game, key, volume, loop, connect) {
                        "undefined" == typeof volume && (volume = 1), "undefined" == typeof loop && (loop = !1), 
                        "undefined" == typeof connect && (connect = game.sound.connectToMaster), this.game = game, 
                        this.name = key, this.key = key, this.loop = loop, this.volume = volume, this.markers = {}, 
                        this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, 
                        this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, 
                        this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, 
                        this.isPlaying = !1, this.currentMarker = "", this.pendingPlayback = !1, this.override = !1, 
                        this.allowMultiple = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, 
                        this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this.usingWebAudio ? (this.context = this.game.sound.context, 
                        this.masterGainNode = this.game.sound.masterGain, this.gainNode = "undefined" == typeof this.context.createGain ? this.context.createGainNode() : this.context.createGain(), 
                        this.gainNode.gain.value = volume * this.game.sound.volume, connect && this.gainNode.connect(this.masterGainNode)) : this.game.cache.getSound(key) && this.game.cache.isSoundReady(key) ? (this._sound = this.game.cache.getSoundData(key), 
                        this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this), 
                        this.onDecoded = new Phaser.Signal(), this.onPlay = new Phaser.Signal(), this.onPause = new Phaser.Signal(), 
                        this.onResume = new Phaser.Signal(), this.onLoop = new Phaser.Signal(), this.onStop = new Phaser.Signal(), 
                        this.onMute = new Phaser.Signal(), this.onMarkerComplete = new Phaser.Signal(), 
                        this.onFadeComplete = new Phaser.Signal(), this._volume = volume, this._buffer = null, 
                        this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, 
                        this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1;
                    }, Phaser.Sound.prototype = {
                        soundHasUnlocked: function(key) {
                            key === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration);
                        },
                        addMarker: function(name, start, duration, volume, loop) {
                            "undefined" == typeof volume && (volume = 1), "undefined" == typeof loop && (loop = !1), 
                            this.markers[name] = {
                                name: name,
                                start: start,
                                stop: start + duration,
                                volume: volume,
                                duration: duration,
                                durationMS: 1e3 * duration,
                                loop: loop
                            };
                        },
                        removeMarker: function(name) {
                            delete this.markers[name];
                        },
                        update: function() {
                            this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), 
                            this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, 
                            this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), 
                            this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), 
                            "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time) : (this.onMarkerComplete.dispatch(this.currentMarker, this), 
                            this.play(this.currentMarker, 0, this.volume, !0, !0))) : this.stop() : this.loop ? (this.onLoop.dispatch(this), 
                            this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()));
                        },
                        play: function(marker, position, volume, loop, forceRestart) {
                            if (("undefined" == typeof marker || marker === !1 || null === marker) && (marker = ""), 
                            "undefined" == typeof forceRestart && (forceRestart = !0), this.isPlaying && !this.allowMultiple && !forceRestart && !this.override) return this;
                            if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || forceRestart)) if (this.usingWebAudio) if ("undefined" == typeof this._sound.stop) this._sound.noteOff(0); else try {
                                this._sound.stop(0);
                            } catch (e) {} else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                            if ("" === marker && Object.keys(this.markers).length > 0) return this;
                            if ("" !== marker) {
                                if (this.currentMarker = marker, !this.markers[marker]) return console.warn("Phaser.Sound.play: audio marker " + marker + " doesn't exist"), 
                                this;
                                this.position = this.markers[marker].start, this.volume = this.markers[marker].volume, 
                                this.loop = this.markers[marker].loop, this.duration = this.markers[marker].duration, 
                                this.durationMS = this.markers[marker].durationMS, "undefined" != typeof volume && (this.volume = volume), 
                                "undefined" != typeof loop && (this.loop = loop), this._tempMarker = marker, this._tempPosition = this.position, 
                                this._tempVolume = this.volume, this._tempLoop = this.loop;
                            } else position = position || 0, "undefined" == typeof volume && (volume = this._volume), 
                            "undefined" == typeof loop && (loop = this.loop), this.position = position, this.volume = volume, 
                            this.loop = loop, this.duration = 0, this.durationMS = 0, this._tempMarker = marker, 
                            this._tempPosition = position, this._tempVolume = volume, this._tempLoop = loop;
                            return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (null === this._buffer && (this._buffer = this.game.cache.getSoundData(this.key)), 
                            this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, 
                            this._sound.connect(this.externalNode ? this.externalNode : this.gainNode), this.totalDuration = this._sound.buffer.duration, 
                            0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), 
                            this.loop && "" === marker && (this._sound.loop = !0), "undefined" == typeof this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this._sound.start(0, this.position, this.duration), 
                            this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, 
                            this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, 
                            this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).isDecoding === !1 && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), 
                            this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), 
                            this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, 
                            this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, 
                            this._sound.muted = this._muted, this._sound.volume = this._muted ? 0 : this._volume, 
                            this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, 
                            this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, 
                            this;
                        },
                        restart: function(marker, position, volume, loop) {
                            marker = marker || "", position = position || 0, volume = volume || 1, "undefined" == typeof loop && (loop = !1), 
                            this.play(marker, position, volume, loop, !0);
                        },
                        pause: function() {
                            this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, 
                            this.pausedTime = this.game.time.time, this.onPause.dispatch(this), this.stop());
                        },
                        resume: function() {
                            if (this.paused && this._sound) {
                                if (this.usingWebAudio) {
                                    var p = this.position + this.pausedPosition / 1e3;
                                    this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, 
                                    this._sound.connect(this.externalNode ? this.externalNode : this.gainNode), this.loop && (this._sound.loop = !0), 
                                    "undefined" == typeof this._sound.start ? this._sound.noteGrainOn(0, p, this.duration) : this._sound.start(0, p, this.duration);
                                } else this._sound.play();
                                this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, 
                                this.onResume.dispatch(this);
                            }
                        },
                        stop: function() {
                            if (this.isPlaying && this._sound) if (this.usingWebAudio) if ("undefined" == typeof this._sound.stop) this._sound.noteOff(0); else try {
                                this._sound.stop(0);
                            } catch (e) {} else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                            this.isPlaying = !1;
                            var prevMarker = this.currentMarker;
                            "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), 
                            this.currentMarker = "", this.paused || this.onStop.dispatch(this, prevMarker);
                        },
                        fadeIn: function(duration, loop) {
                            "undefined" == typeof loop && (loop = !1), this.paused || (this.play("", 0, 0, loop), 
                            this.fadeTo(duration, 1));
                        },
                        fadeOut: function(duration) {
                            this.fadeTo(duration, 0);
                        },
                        fadeTo: function(duration, volume) {
                            if (this.isPlaying && !this.paused && volume !== this.volume) {
                                if ("undefined" == typeof duration && (duration = 1e3), "undefined" == typeof volume) return void console.warn("Phaser.Sound.fadeTo: No Volume Specified.");
                                var tween = this.game.add.tween(this).to({
                                    volume: volume
                                }, duration, Phaser.Easing.Linear.None, !0);
                                tween.onComplete.add(this.fadeComplete, this);
                            }
                        },
                        fadeComplete: function() {
                            this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop();
                        },
                        destroy: function(remove) {
                            "undefined" == typeof remove && (remove = !0), this.stop(), remove ? this.game.sound.remove(this) : (this.markers = {}, 
                            this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), 
                            this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), 
                            this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose());
                        }
                    }, Phaser.Sound.prototype.constructor = Phaser.Sound, Object.defineProperty(Phaser.Sound.prototype, "isDecoding", {
                        get: function() {
                            return this.game.cache.getSound(this.key).isDecoding;
                        }
                    }), Object.defineProperty(Phaser.Sound.prototype, "isDecoded", {
                        get: function() {
                            return this.game.cache.isSoundDecoded(this.key);
                        }
                    }), Object.defineProperty(Phaser.Sound.prototype, "mute", {
                        get: function() {
                            return this._muted || this.game.sound.mute;
                        },
                        set: function(value) {
                            value = value || null, value ? (this._muted = !0, this.usingWebAudio ? (this._muteVolume = this.gainNode.gain.value, 
                            this.gainNode.gain.value = 0) : this.usingAudioTag && this._sound && (this._muteVolume = this._sound.volume, 
                            this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), 
                            this.onMute.dispatch(this);
                        }
                    }), Object.defineProperty(Phaser.Sound.prototype, "volume", {
                        get: function() {
                            return this._volume;
                        },
                        set: function(value) {
                            this.usingWebAudio ? (this._volume = value, this.gainNode.gain.value = value) : this.usingAudioTag && this._sound && value >= 0 && 1 >= value && (this._volume = value, 
                            this._sound.volume = value);
                        }
                    }), Phaser.SoundManager = function(game) {
                        this.game = game, this.onSoundDecode = new Phaser.Signal(), this._codeMuted = !1, 
                        this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], 
                        this.context = null, this.usingWebAudio = !0, this.usingAudioTag = !1, this.noAudio = !1, 
                        this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32;
                    }, Phaser.SoundManager.prototype = {
                        boot: function() {
                            if (this.game.device.iOS && this.game.device.webAudio === !1 && (this.channels = 1), 
                            !this.game.device.cocoonJS && this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? (this.game.input.touch.callbackContext = this, 
                            this.game.input.touch.touchStartCallback = this.unlock, this.game.input.mouse.callbackContext = this, 
                            this.game.input.mouse.mouseDownCallback = this.unlock, this.touchLocked = !0) : this.touchLocked = !1, 
                            window.PhaserGlobal) {
                                if (window.PhaserGlobal.disableAudio === !0) return this.usingWebAudio = !1, void (this.noAudio = !0);
                                if (window.PhaserGlobal.disableWebAudio === !0) return this.usingWebAudio = !1, 
                                this.usingAudioTag = !0, void (this.noAudio = !1);
                            }
                            if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext; else if (window.AudioContext) try {
                                this.context = new window.AudioContext();
                            } catch (error) {
                                this.context = null, this.usingWebAudio = !1, this.noAudio = !0;
                            } else if (window.webkitAudioContext) try {
                                this.context = new window.webkitAudioContext();
                            } catch (error) {
                                this.context = null, this.usingWebAudio = !1, this.noAudio = !0;
                            }
                            window.Audio && null === this.context && (this.usingWebAudio = !1, this.usingAudioTag = !0, 
                            this.noAudio = !1), null !== this.context && (this.masterGain = "undefined" == typeof this.context.createGain ? this.context.createGainNode() : this.context.createGain(), 
                            this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination));
                        },
                        unlock: function() {
                            if (this.touchLocked !== !1) if (this.game.device.webAudio === !1 || window.PhaserGlobal && window.PhaserGlobal.disableWebAudio === !0) this.touchLocked = !1, 
                            this._unlockSource = null, this.game.input.touch.callbackContext = null, this.game.input.touch.touchStartCallback = null, 
                            this.game.input.mouse.callbackContext = null, this.game.input.mouse.mouseDownCallback = null; else {
                                var buffer = this.context.createBuffer(1, 1, 22050);
                                this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = buffer, 
                                this._unlockSource.connect(this.context.destination), this._unlockSource.noteOn(0);
                            }
                        },
                        stopAll: function() {
                            for (var i = 0; i < this._sounds.length; i++) this._sounds[i] && this._sounds[i].stop();
                        },
                        pauseAll: function() {
                            for (var i = 0; i < this._sounds.length; i++) this._sounds[i] && this._sounds[i].pause();
                        },
                        resumeAll: function() {
                            for (var i = 0; i < this._sounds.length; i++) this._sounds[i] && this._sounds[i].resume();
                        },
                        decode: function(key, sound) {
                            sound = sound || null;
                            var soundData = this.game.cache.getSoundData(key);
                            if (soundData && this.game.cache.isSoundDecoded(key) === !1) {
                                this.game.cache.updateSound(key, "isDecoding", !0);
                                var that = this;
                                this.context.decodeAudioData(soundData, function(buffer) {
                                    that.game.cache.decodedSound(key, buffer), sound && that.onSoundDecode.dispatch(key, sound);
                                });
                            }
                        },
                        update: function() {
                            this.touchLocked && this.game.device.webAudio && null !== this._unlockSource && (this._unlockSource.playbackState === this._unlockSource.PLAYING_STATE || this._unlockSource.playbackState === this._unlockSource.FINISHED_STATE) && (this.touchLocked = !1, 
                            this._unlockSource = null, this.game.input.touch.callbackContext = null, this.game.input.touch.touchStartCallback = null);
                            for (var i = 0; i < this._sounds.length; i++) this._sounds[i].update();
                        },
                        add: function(key, volume, loop, connect) {
                            "undefined" == typeof volume && (volume = 1), "undefined" == typeof loop && (loop = !1), 
                            "undefined" == typeof connect && (connect = this.connectToMaster);
                            var sound = new Phaser.Sound(this.game, key, volume, loop, connect);
                            return this._sounds.push(sound), sound;
                        },
                        addSprite: function(key) {
                            var audioSprite = new Phaser.AudioSprite(this.game, key);
                            return audioSprite;
                        },
                        remove: function(sound) {
                            for (var i = this._sounds.length; i--; ) if (this._sounds[i] === sound) return this._sounds[i].destroy(!1), 
                            this._sounds.splice(i, 1), !0;
                            return !1;
                        },
                        removeByKey: function(key) {
                            for (var i = this._sounds.length, removed = 0; i--; ) this._sounds[i].key === key && (this._sounds[i].destroy(!1), 
                            this._sounds.splice(i, 1), removed++);
                            return removed;
                        },
                        play: function(key, volume, loop) {
                            var sound = this.add(key, volume, loop);
                            return sound.play(), sound;
                        },
                        setMute: function() {
                            if (!this._muted) {
                                this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, 
                                this.masterGain.gain.value = 0);
                                for (var i = 0; i < this._sounds.length; i++) this._sounds[i].usingAudioTag && (this._sounds[i].mute = !0);
                            }
                        },
                        unsetMute: function() {
                            if (this._muted && !this._codeMuted) {
                                this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                                for (var i = 0; i < this._sounds.length; i++) this._sounds[i].usingAudioTag && (this._sounds[i].mute = !1);
                            }
                        },
                        destroy: function() {
                            this.stopAll();
                            for (var i = 0; i < this._sounds.length; i++) this._sounds[i] && this._sounds[i].destroy();
                            this._sounds = [], this.onSoundDecode.dispose(), this.context && window.PhaserGlobal && (window.PhaserGlobal.audioContext = this.context);
                        }
                    }, Phaser.SoundManager.prototype.constructor = Phaser.SoundManager, Object.defineProperty(Phaser.SoundManager.prototype, "mute", {
                        get: function() {
                            return this._muted;
                        },
                        set: function(value) {
                            if (value = value || null) {
                                if (this._muted) return;
                                this._codeMuted = !0, this.setMute();
                            } else {
                                if (!this._muted) return;
                                this._codeMuted = !1, this.unsetMute();
                            }
                        }
                    }), Object.defineProperty(Phaser.SoundManager.prototype, "volume", {
                        get: function() {
                            return this.usingWebAudio ? this.masterGain.gain.value : this._volume;
                        },
                        set: function(value) {
                            if (this._volume = value, this.usingWebAudio) this.masterGain.gain.value = value; else for (var i = 0; i < this._sounds.length; i++) this._sounds[i].usingAudioTag && (this._sounds[i].volume = this._sounds[i].volume * value);
                        }
                    }), Phaser.ArraySet = function(list) {
                        this.position = 0, this.list = list || [];
                    }, Phaser.ArraySet.prototype = {
                        add: function(item) {
                            return this.exists(item) || this.list.push(item), item;
                        },
                        getIndex: function(item) {
                            return this.list.indexOf(item);
                        },
                        exists: function(item) {
                            return this.list.indexOf(item) > -1;
                        },
                        reset: function() {
                            this.list.length = 0;
                        },
                        remove: function(item) {
                            var idx = this.list.indexOf(item);
                            return idx > -1 ? (this.list.splice(idx, 1), item) : void 0;
                        },
                        setAll: function(key, value) {
                            for (var i = this.list.length; i--; ) this.list[i] && (this.list[i][key] = value);
                        },
                        callAll: function(key) {
                            for (var args = Array.prototype.splice.call(arguments, 1), i = this.list.length; i--; ) this.list[i] && this.list[i][key] && this.list[i][key].apply(this.list[i], args);
                        }
                    }, Object.defineProperty(Phaser.ArraySet.prototype, "total", {
                        get: function() {
                            return this.list.length;
                        }
                    }), Object.defineProperty(Phaser.ArraySet.prototype, "first", {
                        get: function() {
                            return this.position = 0, this.list.length > 0 ? this.list[0] : null;
                        }
                    }), Object.defineProperty(Phaser.ArraySet.prototype, "next", {
                        get: function() {
                            return this.position < this.list.length ? (this.position++, this.list[this.position]) : null;
                        }
                    }), Phaser.ArraySet.prototype.constructor = Phaser.ArraySet, Phaser.ArrayList = Phaser.ArraySet, 
                    Phaser.LinkedList = function() {
                        this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0;
                    }, Phaser.LinkedList.prototype = {
                        add: function(item) {
                            return 0 === this.total && null === this.first && null === this.last ? (this.first = item, 
                            this.last = item, this.next = item, item.prev = this, this.total++, item) : (this.last.next = item, 
                            item.prev = this.last, this.last = item, this.total++, item);
                        },
                        reset: function() {
                            this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0;
                        },
                        remove: function(item) {
                            return 1 === this.total ? (this.reset(), void (item.next = item.prev = null)) : (item === this.first ? this.first = this.first.next : item === this.last && (this.last = this.last.prev), 
                            item.prev && (item.prev.next = item.next), item.next && (item.next.prev = item.prev), 
                            item.next = item.prev = null, null === this.first && (this.last = null), void this.total--);
                        },
                        callAll: function(callback) {
                            if (this.first && this.last) {
                                var entity = this.first;
                                do entity && entity[callback] && entity[callback].call(entity), entity = entity.next; while (entity != this.last.next);
                            }
                        }
                    }, Phaser.LinkedList.prototype.constructor = Phaser.LinkedList, Phaser.ArrayUtils = {
                        getRandomItem: function(objects, startIndex, length) {
                            if (null == objects) return null;
                            "undefined" == typeof startIndex && (startIndex = 0), "undefined" == typeof length && (length = objects.length);
                            var randomIndex = startIndex + Math.floor(Math.random() * length);
                            return void 0 === objects[randomIndex] ? null : objects[randomIndex];
                        },
                        removeRandomItem: function(objects, startIndex, length) {
                            if (null == objects) return null;
                            "undefined" == typeof startIndex && (startIndex = 0), "undefined" == typeof length && (length = objects.length);
                            var randomIndex = startIndex + Math.floor(Math.random() * length);
                            if (randomIndex < objects.length) {
                                var removed = objects.splice(randomIndex, 1);
                                return void 0 === removed[0] ? null : removed[0];
                            }
                            return null;
                        },
                        shuffle: function(array) {
                            for (var i = array.length - 1; i > 0; i--) {
                                var j = Math.floor(Math.random() * (i + 1)), temp = array[i];
                                array[i] = array[j], array[j] = temp;
                            }
                            return array;
                        },
                        transposeMatrix: function(array) {
                            for (var sourceRowCount = array.length, sourceColCount = array[0].length, result = new Array(sourceColCount), i = 0; sourceColCount > i; i++) {
                                result[i] = new Array(sourceRowCount);
                                for (var j = sourceRowCount - 1; j > -1; j--) result[i][j] = array[j][i];
                            }
                            return result;
                        },
                        rotateMatrix: function(matrix, direction) {
                            if ("string" != typeof direction && (direction = (direction % 360 + 360) % 360), 
                            90 === direction || -270 === direction || "rotateLeft" === direction) matrix = Phaser.ArrayUtils.transposeMatrix(matrix), 
                            matrix = matrix.reverse(); else if (-90 === direction || 270 === direction || "rotateRight" === direction) matrix = matrix.reverse(), 
                            matrix = Phaser.ArrayUtils.transposeMatrix(matrix); else if (180 === Math.abs(direction) || "rotate180" === direction) {
                                for (var i = 0; i < matrix.length; i++) matrix[i].reverse();
                                matrix = matrix.reverse();
                            }
                            return matrix;
                        },
                        findClosest: function(value, arr) {
                            if (!arr.length) return 0 / 0;
                            if (1 === arr.length || value < arr[0]) return arr[0];
                            for (var i = 1; arr[i] < value; ) i++;
                            var low = arr[i - 1], high = i < arr.length ? arr[i] : Number.POSITIVE_INFINITY;
                            return value - low >= high - value ? high : low;
                        },
                        rotate: function(array) {
                            var s = array.shift();
                            return array.push(s), s;
                        },
                        numberArray: function(start, end) {
                            for (var result = [], i = start; end >= i; i++) result.push(i);
                            return result;
                        },
                        numberArrayStep: function(start, end, step) {
                            start = +start || 0;
                            var type = typeof end;
                            "number" !== type && "string" !== type || !step || step[end] !== start || (end = step = null), 
                            step = null == step ? 1 : +step || 0, null === end ? (end = start, start = 0) : end = +end || 0;
                            for (var index = -1, length = Math.max(Phaser.Math.roundAwayFromZero((end - start) / (step || 1)), 0), result = new Array(length); ++index < length; ) result[index] = start, 
                            start += step;
                            return result;
                        }
                    }, Phaser.Utils.Debug = function(game) {
                        this.game = game, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, 
                        this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.renderShadow = !0, 
                        this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1;
                    }, Phaser.Utils.Debug.prototype = {
                        boot: function() {
                            this.game.renderType === Phaser.CANVAS ? this.context = this.game.context : (this.bmd = this.game.make.bitmapData(this.game.width, this.game.height), 
                            this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), 
                            this.canvas = Phaser.Canvas.create(this.game.width, this.game.height, "", !0), this.context = this.canvas.getContext("2d"));
                        },
                        preUpdate: function() {
                            this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), 
                            this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1);
                        },
                        reset: function() {
                            this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), 
                            this.sprite && this.bmd.clear();
                        },
                        start: function(x, y, color, columnWidth) {
                            "number" != typeof x && (x = 0), "number" != typeof y && (y = 0), color = color || "rgb(255,255,255)", 
                            "undefined" == typeof columnWidth && (columnWidth = 0), this.currentX = x, this.currentY = y, 
                            this.currentColor = color, this.currentAlpha = this.context.globalAlpha, this.columnWidth = columnWidth, 
                            this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), 
                            this.context.strokeStyle = color, this.context.fillStyle = color, this.context.font = this.font, 
                            this.context.globalAlpha = 1;
                        },
                        stop: function() {
                            this.context.restore(), this.context.globalAlpha = this.currentAlpha;
                        },
                        line: function() {
                            for (var x = this.currentX, i = 0; i < arguments.length; i++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", 
                            this.context.fillText(arguments[i], x + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), 
                            this.context.fillText(arguments[i], x, this.currentY), x += this.columnWidth;
                            this.currentY += this.lineHeight;
                        },
                        soundInfo: function(sound, x, y, color) {
                            this.start(x, y, color), this.line("Sound: " + sound.key + " Locked: " + sound.game.sound.touchLocked), 
                            this.line("Is Ready?: " + this.game.cache.isSoundReady(sound.key) + " Pending Playback: " + sound.pendingPlayback), 
                            this.line("Decoded: " + sound.isDecoded + " Decoding: " + sound.isDecoding), this.line("Total Duration: " + sound.totalDuration + " Playing: " + sound.isPlaying), 
                            this.line("Time: " + sound.currentTime), this.line("Volume: " + sound.volume + " Muted: " + sound.mute), 
                            this.line("WebAudio: " + sound.usingWebAudio + " Audio: " + sound.usingAudioTag), 
                            "" !== sound.currentMarker && (this.line("Marker: " + sound.currentMarker + " Duration: " + sound.duration + " (ms: " + sound.durationMS + ")"), 
                            this.line("Start: " + sound.markers[sound.currentMarker].start + " Stop: " + sound.markers[sound.currentMarker].stop), 
                            this.line("Position: " + sound.position)), this.stop();
                        },
                        cameraInfo: function(camera, x, y, color) {
                            this.start(x, y, color), this.line("Camera (" + camera.width + " x " + camera.height + ")"), 
                            this.line("X: " + camera.x + " Y: " + camera.y), camera.bounds && this.line("Bounds x: " + camera.bounds.x + " Y: " + camera.bounds.y + " w: " + camera.bounds.width + " h: " + camera.bounds.height), 
                            this.line("View x: " + camera.view.x + " Y: " + camera.view.y + " w: " + camera.view.width + " h: " + camera.view.height), 
                            this.line("Total in view: " + camera.totalInView), this.stop();
                        },
                        timer: function(timer, x, y, color) {
                            this.start(x, y, color), this.line("Timer (running: " + timer.running + " expired: " + timer.expired + ")"), 
                            this.line("Next Tick: " + timer.next + " Duration: " + timer.duration), this.line("Paused: " + timer.paused + " Length: " + timer.length), 
                            this.stop();
                        },
                        pointer: function(pointer, hideIfUp, downColor, upColor, color) {
                            null != pointer && ("undefined" == typeof hideIfUp && (hideIfUp = !1), downColor = downColor || "rgba(0,255,0,0.5)", 
                            upColor = upColor || "rgba(255,0,0,0.5)", (hideIfUp !== !0 || pointer.isUp !== !0) && (this.start(pointer.x, pointer.y - 100, color), 
                            this.context.beginPath(), this.context.arc(pointer.x, pointer.y, pointer.circle.radius, 0, 2 * Math.PI), 
                            this.context.fillStyle = pointer.active ? downColor : upColor, this.context.fill(), 
                            this.context.closePath(), this.context.beginPath(), this.context.moveTo(pointer.positionDown.x, pointer.positionDown.y), 
                            this.context.lineTo(pointer.position.x, pointer.position.y), this.context.lineWidth = 2, 
                            this.context.stroke(), this.context.closePath(), this.line("ID: " + pointer.id + " Active: " + pointer.active), 
                            this.line("World X: " + pointer.worldX + " World Y: " + pointer.worldY), this.line("Screen X: " + pointer.x + " Screen Y: " + pointer.y), 
                            this.line("Duration: " + pointer.duration + " ms"), this.line("is Down: " + pointer.isDown + " is Up: " + pointer.isUp), 
                            this.stop()));
                        },
                        spriteInputInfo: function(sprite, x, y, color) {
                            this.start(x, y, color), this.line("Sprite Input: (" + sprite.width + " x " + sprite.height + ")"), 
                            this.line("x: " + sprite.input.pointerX().toFixed(1) + " y: " + sprite.input.pointerY().toFixed(1)), 
                            this.line("over: " + sprite.input.pointerOver() + " duration: " + sprite.input.overDuration().toFixed(0)), 
                            this.line("down: " + sprite.input.pointerDown() + " duration: " + sprite.input.downDuration().toFixed(0)), 
                            this.line("just over: " + sprite.input.justOver() + " just out: " + sprite.input.justOut()), 
                            this.stop();
                        },
                        key: function(key, x, y, color) {
                            this.start(x, y, color, 150), this.line("Key:", key.keyCode, "isDown:", key.isDown), 
                            this.line("justDown:", key.justDown, "justUp:", key.justUp), this.line("Time Down:", key.timeDown.toFixed(0), "duration:", key.duration.toFixed(0)), 
                            this.stop();
                        },
                        inputInfo: function(x, y, color) {
                            this.start(x, y, color), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), 
                            this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), 
                            this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), 
                            this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), 
                            this.stop();
                        },
                        spriteBounds: function(sprite, color, filled) {
                            var bounds = sprite.getBounds();
                            bounds.x += this.game.camera.x, bounds.y += this.game.camera.y, this.rectangle(bounds, color, filled);
                        },
                        ropeSegments: function(rope, color, filled) {
                            var segments = rope.segments;
                            segments.forEach(function(segment) {
                                this.rectangle(segment, color, filled);
                            }, this);
                        },
                        spriteInfo: function(sprite, x, y, color) {
                            this.start(x, y, color), this.line("Sprite:  (" + sprite.width + " x " + sprite.height + ") anchor: " + sprite.anchor.x + " x " + sprite.anchor.y), 
                            this.line("x: " + sprite.x.toFixed(1) + " y: " + sprite.y.toFixed(1)), this.line("angle: " + sprite.angle.toFixed(1) + " rotation: " + sprite.rotation.toFixed(1)), 
                            this.line("visible: " + sprite.visible + " in camera: " + sprite.inCamera), this.line("bounds x: " + sprite._bounds.x.toFixed(1) + " y: " + sprite._bounds.y.toFixed(1) + " w: " + sprite._bounds.width.toFixed(1) + " h: " + sprite._bounds.height.toFixed(1)), 
                            this.stop();
                        },
                        spriteCoords: function(sprite, x, y, color) {
                            this.start(x, y, color, 100), sprite.name && this.line(sprite.name), this.line("x:", sprite.x.toFixed(2), "y:", sprite.y.toFixed(2)), 
                            this.line("pos x:", sprite.position.x.toFixed(2), "pos y:", sprite.position.y.toFixed(2)), 
                            this.line("world x:", sprite.world.x.toFixed(2), "world y:", sprite.world.y.toFixed(2)), 
                            this.stop();
                        },
                        lineInfo: function(line, x, y, color) {
                            this.start(x, y, color, 80), this.line("start.x:", line.start.x.toFixed(2), "start.y:", line.start.y.toFixed(2)), 
                            this.line("end.x:", line.end.x.toFixed(2), "end.y:", line.end.y.toFixed(2)), this.line("length:", line.length.toFixed(2), "angle:", line.angle), 
                            this.stop();
                        },
                        pixel: function(x, y, color, size) {
                            size = size || 2, this.start(), this.context.fillStyle = color, this.context.fillRect(x, y, size, size), 
                            this.stop();
                        },
                        geom: function(object, color, filled, forceType) {
                            "undefined" == typeof filled && (filled = !0), "undefined" == typeof forceType && (forceType = 0), 
                            color = color || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = color, 
                            this.context.strokeStyle = color, object instanceof Phaser.Rectangle || 1 === forceType ? filled ? this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height) : this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height) : object instanceof Phaser.Circle || 2 === forceType ? (this.context.beginPath(), 
                            this.context.arc(object.x - this.game.camera.x, object.y - this.game.camera.y, object.radius, 0, 2 * Math.PI, !1), 
                            this.context.closePath(), filled ? this.context.fill() : this.context.stroke()) : object instanceof Phaser.Point || 3 === forceType ? this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, 4, 4) : (object instanceof Phaser.Line || 4 === forceType) && (this.context.lineWidth = 1, 
                            this.context.beginPath(), this.context.moveTo(object.start.x + .5 - this.game.camera.x, object.start.y + .5 - this.game.camera.y), 
                            this.context.lineTo(object.end.x + .5 - this.game.camera.x, object.end.y + .5 - this.game.camera.y), 
                            this.context.closePath(), this.context.stroke()), this.stop();
                        },
                        rectangle: function(object, color, filled) {
                            "undefined" == typeof filled && (filled = !0), color = color || "rgba(0, 255, 0, 0.4)", 
                            this.start(), filled ? (this.context.fillStyle = color, this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height)) : (this.context.strokeStyle = color, 
                            this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height)), 
                            this.stop();
                        },
                        text: function(text, x, y, color, font) {
                            color = color || "rgb(255,255,255)", font = font || "16px Courier", this.start(), 
                            this.context.font = font, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", 
                            this.context.fillText(text, x + 1, y + 1)), this.context.fillStyle = color, this.context.fillText(text, x, y), 
                            this.stop();
                        },
                        quadTree: function(quadtree, color) {
                            color = color || "rgba(255,0,0,0.3)", this.start();
                            var bounds = quadtree.bounds;
                            if (0 === quadtree.nodes.length) {
                                this.context.strokeStyle = color, this.context.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height), 
                                this.text("size: " + quadtree.objects.length, bounds.x + 4, bounds.y + 16, "rgb(0,200,0)", "12px Courier"), 
                                this.context.strokeStyle = "rgb(0,255,0)";
                                for (var i = 0; i < quadtree.objects.length; i++) this.context.strokeRect(quadtree.objects[i].x, quadtree.objects[i].y, quadtree.objects[i].width, quadtree.objects[i].height);
                            } else for (var i = 0; i < quadtree.nodes.length; i++) this.quadTree(quadtree.nodes[i]);
                            this.stop();
                        },
                        body: function(sprite, color, filled) {
                            sprite.body && (this.start(), sprite.body.type === Phaser.Physics.ARCADE ? Phaser.Physics.Arcade.Body.render(this.context, sprite.body, color, filled) : sprite.body.type === Phaser.Physics.NINJA ? Phaser.Physics.Ninja.Body.render(this.context, sprite.body, color, filled) : sprite.body.type === Phaser.Physics.BOX2D && Phaser.Physics.Box2D.renderBody(this.context, sprite.body, color), 
                            this.stop());
                        },
                        bodyInfo: function(sprite, x, y, color) {
                            sprite.body && (this.start(x, y, color, 210), sprite.body.type === Phaser.Physics.ARCADE ? Phaser.Physics.Arcade.Body.renderBodyInfo(this, sprite.body) : sprite.body.type === Phaser.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, sprite.body), 
                            this.stop());
                        },
                        box2dWorld: function() {
                            this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), 
                            this.game.physics.box2d.renderDebugDraw(this.context), this.stop();
                        },
                        box2dBody: function(body, color) {
                            this.start(), Phaser.Physics.Box2D.renderBody(this.context, body, color), this.stop();
                        }
                    }, Phaser.Utils.Debug.prototype.constructor = Phaser.Utils.Debug, Phaser.Color = {
                        packPixel: function(r, g, b, a) {
                            return Phaser.Device.LITTLE_ENDIAN ? (a << 24 | b << 16 | g << 8 | r) >>> 0 : (r << 24 | g << 16 | b << 8 | a) >>> 0;
                        },
                        unpackPixel: function(rgba, out, hsl, hsv) {
                            return ("undefined" == typeof out || null === out) && (out = Phaser.Color.createColor()), 
                            ("undefined" == typeof hsl || null === hsl) && (hsl = !1), ("undefined" == typeof hsv || null === hsv) && (hsv = !1), 
                            Phaser.Device.LITTLE_ENDIAN ? (out.a = (4278190080 & rgba) >>> 24, out.b = (16711680 & rgba) >>> 16, 
                            out.g = (65280 & rgba) >>> 8, out.r = 255 & rgba) : (out.r = (4278190080 & rgba) >>> 24, 
                            out.g = (16711680 & rgba) >>> 16, out.b = (65280 & rgba) >>> 8, out.a = 255 & rgba), 
                            out.color = rgba, out.rgba = "rgba(" + out.r + "," + out.g + "," + out.b + "," + out.a / 255 + ")", 
                            hsl && Phaser.Color.RGBtoHSL(out.r, out.g, out.b, out), hsv && Phaser.Color.RGBtoHSV(out.r, out.g, out.b, out), 
                            out;
                        },
                        fromRGBA: function(rgba, out) {
                            return out || (out = Phaser.Color.createColor()), out.r = (4278190080 & rgba) >>> 24, 
                            out.g = (16711680 & rgba) >>> 16, out.b = (65280 & rgba) >>> 8, out.a = 255 & rgba, 
                            out.rgba = "rgba(" + out.r + "," + out.g + "," + out.b + "," + out.a + ")", out;
                        },
                        toRGBA: function(r, g, b, a) {
                            return r << 24 | g << 16 | b << 8 | a;
                        },
                        RGBtoHSL: function(r, g, b, out) {
                            out || (out = Phaser.Color.createColor(r, g, b, 1)), r /= 255, g /= 255, b /= 255;
                            var min = Math.min(r, g, b), max = Math.max(r, g, b);
                            if (out.h = 0, out.s = 0, out.l = (max + min) / 2, max !== min) {
                                var d = max - min;
                                out.s = out.l > .5 ? d / (2 - max - min) : d / (max + min), max === r ? out.h = (g - b) / d + (b > g ? 6 : 0) : max === g ? out.h = (b - r) / d + 2 : max === b && (out.h = (r - g) / d + 4), 
                                out.h /= 6;
                            }
                            return out;
                        },
                        HSLtoRGB: function(h, s, l, out) {
                            if (out ? (out.r = l, out.g = l, out.b = l) : out = Phaser.Color.createColor(l, l, l), 
                            0 !== s) {
                                var q = .5 > l ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
                                out.r = Phaser.Color.hueToColor(p, q, h + 1 / 3), out.g = Phaser.Color.hueToColor(p, q, h), 
                                out.b = Phaser.Color.hueToColor(p, q, h - 1 / 3);
                            }
                            return out.r = Math.floor(255 * out.r | 0), out.g = Math.floor(255 * out.g | 0), 
                            out.b = Math.floor(255 * out.b | 0), Phaser.Color.updateColor(out), out;
                        },
                        RGBtoHSV: function(r, g, b, out) {
                            out || (out = Phaser.Color.createColor(r, g, b, 255)), r /= 255, g /= 255, b /= 255;
                            var min = Math.min(r, g, b), max = Math.max(r, g, b), d = max - min;
                            return out.h = 0, out.s = 0 === max ? 0 : d / max, out.v = max, max !== min && (max === r ? out.h = (g - b) / d + (b > g ? 6 : 0) : max === g ? out.h = (b - r) / d + 2 : max === b && (out.h = (r - g) / d + 4), 
                            out.h /= 6), out;
                        },
                        HSVtoRGB: function(h, s, v, out) {
                            "undefined" == typeof out && (out = Phaser.Color.createColor(0, 0, 0, 1, h, s, 0, v));
                            var r, g, b, i = Math.floor(6 * h), f = 6 * h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s);
                            switch (i % 6) {
                              case 0:
                                r = v, g = t, b = p;
                                break;

                              case 1:
                                r = q, g = v, b = p;
                                break;

                              case 2:
                                r = p, g = v, b = t;
                                break;

                              case 3:
                                r = p, g = q, b = v;
                                break;

                              case 4:
                                r = t, g = p, b = v;
                                break;

                              case 5:
                                r = v, g = p, b = q;
                            }
                            return out.r = Math.floor(255 * r), out.g = Math.floor(255 * g), out.b = Math.floor(255 * b), 
                            Phaser.Color.updateColor(out), out;
                        },
                        hueToColor: function(p, q, t) {
                            return 0 > t && (t += 1), t > 1 && (t -= 1), 1 / 6 > t ? p + 6 * (q - p) * t : .5 > t ? q : 2 / 3 > t ? p + (q - p) * (2 / 3 - t) * 6 : p;
                        },
                        createColor: function(r, g, b, a, h, s, l, v) {
                            var out = {
                                r: r || 0,
                                g: g || 0,
                                b: b || 0,
                                a: a || 1,
                                h: h || 0,
                                s: s || 0,
                                l: l || 0,
                                v: v || 0,
                                color: 0,
                                color32: 0,
                                rgba: ""
                            };
                            return out.color = Phaser.Color.getColor(out.r, out.g, out.b), out.color32 = Phaser.Color.getColor32(out.a, out.r, out.g, out.b), 
                            Phaser.Color.updateColor(out);
                        },
                        updateColor: function(out) {
                            return out.rgba = "rgba(" + out.r.toString() + "," + out.g.toString() + "," + out.b.toString() + "," + out.a.toString() + ")", 
                            out;
                        },
                        getColor32: function(a, r, g, b) {
                            return a << 24 | r << 16 | g << 8 | b;
                        },
                        getColor: function(r, g, b) {
                            return r << 16 | g << 8 | b;
                        },
                        RGBtoString: function(r, g, b, a, prefix) {
                            return "undefined" == typeof a && (a = 255), "undefined" == typeof prefix && (prefix = "#"), 
                            "#" === prefix ? "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1) : "0x" + Phaser.Color.componentToHex(a) + Phaser.Color.componentToHex(r) + Phaser.Color.componentToHex(g) + Phaser.Color.componentToHex(b);
                        },
                        hexToRGB: function(hex) {
                            var rgb = Phaser.Color.hexToColor(hex);
                            return rgb ? Phaser.Color.getColor32(rgb.a, rgb.r, rgb.g, rgb.b) : void 0;
                        },
                        hexToColor: function(hex, out) {
                            hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r, g, b) {
                                return r + r + g + g + b + b;
                            });
                            var result = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                            if (result) {
                                var r = parseInt(result[1], 16), g = parseInt(result[2], 16), b = parseInt(result[3], 16);
                                out ? (out.r = r, out.g = g, out.b = b) : out = Phaser.Color.createColor(r, g, b);
                            }
                            return out;
                        },
                        webToColor: function(web, out) {
                            out || (out = Phaser.Color.createColor());
                            var result = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(web);
                            return result && (out.r = parseInt(result[1], 10), out.g = parseInt(result[2], 10), 
                            out.b = parseInt(result[3], 10), out.a = void 0 !== result[4] ? parseFloat(result[4]) : 1), 
                            out;
                        },
                        valueToColor: function(value, out) {
                            if (out || (out = Phaser.Color.createColor()), "string" == typeof value) return 0 === value.indexOf("rgb") ? Phaser.Color.webToColor(value, out) : (out.a = 1, 
                            Phaser.Color.hexToColor(value, out));
                            if ("number" == typeof value) {
                                var tempColor = Phaser.Color.getRGB(value);
                                return out.r = tempColor.r, out.g = tempColor.g, out.b = tempColor.b, out.a = tempColor.a / 255, 
                                out;
                            }
                            return out;
                        },
                        componentToHex: function(color) {
                            var hex = color.toString(16);
                            return 1 == hex.length ? "0" + hex : hex;
                        },
                        HSVColorWheel: function(s, v) {
                            "undefined" == typeof s && (s = 1), "undefined" == typeof v && (v = 1);
                            for (var colors = [], c = 0; 359 >= c; c++) colors.push(Phaser.Color.HSVtoRGB(c / 359, s, v));
                            return colors;
                        },
                        HSLColorWheel: function(s, l) {
                            "undefined" == typeof s && (s = .5), "undefined" == typeof l && (l = .5);
                            for (var colors = [], c = 0; 359 >= c; c++) colors.push(Phaser.Color.HSLtoRGB(c / 359, s, l));
                            return colors;
                        },
                        interpolateColor: function(color1, color2, steps, currentStep, alpha) {
                            "undefined" == typeof alpha && (alpha = 255);
                            var src1 = Phaser.Color.getRGB(color1), src2 = Phaser.Color.getRGB(color2), r = (src2.red - src1.red) * currentStep / steps + src1.red, g = (src2.green - src1.green) * currentStep / steps + src1.green, b = (src2.blue - src1.blue) * currentStep / steps + src1.blue;
                            return Phaser.Color.getColor32(alpha, r, g, b);
                        },
                        interpolateColorWithRGB: function(color, r, g, b, steps, currentStep) {
                            var src = Phaser.Color.getRGB(color), or = (r - src.red) * currentStep / steps + src.red, og = (g - src.green) * currentStep / steps + src.green, ob = (b - src.blue) * currentStep / steps + src.blue;
                            return Phaser.Color.getColor(or, og, ob);
                        },
                        interpolateRGB: function(r1, g1, b1, r2, g2, b2, steps, currentStep) {
                            var r = (r2 - r1) * currentStep / steps + r1, g = (g2 - g1) * currentStep / steps + g1, b = (b2 - b1) * currentStep / steps + b1;
                            return Phaser.Color.getColor(r, g, b);
                        },
                        getRandomColor: function(min, max, alpha) {
                            if ("undefined" == typeof min && (min = 0), "undefined" == typeof max && (max = 255), 
                            "undefined" == typeof alpha && (alpha = 255), max > 255 || min > max) return Phaser.Color.getColor(255, 255, 255);
                            var red = min + Math.round(Math.random() * (max - min)), green = min + Math.round(Math.random() * (max - min)), blue = min + Math.round(Math.random() * (max - min));
                            return Phaser.Color.getColor32(alpha, red, green, blue);
                        },
                        getRGB: function(color) {
                            return color > 16777215 ? {
                                alpha: color >>> 24,
                                red: color >> 16 & 255,
                                green: color >> 8 & 255,
                                blue: 255 & color,
                                a: color >>> 24,
                                r: color >> 16 & 255,
                                g: color >> 8 & 255,
                                b: 255 & color
                            } : {
                                alpha: 255,
                                red: color >> 16 & 255,
                                green: color >> 8 & 255,
                                blue: 255 & color,
                                a: 255,
                                r: color >> 16 & 255,
                                g: color >> 8 & 255,
                                b: 255 & color
                            };
                        },
                        getWebRGB: function(color) {
                            if ("object" == typeof color) return "rgba(" + color.r.toString() + "," + color.g.toString() + "," + color.b.toString() + "," + (color.a / 255).toString() + ")";
                            var rgb = Phaser.Color.getRGB(color);
                            return "rgba(" + rgb.r.toString() + "," + rgb.g.toString() + "," + rgb.b.toString() + "," + (rgb.a / 255).toString() + ")";
                        },
                        getAlpha: function(color) {
                            return color >>> 24;
                        },
                        getAlphaFloat: function(color) {
                            return (color >>> 24) / 255;
                        },
                        getRed: function(color) {
                            return color >> 16 & 255;
                        },
                        getGreen: function(color) {
                            return color >> 8 & 255;
                        },
                        getBlue: function(color) {
                            return 255 & color;
                        }
                    }, Phaser.Physics = function(game, config) {
                        config = config || {}, this.game = game, this.config = config, this.arcade = null, 
                        this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.parseConfig();
                    }, Phaser.Physics.ARCADE = 0, Phaser.Physics.P2JS = 1, Phaser.Physics.NINJA = 2, 
                    Phaser.Physics.BOX2D = 3, Phaser.Physics.CHIPMUNK = 4, Phaser.Physics.prototype = {
                        parseConfig: function() {
                            this.config.hasOwnProperty("arcade") && this.config.arcade !== !0 || !Phaser.Physics.hasOwnProperty("Arcade") || (this.arcade = new Phaser.Physics.Arcade(this.game), 
                            this.game.time.deltaCap = .2), this.config.hasOwnProperty("ninja") && this.config.ninja === !0 && Phaser.Physics.hasOwnProperty("Ninja") && (this.ninja = new Phaser.Physics.Ninja(this.game)), 
                            this.config.hasOwnProperty("p2") && this.config.p2 === !0 && Phaser.Physics.hasOwnProperty("P2") && (this.p2 = new Phaser.Physics.P2(this.game, this.config)), 
                            this.config.hasOwnProperty("box2d") && this.config.box2d === !0 && Phaser.Physics.hasOwnProperty("BOX2D") && (this.box2d = new Phaser.Physics.BOX2D(this.game, this.config));
                        },
                        startSystem: function(system) {
                            system === Phaser.Physics.ARCADE ? this.arcade = new Phaser.Physics.Arcade(this.game) : system === Phaser.Physics.P2JS ? null === this.p2 ? this.p2 = new Phaser.Physics.P2(this.game, this.config) : this.p2.reset() : system === Phaser.Physics.NINJA ? this.ninja = new Phaser.Physics.Ninja(this.game) : system === Phaser.Physics.BOX2D && (null === this.box2d ? this.box2d = new Phaser.Physics.Box2D(this.game, this.config) : this.box2d.reset());
                        },
                        enable: function(object, system, debug) {
                            "undefined" == typeof system && (system = Phaser.Physics.ARCADE), "undefined" == typeof debug && (debug = !1), 
                            system === Phaser.Physics.ARCADE ? this.arcade.enable(object) : system === Phaser.Physics.P2JS && this.p2 ? this.p2.enable(object, debug) : system === Phaser.Physics.NINJA && this.ninja ? this.ninja.enableAABB(object) : system === Phaser.Physics.BOX2D && this.box2d && this.box2d.enable(object);
                        },
                        preUpdate: function() {
                            this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate();
                        },
                        update: function() {
                            this.p2 && this.p2.update(), this.box2d && this.box2d.update();
                        },
                        setBoundsToWorld: function() {
                            this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), 
                            this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld();
                        },
                        clear: function() {
                            this.p2 && this.p2.clear(), this.box2d && this.box2d.clear();
                        },
                        destroy: function() {
                            this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.arcade = null, 
                            this.ninja = null, this.p2 = null, this.box2d = null;
                        }
                    }, Phaser.Physics.prototype.constructor = Phaser.Physics, Phaser.Physics.Arcade = function(game) {
                        this.game = game, this.gravity = new Phaser.Point(), this.bounds = new Phaser.Rectangle(0, 0, game.world.width, game.world.height), 
                        this.checkCollision = {
                            up: !0,
                            down: !0,
                            left: !0,
                            right: !0
                        }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.TILE_BIAS = 16, 
                        this.forceX = !1, this.skipQuadTree = !0, this.quadTree = new Phaser.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), 
                        this._overlap = 0, this._maxOverlap = 0, this._velocity1 = 0, this._velocity2 = 0, 
                        this._newVelocity1 = 0, this._newVelocity2 = 0, this._average = 0, this._mapData = [], 
                        this._result = !1, this._total = 0, this._angle = 0, this._dx = 0, this._dy = 0, 
                        this.setBoundsToWorld();
                    }, Phaser.Physics.Arcade.prototype.constructor = Phaser.Physics.Arcade, Phaser.Physics.Arcade.prototype = {
                        setBounds: function(x, y, width, height) {
                            this.bounds.setTo(x, y, width, height);
                        },
                        setBoundsToWorld: function() {
                            this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height);
                        },
                        enable: function(object, children) {
                            "undefined" == typeof children && (children = !0);
                            var i = 1;
                            if (Array.isArray(object)) for (i = object.length; i--; ) object[i] instanceof Phaser.Group ? this.enable(object[i].children, children) : (this.enableBody(object[i]), 
                            children && object[i].hasOwnProperty("children") && object[i].children.length > 0 && this.enable(object[i], !0)); else object instanceof Phaser.Group ? this.enable(object.children, children) : (this.enableBody(object), 
                            children && object.hasOwnProperty("children") && object.children.length > 0 && this.enable(object.children, !0));
                        },
                        enableBody: function(object) {
                            object.hasOwnProperty("body") && null === object.body && (object.body = new Phaser.Physics.Arcade.Body(object));
                        },
                        updateMotion: function(body) {
                            this._velocityDelta = this.computeVelocity(0, body, body.angularVelocity, body.angularAcceleration, body.angularDrag, body.maxAngular) - body.angularVelocity, 
                            body.angularVelocity += this._velocityDelta, body.rotation += body.angularVelocity * this.game.time.physicsElapsed, 
                            body.velocity.x = this.computeVelocity(1, body, body.velocity.x, body.acceleration.x, body.drag.x, body.maxVelocity.x), 
                            body.velocity.y = this.computeVelocity(2, body, body.velocity.y, body.acceleration.y, body.drag.y, body.maxVelocity.y);
                        },
                        computeVelocity: function(axis, body, velocity, acceleration, drag, max) {
                            return max = max || 1e4, 1 == axis && body.allowGravity ? velocity += (this.gravity.x + body.gravity.x) * this.game.time.physicsElapsed : 2 == axis && body.allowGravity && (velocity += (this.gravity.y + body.gravity.y) * this.game.time.physicsElapsed), 
                            acceleration ? velocity += acceleration * this.game.time.physicsElapsed : drag && (this._drag = drag * this.game.time.physicsElapsed, 
                            velocity - this._drag > 0 ? velocity -= this._drag : velocity + this._drag < 0 ? velocity += this._drag : velocity = 0), 
                            velocity > max ? velocity = max : -max > velocity && (velocity = -max), velocity;
                        },
                        overlap: function(object1, object2, overlapCallback, processCallback, callbackContext) {
                            if (overlapCallback = overlapCallback || null, processCallback = processCallback || null, 
                            callbackContext = callbackContext || overlapCallback, this._result = !1, this._total = 0, 
                            !Array.isArray(object1) && Array.isArray(object2)) for (var i = 0, len = object2.length; len > i; i++) this.collideHandler(object1, object2[i], overlapCallback, processCallback, callbackContext, !0); else if (Array.isArray(object1) && !Array.isArray(object2)) for (var i = 0, len = object1.length; len > i; i++) this.collideHandler(object1[i], object2, overlapCallback, processCallback, callbackContext, !0); else if (Array.isArray(object1) && Array.isArray(object2)) for (var i = 0, len = object1.length; len > i; i++) for (var j = 0, len2 = object2.length; len2 > j; j++) this.collideHandler(object1[i], object2[j], overlapCallback, processCallback, callbackContext, !0); else this.collideHandler(object1, object2, overlapCallback, processCallback, callbackContext, !0);
                            return this._total > 0;
                        },
                        collide: function(object1, object2, collideCallback, processCallback, callbackContext) {
                            if (collideCallback = collideCallback || null, processCallback = processCallback || null, 
                            callbackContext = callbackContext || collideCallback, this._result = !1, this._total = 0, 
                            !Array.isArray(object1) && Array.isArray(object2)) for (var i = 0, len = object2.length; len > i; i++) this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, !1); else if (Array.isArray(object1) && !Array.isArray(object2)) for (var i = 0, len = object1.length; len > i; i++) this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, !1); else if (Array.isArray(object1) && Array.isArray(object2)) for (var i = 0, len1 = object1.length; len1 > i; i++) for (var j = 0, len2 = object2.length; len2 > j; j++) this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, !1); else this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, !1);
                            return this._total > 0;
                        },
                        collideHandler: function(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
                            return "undefined" != typeof object2 || object1.type !== Phaser.GROUP && object1.type !== Phaser.EMITTER ? void (object1 && object2 && object1.exists && object2.exists && (object1.type == Phaser.SPRITE || object1.type == Phaser.TILESPRITE ? object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE ? this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) : object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER ? this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) : object2.type == Phaser.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext) : object1.type == Phaser.GROUP ? object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE ? this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly) : object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER ? this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) : object2.type == Phaser.TILEMAPLAYER && this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext) : object1.type == Phaser.TILEMAPLAYER ? object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE ? this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext) : (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER) && this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext) : object1.type == Phaser.EMITTER && (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE ? this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly) : object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER ? this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) : object2.type == Phaser.TILEMAPLAYER && this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext)))) : void this.collideGroupVsSelf(object1, collideCallback, processCallback, callbackContext, overlapOnly);
                        },
                        collideSpriteVsSprite: function(sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {
                            return sprite1.body && sprite2.body ? (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly) && (collideCallback && collideCallback.call(callbackContext, sprite1, sprite2), 
                            this._total++), !0) : !1;
                        },
                        collideSpriteVsGroup: function(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {
                            if (0 !== group.length && sprite.body) if (sprite.body.skipQuadTree || this.skipQuadTree) for (var i = 0, len = group.children.length; len > i; i++) group.children[i] && group.children[i].exists && this.collideSpriteVsSprite(sprite, group.children[i], collideCallback, processCallback, callbackContext, overlapOnly); else {
                                this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), 
                                this.quadTree.populate(group), this._potentials = this.quadTree.retrieve(sprite);
                                for (var i = 0, len = this._potentials.length; len > i; i++) this.separate(sprite.body, this._potentials[i], processCallback, callbackContext, overlapOnly) && (collideCallback && collideCallback.call(callbackContext, sprite, this._potentials[i].sprite), 
                                this._total++);
                            }
                        },
                        collideGroupVsSelf: function(group, collideCallback, processCallback, callbackContext, overlapOnly) {
                            if (0 !== group.length) for (var len = group.children.length, i = 0; len - 1 > i; i++) for (var j = i + 1; len > j; j++) group.children[i] && group.children[j] && group.children[i].exists && group.children[j].exists && this.collideSpriteVsSprite(group.children[i], group.children[j], collideCallback, processCallback, callbackContext, overlapOnly);
                        },
                        collideGroupVsGroup: function(group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {
                            if (0 !== group1.length && 0 !== group2.length) for (var i = 0, len = group1.children.length; len > i; i++) group1.children[i].exists && (group1.children[i].type === Phaser.GROUP ? this.collideGroupVsGroup(group1.children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly) : this.collideSpriteVsGroup(group1.children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly));
                        },
                        collideSpriteVsTilemapLayer: function(sprite, tilemapLayer, collideCallback, processCallback, callbackContext) {
                            if (sprite.body && (this._mapData = tilemapLayer.getTiles(sprite.body.position.x - sprite.body.tilePadding.x, sprite.body.position.y - sprite.body.tilePadding.y, sprite.body.width + sprite.body.tilePadding.x, sprite.body.height + sprite.body.tilePadding.y, !1, !1), 
                            0 !== this._mapData.length)) for (var i = 0; i < this._mapData.length; i++) processCallback ? processCallback.call(callbackContext, sprite, this._mapData[i]) && this.separateTile(i, sprite.body, this._mapData[i]) && (this._total++, 
                            collideCallback && collideCallback.call(callbackContext, sprite, this._mapData[i])) : this.separateTile(i, sprite.body, this._mapData[i]) && (this._total++, 
                            collideCallback && collideCallback.call(callbackContext, sprite, this._mapData[i]));
                        },
                        collideGroupVsTilemapLayer: function(group, tilemapLayer, collideCallback, processCallback, callbackContext) {
                            if (0 !== group.length) for (var i = 0, len = group.children.length; len > i; i++) group.children[i].exists && this.collideSpriteVsTilemapLayer(group.children[i], tilemapLayer, collideCallback, processCallback, callbackContext);
                        },
                        separate: function(body1, body2, processCallback, callbackContext, overlapOnly) {
                            return body1.enable && body2.enable && this.intersects(body1, body2) ? processCallback && processCallback.call(callbackContext, body1.sprite, body2.sprite) === !1 ? !1 : (this._result = this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x) ? this.separateX(body1, body2, overlapOnly) || this.separateY(body1, body2, overlapOnly) : this.separateY(body1, body2, overlapOnly) || this.separateX(body1, body2, overlapOnly), 
                            overlapOnly ? !0 : this._result) : !1;
                        },
                        intersects: function(body1, body2) {
                            return body1.right <= body2.position.x ? !1 : body1.bottom <= body2.position.y ? !1 : body1.position.x >= body2.right ? !1 : body1.position.y >= body2.bottom ? !1 : !0;
                        },
                        separateX: function(body1, body2, overlapOnly) {
                            return body1.immovable && body2.immovable ? !1 : (this._overlap = 0, this.intersects(body1, body2) && (this._maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + this.OVERLAP_BIAS, 
                            0 === body1.deltaX() && 0 === body2.deltaX() ? (body1.embedded = !0, body2.embedded = !0) : body1.deltaX() > body2.deltaX() ? (this._overlap = body1.right - body2.x, 
                            this._overlap > this._maxOverlap || body1.checkCollision.right === !1 || body2.checkCollision.left === !1 ? this._overlap = 0 : (body1.touching.none = !1, 
                            body1.touching.right = !0, body2.touching.none = !1, body2.touching.left = !0)) : body1.deltaX() < body2.deltaX() && (this._overlap = body1.x - body2.width - body2.x, 
                            -this._overlap > this._maxOverlap || body1.checkCollision.left === !1 || body2.checkCollision.right === !1 ? this._overlap = 0 : (body1.touching.none = !1, 
                            body1.touching.left = !0, body2.touching.none = !1, body2.touching.right = !0)), 
                            body1.overlapX = this._overlap, body2.overlapX = this._overlap, 0 !== this._overlap) ? overlapOnly || body1.customSeparateX || body2.customSeparateX ? !0 : (this._velocity1 = body1.velocity.x, 
                            this._velocity2 = body2.velocity.x, body1.immovable || body2.immovable ? body1.immovable ? body2.immovable || (body2.x += this._overlap, 
                            body2.velocity.x = this._velocity1 - this._velocity2 * body2.bounce.x) : (body1.x = body1.x - this._overlap, 
                            body1.velocity.x = this._velocity2 - this._velocity1 * body1.bounce.x) : (this._overlap *= .5, 
                            body1.x = body1.x - this._overlap, body2.x += this._overlap, this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * body2.mass / body1.mass) * (this._velocity2 > 0 ? 1 : -1), 
                            this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * body1.mass / body2.mass) * (this._velocity1 > 0 ? 1 : -1), 
                            this._average = .5 * (this._newVelocity1 + this._newVelocity2), this._newVelocity1 -= this._average, 
                            this._newVelocity2 -= this._average, body1.velocity.x = this._average + this._newVelocity1 * body1.bounce.x, 
                            body2.velocity.x = this._average + this._newVelocity2 * body2.bounce.x), !0) : !1);
                        },
                        separateY: function(body1, body2, overlapOnly) {
                            return body1.immovable && body2.immovable ? !1 : (this._overlap = 0, this.intersects(body1, body2) && (this._maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + this.OVERLAP_BIAS, 
                            0 === body1.deltaY() && 0 === body2.deltaY() ? (body1.embedded = !0, body2.embedded = !0) : body1.deltaY() > body2.deltaY() ? (this._overlap = body1.bottom - body2.y, 
                            this._overlap > this._maxOverlap || body1.checkCollision.down === !1 || body2.checkCollision.up === !1 ? this._overlap = 0 : (body1.touching.none = !1, 
                            body1.touching.down = !0, body2.touching.none = !1, body2.touching.up = !0)) : body1.deltaY() < body2.deltaY() && (this._overlap = body1.y - body2.bottom, 
                            -this._overlap > this._maxOverlap || body1.checkCollision.up === !1 || body2.checkCollision.down === !1 ? this._overlap = 0 : (body1.touching.none = !1, 
                            body1.touching.up = !0, body2.touching.none = !1, body2.touching.down = !0)), body1.overlapY = this._overlap, 
                            body2.overlapY = this._overlap, 0 !== this._overlap) ? overlapOnly || body1.customSeparateY || body2.customSeparateY ? !0 : (this._velocity1 = body1.velocity.y, 
                            this._velocity2 = body2.velocity.y, body1.immovable || body2.immovable ? body1.immovable ? body2.immovable || (body2.y += this._overlap, 
                            body2.velocity.y = this._velocity1 - this._velocity2 * body2.bounce.y, body1.moves && (body2.x += body1.x - body1.prev.x)) : (body1.y = body1.y - this._overlap, 
                            body1.velocity.y = this._velocity2 - this._velocity1 * body1.bounce.y, body2.moves && (body1.x += body2.x - body2.prev.x)) : (this._overlap *= .5, 
                            body1.y = body1.y - this._overlap, body2.y += this._overlap, this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * body2.mass / body1.mass) * (this._velocity2 > 0 ? 1 : -1), 
                            this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * body1.mass / body2.mass) * (this._velocity1 > 0 ? 1 : -1), 
                            this._average = .5 * (this._newVelocity1 + this._newVelocity2), this._newVelocity1 -= this._average, 
                            this._newVelocity2 -= this._average, body1.velocity.y = this._average + this._newVelocity1 * body1.bounce.y, 
                            body2.velocity.y = this._average + this._newVelocity2 * body2.bounce.y), !0) : !1);
                        },
                        separateTile: function(i, body, tile) {
                            if (!body.enable || !tile.intersects(body.position.x, body.position.y, body.right, body.bottom)) return !1;
                            if (tile.collisionCallback && !tile.collisionCallback.call(tile.collisionCallbackContext, body.sprite, tile)) return !1;
                            if (tile.layer.callbacks[tile.index] && !tile.layer.callbacks[tile.index].callback.call(tile.layer.callbacks[tile.index].callbackContext, body.sprite, tile)) return !1;
                            if (!(tile.faceLeft || tile.faceRight || tile.faceTop || tile.faceBottom)) return !1;
                            var ox = 0, oy = 0, minX = 0, minY = 1;
                            if (body.deltaAbsX() > body.deltaAbsY() ? minX = -1 : body.deltaAbsX() < body.deltaAbsY() && (minY = -1), 
                            0 !== body.deltaX() && 0 !== body.deltaY() && (tile.faceLeft || tile.faceRight) && (tile.faceTop || tile.faceBottom) && (minX = Math.min(Math.abs(body.position.x - tile.right), Math.abs(body.right - tile.left)), 
                            minY = Math.min(Math.abs(body.position.y - tile.bottom), Math.abs(body.bottom - tile.top))), 
                            minY > minX) {
                                if ((tile.faceLeft || tile.faceRight) && (ox = this.tileCheckX(body, tile), 0 !== ox && !tile.intersects(body.position.x, body.position.y, body.right, body.bottom))) return !0;
                                (tile.faceTop || tile.faceBottom) && (oy = this.tileCheckY(body, tile));
                            } else {
                                if ((tile.faceTop || tile.faceBottom) && (oy = this.tileCheckY(body, tile), 0 !== oy && !tile.intersects(body.position.x, body.position.y, body.right, body.bottom))) return !0;
                                (tile.faceLeft || tile.faceRight) && (ox = this.tileCheckX(body, tile));
                            }
                            return 0 !== ox || 0 !== oy;
                        },
                        tileCheckX: function(body, tile) {
                            var ox = 0;
                            return body.deltaX() < 0 && !body.blocked.left && tile.collideRight && body.checkCollision.left ? tile.faceRight && body.x < tile.right && (ox = body.x - tile.right, 
                            ox < -this.TILE_BIAS && (ox = 0)) : body.deltaX() > 0 && !body.blocked.right && tile.collideLeft && body.checkCollision.right && tile.faceLeft && body.right > tile.left && (ox = body.right - tile.left, 
                            ox > this.TILE_BIAS && (ox = 0)), 0 !== ox && this.processTileSeparationX(body, ox), 
                            ox;
                        },
                        tileCheckY: function(body, tile) {
                            var oy = 0;
                            return body.deltaY() < 0 && !body.blocked.up && tile.collideDown && body.checkCollision.up ? tile.faceBottom && body.y < tile.bottom && (oy = body.y - tile.bottom, 
                            oy < -this.TILE_BIAS && (oy = 0)) : body.deltaY() > 0 && !body.blocked.down && tile.collideUp && body.checkCollision.down && tile.faceTop && body.bottom > tile.top && (oy = body.bottom - tile.top, 
                            oy > this.TILE_BIAS && (oy = 0)), 0 !== oy && this.processTileSeparationY(body, oy), 
                            oy;
                        },
                        processTileSeparationX: function(body, x) {
                            0 > x ? body.blocked.left = !0 : x > 0 && (body.blocked.right = !0), body.position.x -= x, 
                            body.velocity.x = 0 === body.bounce.x ? 0 : -body.velocity.x * body.bounce.x;
                        },
                        processTileSeparationY: function(body, y) {
                            0 > y ? body.blocked.up = !0 : y > 0 && (body.blocked.down = !0), body.position.y -= y, 
                            body.velocity.y = 0 === body.bounce.y ? 0 : -body.velocity.y * body.bounce.y;
                        },
                        getObjectsUnderPointer: function(pointer, group, callback, callbackContext) {
                            return 0 !== group.length && pointer.exists ? this.getObjectsAtLocation(pointer.x, pointer.y, group, callback, callbackContext, pointer) : void 0;
                        },
                        getObjectsAtLocation: function(x, y, group, callback, callbackContext, callbackArg) {
                            this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), 
                            this.quadTree.populate(group);
                            var rect = new Phaser.Rectangle(x, y, 1, 1), output = [];
                            this._potentials = this.quadTree.retrieve(rect);
                            for (var i = 0, len = this._potentials.length; len > i; i++) this._potentials[i].hitTest(x, y) && (callback && callback.call(callbackContext, callbackArg, this._potentials[i].sprite), 
                            output.push(this._potentials[i].sprite));
                            return output;
                        },
                        moveToObject: function(displayObject, destination, speed, maxTime) {
                            return "undefined" == typeof speed && (speed = 60), "undefined" == typeof maxTime && (maxTime = 0), 
                            this._angle = Math.atan2(destination.y - displayObject.y, destination.x - displayObject.x), 
                            maxTime > 0 && (speed = this.distanceBetween(displayObject, destination) / (maxTime / 1e3)), 
                            displayObject.body.velocity.x = Math.cos(this._angle) * speed, displayObject.body.velocity.y = Math.sin(this._angle) * speed, 
                            this._angle;
                        },
                        moveToPointer: function(displayObject, speed, pointer, maxTime) {
                            return "undefined" == typeof speed && (speed = 60), pointer = pointer || this.game.input.activePointer, 
                            "undefined" == typeof maxTime && (maxTime = 0), this._angle = this.angleToPointer(displayObject, pointer), 
                            maxTime > 0 && (speed = this.distanceToPointer(displayObject, pointer) / (maxTime / 1e3)), 
                            displayObject.body.velocity.x = Math.cos(this._angle) * speed, displayObject.body.velocity.y = Math.sin(this._angle) * speed, 
                            this._angle;
                        },
                        moveToXY: function(displayObject, x, y, speed, maxTime) {
                            return "undefined" == typeof speed && (speed = 60), "undefined" == typeof maxTime && (maxTime = 0), 
                            this._angle = Math.atan2(y - displayObject.y, x - displayObject.x), maxTime > 0 && (speed = this.distanceToXY(displayObject, x, y) / (maxTime / 1e3)), 
                            displayObject.body.velocity.x = Math.cos(this._angle) * speed, displayObject.body.velocity.y = Math.sin(this._angle) * speed, 
                            this._angle;
                        },
                        velocityFromAngle: function(angle, speed, point) {
                            return "undefined" == typeof speed && (speed = 60), point = point || new Phaser.Point(), 
                            point.setTo(Math.cos(this.game.math.degToRad(angle)) * speed, Math.sin(this.game.math.degToRad(angle)) * speed);
                        },
                        velocityFromRotation: function(rotation, speed, point) {
                            return "undefined" == typeof speed && (speed = 60), point = point || new Phaser.Point(), 
                            point.setTo(Math.cos(rotation) * speed, Math.sin(rotation) * speed);
                        },
                        accelerationFromRotation: function(rotation, speed, point) {
                            return "undefined" == typeof speed && (speed = 60), point = point || new Phaser.Point(), 
                            point.setTo(Math.cos(rotation) * speed, Math.sin(rotation) * speed);
                        },
                        accelerateToObject: function(displayObject, destination, speed, xSpeedMax, ySpeedMax) {
                            return "undefined" == typeof speed && (speed = 60), "undefined" == typeof xSpeedMax && (xSpeedMax = 1e3), 
                            "undefined" == typeof ySpeedMax && (ySpeedMax = 1e3), this._angle = this.angleBetween(displayObject, destination), 
                            displayObject.body.acceleration.setTo(Math.cos(this._angle) * speed, Math.sin(this._angle) * speed), 
                            displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax), this._angle;
                        },
                        accelerateToPointer: function(displayObject, pointer, speed, xSpeedMax, ySpeedMax) {
                            return "undefined" == typeof speed && (speed = 60), "undefined" == typeof pointer && (pointer = this.game.input.activePointer), 
                            "undefined" == typeof xSpeedMax && (xSpeedMax = 1e3), "undefined" == typeof ySpeedMax && (ySpeedMax = 1e3), 
                            this._angle = this.angleToPointer(displayObject, pointer), displayObject.body.acceleration.setTo(Math.cos(this._angle) * speed, Math.sin(this._angle) * speed), 
                            displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax), this._angle;
                        },
                        accelerateToXY: function(displayObject, x, y, speed, xSpeedMax, ySpeedMax) {
                            return "undefined" == typeof speed && (speed = 60), "undefined" == typeof xSpeedMax && (xSpeedMax = 1e3), 
                            "undefined" == typeof ySpeedMax && (ySpeedMax = 1e3), this._angle = this.angleToXY(displayObject, x, y), 
                            displayObject.body.acceleration.setTo(Math.cos(this._angle) * speed, Math.sin(this._angle) * speed), 
                            displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax), this._angle;
                        },
                        distanceBetween: function(source, target) {
                            return this._dx = source.x - target.x, this._dy = source.y - target.y, Math.sqrt(this._dx * this._dx + this._dy * this._dy);
                        },
                        distanceToXY: function(displayObject, x, y) {
                            return this._dx = displayObject.x - x, this._dy = displayObject.y - y, Math.sqrt(this._dx * this._dx + this._dy * this._dy);
                        },
                        distanceToPointer: function(displayObject, pointer) {
                            return pointer = pointer || this.game.input.activePointer, this._dx = displayObject.x - pointer.x, 
                            this._dy = displayObject.y - pointer.y, Math.sqrt(this._dx * this._dx + this._dy * this._dy);
                        },
                        angleBetween: function(source, target) {
                            return this._dx = target.x - source.x, this._dy = target.y - source.y, Math.atan2(this._dy, this._dx);
                        },
                        angleToXY: function(displayObject, x, y) {
                            return this._dx = x - displayObject.x, this._dy = y - displayObject.y, Math.atan2(this._dy, this._dx);
                        },
                        angleToPointer: function(displayObject, pointer) {
                            return pointer = pointer || this.game.input.activePointer, this._dx = pointer.worldX - displayObject.x, 
                            this._dy = pointer.worldY - displayObject.y, Math.atan2(this._dy, this._dx);
                        }
                    }, Phaser.Physics.Arcade.Body = function(sprite) {
                        this.sprite = sprite, this.game = sprite.game, this.type = Phaser.Physics.ARCADE, 
                        this.enable = !0, this.offset = new Phaser.Point(), this.position = new Phaser.Point(sprite.x, sprite.y), 
                        this.prev = new Phaser.Point(this.position.x, this.position.y), this.allowRotation = !0, 
                        this.rotation = sprite.rotation, this.preRotation = sprite.rotation, this.sourceWidth = sprite.texture.frame.width, 
                        this.sourceHeight = sprite.texture.frame.height, this.width = sprite.width, this.height = sprite.height, 
                        this.halfWidth = Math.abs(sprite.width / 2), this.halfHeight = Math.abs(sprite.height / 2), 
                        this.center = new Phaser.Point(sprite.x + this.halfWidth, sprite.y + this.halfHeight), 
                        this.velocity = new Phaser.Point(), this.newVelocity = new Phaser.Point(0, 0), this.deltaMax = new Phaser.Point(0, 0), 
                        this.acceleration = new Phaser.Point(), this.drag = new Phaser.Point(), this.allowGravity = !0, 
                        this.gravity = new Phaser.Point(0, 0), this.bounce = new Phaser.Point(), this.maxVelocity = new Phaser.Point(1e4, 1e4), 
                        this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, 
                        this.mass = 1, this.angle = 0, this.speed = 0, this.facing = Phaser.NONE, this.immovable = !1, 
                        this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, 
                        this.overlapY = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
                            none: !1,
                            any: !0,
                            up: !0,
                            down: !0,
                            left: !0,
                            right: !0
                        }, this.touching = {
                            none: !0,
                            up: !1,
                            down: !1,
                            left: !1,
                            right: !1
                        }, this.wasTouching = {
                            none: !0,
                            up: !1,
                            down: !1,
                            left: !1,
                            right: !1
                        }, this.blocked = {
                            up: !1,
                            down: !1,
                            left: !1,
                            right: !1
                        }, this.tilePadding = new Phaser.Point(), this.phase = 0, this.skipQuadTree = !1, 
                        this._reset = !0, this._sx = sprite.scale.x, this._sy = sprite.scale.y, this._dx = 0, 
                        this._dy = 0;
                    }, Phaser.Physics.Arcade.Body.prototype = {
                        updateBounds: function() {
                            var asx = Math.abs(this.sprite.scale.x), asy = Math.abs(this.sprite.scale.y);
                            (asx !== this._sx || asy !== this._sy) && (this.width = this.sourceWidth * asx, 
                            this.height = this.sourceHeight * asy, this.halfWidth = Math.floor(this.width / 2), 
                            this.halfHeight = Math.floor(this.height / 2), this._sx = asx, this._sy = asy, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), 
                            this._reset = !0);
                        },
                        preUpdate: function() {
                            this.enable && (this.phase = 1, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, 
                            this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, 
                            this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, 
                            this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.up = !1, 
                            this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.embedded = !1, 
                            this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.width + this.offset.x, 
                            this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.height + this.offset.y, 
                            this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || 1 === this.sprite._cache[4]) && (this.prev.x = this.position.x, 
                            this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), 
                            this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), 
                            this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, (this.position.x !== this.prev.x || this.position.y !== this.prev.y) && (this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), 
                            this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.collideWorldBounds && this.checkWorldBounds()), 
                            this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1);
                        },
                        postUpdate: function() {
                            this.enable && 2 !== this.phase && (this.phase = 2, this.deltaX() < 0 ? this.facing = Phaser.LEFT : this.deltaX() > 0 && (this.facing = Phaser.RIGHT), 
                            this.deltaY() < 0 ? this.facing = Phaser.UP : this.deltaY() > 0 && (this.facing = Phaser.DOWN), 
                            this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 
                            0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), 
                            this.sprite.x += this._dx, this.sprite.y += this._dy), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), 
                            this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, 
                            this.prev.y = this.position.y);
                        },
                        destroy: function() {
                            this.sprite.body = null, this.sprite = null;
                        },
                        checkWorldBounds: function() {
                            this.position.x < this.game.physics.arcade.bounds.x && this.game.physics.arcade.checkCollision.left ? (this.position.x = this.game.physics.arcade.bounds.x, 
                            this.velocity.x *= -this.bounce.x, this.blocked.left = !0) : this.right > this.game.physics.arcade.bounds.right && this.game.physics.arcade.checkCollision.right && (this.position.x = this.game.physics.arcade.bounds.right - this.width, 
                            this.velocity.x *= -this.bounce.x, this.blocked.right = !0), this.position.y < this.game.physics.arcade.bounds.y && this.game.physics.arcade.checkCollision.up ? (this.position.y = this.game.physics.arcade.bounds.y, 
                            this.velocity.y *= -this.bounce.y, this.blocked.up = !0) : this.bottom > this.game.physics.arcade.bounds.bottom && this.game.physics.arcade.checkCollision.down && (this.position.y = this.game.physics.arcade.bounds.bottom - this.height, 
                            this.velocity.y *= -this.bounce.y, this.blocked.down = !0);
                        },
                        setSize: function(width, height, offsetX, offsetY) {
                            "undefined" == typeof offsetX && (offsetX = this.offset.x), "undefined" == typeof offsetY && (offsetY = this.offset.y), 
                            this.sourceWidth = width, this.sourceHeight = height, this.width = this.sourceWidth * this._sx, 
                            this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), 
                            this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(offsetX, offsetY), 
                            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
                        },
                        reset: function(x, y) {
                            this.velocity.set(0), this.acceleration.set(0), this.angularVelocity = 0, this.angularAcceleration = 0, 
                            this.position.x = x - this.sprite.anchor.x * this.width + this.offset.x, this.position.y = y - this.sprite.anchor.y * this.height + this.offset.y, 
                            this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, 
                            this.preRotation = this.rotation, this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, 
                            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
                        },
                        hitTest: function(x, y) {
                            return Phaser.Rectangle.contains(this, x, y);
                        },
                        onFloor: function() {
                            return this.blocked.down;
                        },
                        onWall: function() {
                            return this.blocked.left || this.blocked.right;
                        },
                        deltaAbsX: function() {
                            return this.deltaX() > 0 ? this.deltaX() : -this.deltaX();
                        },
                        deltaAbsY: function() {
                            return this.deltaY() > 0 ? this.deltaY() : -this.deltaY();
                        },
                        deltaX: function() {
                            return this.position.x - this.prev.x;
                        },
                        deltaY: function() {
                            return this.position.y - this.prev.y;
                        },
                        deltaZ: function() {
                            return this.rotation - this.preRotation;
                        }
                    }, Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "bottom", {
                        get: function() {
                            return this.position.y + this.height;
                        }
                    }), Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "right", {
                        get: function() {
                            return this.position.x + this.width;
                        }
                    }), Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "x", {
                        get: function() {
                            return this.position.x;
                        },
                        set: function(value) {
                            this.position.x = value;
                        }
                    }), Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "y", {
                        get: function() {
                            return this.position.y;
                        },
                        set: function(value) {
                            this.position.y = value;
                        }
                    }), Phaser.Physics.Arcade.Body.render = function(context, body, color, filled) {
                        "undefined" == typeof filled && (filled = !0), color = color || "rgba(0,255,0,0.4)", 
                        filled ? (context.fillStyle = color, context.fillRect(body.position.x - body.game.camera.x, body.position.y - body.game.camera.y, body.width, body.height)) : (context.strokeStyle = color, 
                        context.strokeRect(body.position.x - body.game.camera.x, body.position.y - body.game.camera.y, body.width, body.height));
                    }, Phaser.Physics.Arcade.Body.renderBodyInfo = function(debug, body) {
                        debug.line("x: " + body.x.toFixed(2), "y: " + body.y.toFixed(2), "width: " + body.width, "height: " + body.height), 
                        debug.line("velocity x: " + body.velocity.x.toFixed(2), "y: " + body.velocity.y.toFixed(2), "deltaX: " + body._dx.toFixed(2), "deltaY: " + body._dy.toFixed(2)), 
                        debug.line("acceleration x: " + body.acceleration.x.toFixed(2), "y: " + body.acceleration.y.toFixed(2), "speed: " + body.speed.toFixed(2), "angle: " + body.angle.toFixed(2)), 
                        debug.line("gravity x: " + body.gravity.x, "y: " + body.gravity.y, "bounce x: " + body.bounce.x.toFixed(2), "y: " + body.bounce.y.toFixed(2)), 
                        debug.line("touching left: " + body.touching.left, "right: " + body.touching.right, "up: " + body.touching.up, "down: " + body.touching.down), 
                        debug.line("blocked left: " + body.blocked.left, "right: " + body.blocked.right, "up: " + body.blocked.up, "down: " + body.blocked.down);
                    }, Phaser.Physics.Arcade.Body.prototype.constructor = Phaser.Physics.Arcade.Body, 
                    Phaser.Particles = function(game) {
                        this.game = game, this.emitters = {}, this.ID = 0;
                    }, Phaser.Particles.prototype = {
                        add: function(emitter) {
                            return this.emitters[emitter.name] = emitter, emitter;
                        },
                        remove: function(emitter) {
                            delete this.emitters[emitter.name];
                        },
                        update: function() {
                            for (var key in this.emitters) this.emitters[key].exists && this.emitters[key].update();
                        }
                    }, Phaser.Particles.prototype.constructor = Phaser.Particles, Phaser.Particles.Arcade = {}, 
                    Phaser.Particles.Arcade.Emitter = function(game, x, y, maxParticles) {
                        this.maxParticles = maxParticles || 50, Phaser.Group.call(this, game), this.name = "emitter" + this.game.particles.ID++, 
                        this.type = Phaser.EMITTER, this.area = new Phaser.Rectangle(x, y, 1, 1), this.minParticleSpeed = new Phaser.Point(-100, -100), 
                        this.maxParticleSpeed = new Phaser.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, 
                        this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, 
                        this.maxParticleAlpha = 1, this.alphaData = null, this.gravity = 100, this.particleClass = Phaser.Particle, 
                        this.particleDrag = new Phaser.Point(), this.angularDrag = 0, this.frequency = 100, 
                        this.lifespan = 2e3, this.bounce = new Phaser.Point(), this.on = !1, this.particleAnchor = new Phaser.Point(.5, .5), 
                        this.blendMode = Phaser.blendModes.NORMAL, this.emitX = x, this.emitY = y, this.autoScale = !1, 
                        this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, 
                        this._minParticleScale = new Phaser.Point(1, 1), this._maxParticleScale = new Phaser.Point(1, 1), 
                        this._quantity = 0, this._timer = 0, this._counter = 0, this._explode = !0, this._frames = null;
                    }, Phaser.Particles.Arcade.Emitter.prototype = Object.create(Phaser.Group.prototype), 
                    Phaser.Particles.Arcade.Emitter.prototype.constructor = Phaser.Particles.Arcade.Emitter, 
                    Phaser.Particles.Arcade.Emitter.prototype.update = function() {
                        this.on && this.game.time.time >= this._timer && (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 
                        this.emitParticle() && (this._counter++, this._quantity > 0 && this._counter >= this._quantity && (this.on = !1)));
                        for (var i = this.children.length; i--; ) this.children[i].exists && this.children[i].update();
                    }, Phaser.Particles.Arcade.Emitter.prototype.makeParticles = function(keys, frames, quantity, collide, collideWorldBounds) {
                        "undefined" == typeof frames && (frames = 0), "undefined" == typeof quantity && (quantity = this.maxParticles), 
                        "undefined" == typeof collide && (collide = !1), "undefined" == typeof collideWorldBounds && (collideWorldBounds = !1);
                        var particle, i = 0, rndKey = keys, rndFrame = frames;
                        for (this._frames = frames, quantity > this.maxParticles && (this.maxParticles = quantity); quantity > i; ) Array.isArray(keys) && (rndKey = this.game.rnd.pick(keys)), 
                        Array.isArray(frames) && (rndFrame = this.game.rnd.pick(frames)), particle = new this.particleClass(this.game, 0, 0, rndKey, rndFrame), 
                        this.game.physics.arcade.enable(particle, !1), collide ? (particle.body.checkCollision.any = !0, 
                        particle.body.checkCollision.none = !1) : particle.body.checkCollision.none = !0, 
                        particle.body.collideWorldBounds = collideWorldBounds, particle.body.skipQuadTree = !0, 
                        particle.exists = !1, particle.visible = !1, particle.anchor.copyFrom(this.particleAnchor), 
                        this.add(particle), i++;
                        return this;
                    }, Phaser.Particles.Arcade.Emitter.prototype.kill = function() {
                        this.on = !1, this.alive = !1, this.exists = !1;
                    }, Phaser.Particles.Arcade.Emitter.prototype.revive = function() {
                        this.alive = !0, this.exists = !0;
                    }, Phaser.Particles.Arcade.Emitter.prototype.explode = function(lifespan, quantity) {
                        this.start(!0, lifespan, 0, quantity, !1);
                    }, Phaser.Particles.Arcade.Emitter.prototype.flow = function(lifespan, frequency, quantity) {
                        this.start(!1, lifespan, frequency, quantity, !0);
                    }, Phaser.Particles.Arcade.Emitter.prototype.start = function(explode, lifespan, frequency, quantity, forceQuantity) {
                        if ("undefined" == typeof explode && (explode = !0), "undefined" == typeof lifespan && (lifespan = 0), 
                        ("undefined" == typeof frequency || null === frequency) && (frequency = 250), "undefined" == typeof quantity && (quantity = 0), 
                        "undefined" == typeof forceQuantity && (forceQuantity = !1), quantity > this.maxParticles && (quantity = this.maxParticles), 
                        this.revive(), this.visible = !0, this.lifespan = lifespan, this.frequency = frequency, 
                        explode || forceQuantity) for (var i = 0; quantity > i; i++) this.emitParticle(); else this.on = !0, 
                        this._quantity += quantity, this._counter = 0, this._timer = this.game.time.time + frequency * this.game.time.slowMotion;
                    }, Phaser.Particles.Arcade.Emitter.prototype.emitParticle = function() {
                        var particle = this.getFirstExists(!1);
                        return null === particle ? !1 : (this.width > 1 || this.height > 1 ? particle.reset(this.game.rnd.integerInRange(this.left, this.right), this.game.rnd.integerInRange(this.top, this.bottom)) : particle.reset(this.emitX, this.emitY), 
                        particle.angle = 0, particle.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(particle) : this.particleSendToBack && this.sendToBack(particle), 
                        this.autoScale ? particle.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? particle.scale.set(this.game.rnd.realInRange(this.minParticleScale, this.maxParticleScale)) : (this._minParticleScale.x !== this._maxParticleScale.x || this._minParticleScale.y !== this._maxParticleScale.y) && particle.scale.set(this.game.rnd.realInRange(this._minParticleScale.x, this._maxParticleScale.x), this.game.rnd.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), 
                        particle.frame = Array.isArray("object" === this._frames) ? this.game.rnd.pick(this._frames) : this._frames, 
                        this.autoAlpha ? particle.setAlphaData(this.alphaData) : particle.alpha = this.game.rnd.realInRange(this.minParticleAlpha, this.maxParticleAlpha), 
                        particle.blendMode = this.blendMode, particle.body.updateBounds(), particle.body.bounce.setTo(this.bounce.x, this.bounce.y), 
                        particle.body.velocity.x = this.game.rnd.integerInRange(this.minParticleSpeed.x, this.maxParticleSpeed.x), 
                        particle.body.velocity.y = this.game.rnd.integerInRange(this.minParticleSpeed.y, this.maxParticleSpeed.y), 
                        particle.body.angularVelocity = this.game.rnd.integerInRange(this.minRotation, this.maxRotation), 
                        particle.body.gravity.y = this.gravity, particle.body.drag.x = this.particleDrag.x, 
                        particle.body.drag.y = this.particleDrag.y, particle.body.angularDrag = this.angularDrag, 
                        particle.onEmit(), !0);
                    }, Phaser.Particles.Arcade.Emitter.prototype.setSize = function(width, height) {
                        this.area.width = width, this.area.height = height;
                    }, Phaser.Particles.Arcade.Emitter.prototype.setXSpeed = function(min, max) {
                        min = min || 0, max = max || 0, this.minParticleSpeed.x = min, this.maxParticleSpeed.x = max;
                    }, Phaser.Particles.Arcade.Emitter.prototype.setYSpeed = function(min, max) {
                        min = min || 0, max = max || 0, this.minParticleSpeed.y = min, this.maxParticleSpeed.y = max;
                    }, Phaser.Particles.Arcade.Emitter.prototype.setRotation = function(min, max) {
                        min = min || 0, max = max || 0, this.minRotation = min, this.maxRotation = max;
                    }, Phaser.Particles.Arcade.Emitter.prototype.setAlpha = function(min, max, rate, ease, yoyo) {
                        if ("undefined" == typeof min && (min = 1), "undefined" == typeof max && (max = 1), 
                        "undefined" == typeof rate && (rate = 0), "undefined" == typeof ease && (ease = Phaser.Easing.Linear.None), 
                        "undefined" == typeof yoyo && (yoyo = !1), this.minParticleAlpha = min, this.maxParticleAlpha = max, 
                        this.autoAlpha = !1, rate > 0 && min !== max) {
                            var tweenData = {
                                v: min
                            }, tween = this.game.make.tween(tweenData).to({
                                v: max
                            }, rate, ease);
                            tween.yoyo(yoyo), this.alphaData = tween.generateData(60), this.alphaData.reverse(), 
                            this.autoAlpha = !0;
                        }
                    }, Phaser.Particles.Arcade.Emitter.prototype.setScale = function(minX, maxX, minY, maxY, rate, ease, yoyo) {
                        if ("undefined" == typeof minX && (minX = 1), "undefined" == typeof maxX && (maxX = 1), 
                        "undefined" == typeof minY && (minY = 1), "undefined" == typeof maxY && (maxY = 1), 
                        "undefined" == typeof rate && (rate = 0), "undefined" == typeof ease && (ease = Phaser.Easing.Linear.None), 
                        "undefined" == typeof yoyo && (yoyo = !1), this.minParticleScale = 1, this.maxParticleScale = 1, 
                        this._minParticleScale.set(minX, minY), this._maxParticleScale.set(maxX, maxY), 
                        this.autoScale = !1, rate > 0 && (minX !== maxX || minY !== maxY)) {
                            var tweenData = {
                                x: minX,
                                y: minY
                            }, tween = this.game.make.tween(tweenData).to({
                                x: maxX,
                                y: maxY
                            }, rate, ease);
                            tween.yoyo(yoyo), this.scaleData = tween.generateData(60), this.scaleData.reverse(), 
                            this.autoScale = !0;
                        }
                    }, Phaser.Particles.Arcade.Emitter.prototype.at = function(object) {
                        object.center ? (this.emitX = object.center.x, this.emitY = object.center.y) : (this.emitX = object.world.x + object.anchor.x * object.width, 
                        this.emitY = object.world.y + object.anchor.y * object.height);
                    }, Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "width", {
                        get: function() {
                            return this.area.width;
                        },
                        set: function(value) {
                            this.area.width = value;
                        }
                    }), Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "height", {
                        get: function() {
                            return this.area.height;
                        },
                        set: function(value) {
                            this.area.height = value;
                        }
                    }), Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "x", {
                        get: function() {
                            return this.emitX;
                        },
                        set: function(value) {
                            this.emitX = value;
                        }
                    }), Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "y", {
                        get: function() {
                            return this.emitY;
                        },
                        set: function(value) {
                            this.emitY = value;
                        }
                    }), Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "left", {
                        get: function() {
                            return Math.floor(this.x - this.area.width / 2);
                        }
                    }), Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "right", {
                        get: function() {
                            return Math.floor(this.x + this.area.width / 2);
                        }
                    }), Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "top", {
                        get: function() {
                            return Math.floor(this.y - this.area.height / 2);
                        }
                    }), Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "bottom", {
                        get: function() {
                            return Math.floor(this.y + this.area.height / 2);
                        }
                    }), Phaser.Tile = function(layer, index, x, y, width, height) {
                        this.layer = layer, this.index = index, this.x = x, this.y = y, this.worldX = x * width, 
                        this.worldY = y * height, this.width = width, this.height = height, this.centerX = Math.abs(width / 2), 
                        this.centerY = Math.abs(height / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, 
                        this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, 
                        this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, 
                        this.collisionCallback = null, this.collisionCallbackContext = this;
                    }, Phaser.Tile.prototype = {
                        containsPoint: function(x, y) {
                            return !(x < this.worldX || y < this.worldY || x > this.right || y > this.bottom);
                        },
                        intersects: function(x, y, right, bottom) {
                            return right <= this.worldX ? !1 : bottom <= this.worldY ? !1 : x >= this.worldX + this.width ? !1 : y >= this.worldY + this.height ? !1 : !0;
                        },
                        setCollisionCallback: function(callback, context) {
                            this.collisionCallback = callback, this.collisionCallbackContext = context;
                        },
                        destroy: function() {
                            this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null;
                        },
                        setCollision: function(left, right, up, down) {
                            this.collideLeft = left, this.collideRight = right, this.collideUp = up, this.collideDown = down, 
                            this.faceLeft = left, this.faceRight = right, this.faceTop = up, this.faceBottom = down;
                        },
                        resetCollision: function() {
                            this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, 
                            this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1;
                        },
                        isInteresting: function(collides, faces) {
                            return collides && faces ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : collides ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : faces ? this.faceTop || this.faceBottom || this.faceLeft || this.faceRight : !1;
                        },
                        copy: function(tile) {
                            this.index = tile.index, this.alpha = tile.alpha, this.properties = tile.properties, 
                            this.collideUp = tile.collideUp, this.collideDown = tile.collideDown, this.collideLeft = tile.collideLeft, 
                            this.collideRight = tile.collideRight, this.collisionCallback = tile.collisionCallback, 
                            this.collisionCallbackContext = tile.collisionCallbackContext;
                        }
                    }, Phaser.Tile.prototype.constructor = Phaser.Tile, Object.defineProperty(Phaser.Tile.prototype, "collides", {
                        get: function() {
                            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
                        }
                    }), Object.defineProperty(Phaser.Tile.prototype, "canCollide", {
                        get: function() {
                            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback;
                        }
                    }), Object.defineProperty(Phaser.Tile.prototype, "left", {
                        get: function() {
                            return this.worldX;
                        }
                    }), Object.defineProperty(Phaser.Tile.prototype, "right", {
                        get: function() {
                            return this.worldX + this.width;
                        }
                    }), Object.defineProperty(Phaser.Tile.prototype, "top", {
                        get: function() {
                            return this.worldY;
                        }
                    }), Object.defineProperty(Phaser.Tile.prototype, "bottom", {
                        get: function() {
                            return this.worldY + this.height;
                        }
                    }), Phaser.Tilemap = function(game, key, tileWidth, tileHeight, width, height) {
                        this.game = game, this.key = key;
                        var data = Phaser.TilemapParser.parse(this.game, key, tileWidth, tileHeight, width, height);
                        null !== data && (this.width = data.width, this.height = data.height, this.tileWidth = data.tileWidth, 
                        this.tileHeight = data.tileHeight, this.orientation = data.orientation, this.format = data.format, 
                        this.version = data.version, this.properties = data.properties, this.widthInPixels = data.widthInPixels, 
                        this.heightInPixels = data.heightInPixels, this.layers = data.layers, this.tilesets = data.tilesets, 
                        this.tiles = data.tiles, this.objects = data.objects, this.collideIndexes = [], 
                        this.collision = data.collision, this.images = data.images, this.currentLayer = 0, 
                        this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0);
                    }, Phaser.Tilemap.CSV = 0, Phaser.Tilemap.TILED_JSON = 1, Phaser.Tilemap.NORTH = 0, 
                    Phaser.Tilemap.EAST = 1, Phaser.Tilemap.SOUTH = 2, Phaser.Tilemap.WEST = 3, Phaser.Tilemap.prototype = {
                        create: function(name, width, height, tileWidth, tileHeight, group) {
                            return "undefined" == typeof group && (group = this.game.world), this.width = width, 
                            this.height = height, this.setTileSize(tileWidth, tileHeight), this.layers.length = 0, 
                            this.createBlankLayer(name, width, height, tileWidth, tileHeight, group);
                        },
                        setTileSize: function(tileWidth, tileHeight) {
                            this.tileWidth = tileWidth, this.tileHeight = tileHeight, this.widthInPixels = this.width * tileWidth, 
                            this.heightInPixels = this.height * tileHeight;
                        },
                        addTilesetImage: function(tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {
                            if ("undefined" == typeof tileWidth && (tileWidth = this.tileWidth), "undefined" == typeof tileHeight && (tileHeight = this.tileHeight), 
                            "undefined" == typeof tileMargin && (tileMargin = 0), "undefined" == typeof tileSpacing && (tileSpacing = 0), 
                            "undefined" == typeof gid && (gid = 0), 0 === tileWidth && (tileWidth = 32), 0 === tileHeight && (tileHeight = 32), 
                            "undefined" == typeof key) {
                                if ("string" != typeof tileset) return null;
                                if (key = tileset, !this.game.cache.checkImageKey(key)) return console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + key + '"'), 
                                null;
                            }
                            if ("string" == typeof tileset && (tileset = this.getTilesetIndex(tileset), null === tileset && this.format === Phaser.Tilemap.TILED_JSON)) return console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + key + '"'), 
                            null;
                            if (this.tilesets[tileset]) return this.tilesets[tileset].setImage(this.game.cache.getImage(key)), 
                            this.tilesets[tileset];
                            var newSet = new Phaser.Tileset(key, gid, tileWidth, tileHeight, tileMargin, tileSpacing, {});
                            newSet.setImage(this.game.cache.getImage(key)), this.tilesets.push(newSet);
                            for (var i = this.tilesets.length - 1, x = tileMargin, y = tileMargin, count = 0, countX = 0, countY = 0, t = gid; t < gid + newSet.total && (this.tiles[t] = [ x, y, i ], 
                            x += tileWidth + tileSpacing, count++, count !== newSet.total) && (countX++, countX !== newSet.columns || (x = tileMargin, 
                            y += tileHeight + tileSpacing, countX = 0, countY++, countY !== newSet.rows)); t++) ;
                            return newSet;
                        },
                        createFromObjects: function(name, gid, key, frame, exists, autoCull, group, CustomClass, adjustY) {
                            if ("undefined" == typeof exists && (exists = !0), "undefined" == typeof autoCull && (autoCull = !1), 
                            "undefined" == typeof group && (group = this.game.world), "undefined" == typeof CustomClass && (CustomClass = Phaser.Sprite), 
                            "undefined" == typeof adjustY && (adjustY = !0), !this.objects[name]) return void console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + name);
                            for (var sprite, i = 0, len = this.objects[name].length; len > i; i++) if (this.objects[name][i].gid === gid) {
                                sprite = new CustomClass(this.game, this.objects[name][i].x, this.objects[name][i].y, key, frame), 
                                sprite.name = this.objects[name][i].name, sprite.visible = this.objects[name][i].visible, 
                                sprite.autoCull = autoCull, sprite.exists = exists, adjustY && (sprite.y -= sprite.height), 
                                group.add(sprite);
                                for (var property in this.objects[name][i].properties) group.set(sprite, property, this.objects[name][i].properties[property], !1, !1, 0, !0);
                            }
                        },
                        createFromTiles: function(tiles, replacements, key, layer, group, properties) {
                            "number" == typeof tiles && (tiles = [ tiles ]), "undefined" == typeof replacements || null === replacements ? replacements = [] : "number" == typeof replacements && (replacements = [ replacements ]), 
                            layer = this.getLayer(layer), "undefined" == typeof group && (group = this.game.world), 
                            "undefined" == typeof properties && (properties = {}), void 0 === properties.customClass && (properties.customClass = Phaser.Sprite), 
                            void 0 === properties.adjustY && (properties.adjustY = !0);
                            var lw = this.layers[layer].width, lh = this.layers[layer].height;
                            if (this.copy(0, 0, lw, lh, layer), this._results.length < 2) return 0;
                            for (var sprite, total = 0, i = 1, len = this._results.length; len > i; i++) if (-1 !== tiles.indexOf(this._results[i].index)) {
                                sprite = new properties.customClass(this.game, this._results[i].worldX, this._results[i].worldY, key);
                                for (var property in properties) sprite[property] = properties[property];
                                group.add(sprite), total++;
                            }
                            if (1 === replacements.length) for (i = 0; i < tiles.length; i++) this.replace(tiles[i], replacements[0], 0, 0, lw, lh, layer); else if (replacements.length > 1) for (i = 0; i < tiles.length; i++) this.replace(tiles[i], replacements[i], 0, 0, lw, lh, layer);
                            return total;
                        },
                        createLayer: function(layer, width, height, group) {
                            "undefined" == typeof width && (width = this.game.width), "undefined" == typeof height && (height = this.game.height), 
                            "undefined" == typeof group && (group = this.game.world);
                            var index = layer;
                            return "string" == typeof layer && (index = this.getLayerIndex(layer)), null === index || index > this.layers.length ? void console.warn("Tilemap.createLayer: Invalid layer ID given: " + index) : group.add(new Phaser.TilemapLayer(this.game, this, index, width, height));
                        },
                        createBlankLayer: function(name, width, height, tileWidth, tileHeight, group) {
                            if ("undefined" == typeof group && (group = this.game.world), null !== this.getLayerIndex(name)) return void console.warn("Tilemap.createBlankLayer: Layer with matching name already exists");
                            for (var row, layer = {
                                name: name,
                                x: 0,
                                y: 0,
                                width: width,
                                height: height,
                                widthInPixels: width * tileWidth,
                                heightInPixels: height * tileHeight,
                                alpha: 1,
                                visible: !0,
                                properties: {},
                                indexes: [],
                                callbacks: [],
                                bodies: [],
                                data: null
                            }, output = [], y = 0; height > y; y++) {
                                row = [];
                                for (var x = 0; width > x; x++) row.push(new Phaser.Tile(layer, -1, x, y, tileWidth, tileHeight));
                                output.push(row);
                            }
                            layer.data = output, this.layers.push(layer), this.currentLayer = this.layers.length - 1;
                            var w = layer.widthInPixels, h = layer.heightInPixels;
                            w > this.game.width && (w = this.game.width), h > this.game.height && (h = this.game.height);
                            var output = new Phaser.TilemapLayer(this.game, this, this.layers.length - 1, w, h);
                            return output.name = name, group.add(output);
                        },
                        getIndex: function(location, name) {
                            for (var i = 0; i < location.length; i++) if (location[i].name === name) return i;
                            return null;
                        },
                        getLayerIndex: function(name) {
                            return this.getIndex(this.layers, name);
                        },
                        getTilesetIndex: function(name) {
                            return this.getIndex(this.tilesets, name);
                        },
                        getImageIndex: function(name) {
                            return this.getIndex(this.images, name);
                        },
                        getObjectIndex: function(name) {
                            return this.getIndex(this.objects, name);
                        },
                        setTileIndexCallback: function(indexes, callback, callbackContext, layer) {
                            if (layer = this.getLayer(layer), "number" == typeof indexes) this.layers[layer].callbacks[indexes] = {
                                callback: callback,
                                callbackContext: callbackContext
                            }; else for (var i = 0, len = indexes.length; len > i; i++) this.layers[layer].callbacks[indexes[i]] = {
                                callback: callback,
                                callbackContext: callbackContext
                            };
                        },
                        setTileLocationCallback: function(x, y, width, height, callback, callbackContext, layer) {
                            if (layer = this.getLayer(layer), this.copy(x, y, width, height, layer), !(this._results.length < 2)) for (var i = 1; i < this._results.length; i++) this._results[i].setCollisionCallback(callback, callbackContext);
                        },
                        setCollision: function(indexes, collides, layer, recalculate) {
                            if ("undefined" == typeof collides && (collides = !0), "undefined" == typeof recalculate && (recalculate = !0), 
                            layer = this.getLayer(layer), "number" == typeof indexes) return this.setCollisionByIndex(indexes, collides, layer, !0);
                            for (var i = 0, len = indexes.length; len > i; i++) this.setCollisionByIndex(indexes[i], collides, layer, !1);
                            recalculate && this.calculateFaces(layer);
                        },
                        setCollisionBetween: function(start, stop, collides, layer, recalculate) {
                            if ("undefined" == typeof collides && (collides = !0), "undefined" == typeof recalculate && (recalculate = !0), 
                            layer = this.getLayer(layer), !(start > stop)) {
                                for (var index = start; stop >= index; index++) this.setCollisionByIndex(index, collides, layer, !1);
                                recalculate && this.calculateFaces(layer);
                            }
                        },
                        setCollisionByExclusion: function(indexes, collides, layer, recalculate) {
                            "undefined" == typeof collides && (collides = !0), "undefined" == typeof recalculate && (recalculate = !0), 
                            layer = this.getLayer(layer);
                            for (var i = 0, len = this.tiles.length; len > i; i++) -1 === indexes.indexOf(i) && this.setCollisionByIndex(i, collides, layer, !1);
                            recalculate && this.calculateFaces(layer);
                        },
                        setCollisionByIndex: function(index, collides, layer, recalculate) {
                            if ("undefined" == typeof collides && (collides = !0), "undefined" == typeof layer && (layer = this.currentLayer), 
                            "undefined" == typeof recalculate && (recalculate = !0), collides) this.collideIndexes.push(index); else {
                                var i = this.collideIndexes.indexOf(index);
                                i > -1 && this.collideIndexes.splice(i, 1);
                            }
                            for (var y = 0; y < this.layers[layer].height; y++) for (var x = 0; x < this.layers[layer].width; x++) {
                                var tile = this.layers[layer].data[y][x];
                                tile && tile.index === index && (collides ? tile.setCollision(!0, !0, !0, !0) : tile.resetCollision(), 
                                tile.faceTop = collides, tile.faceBottom = collides, tile.faceLeft = collides, tile.faceRight = collides);
                            }
                            return recalculate && this.calculateFaces(layer), layer;
                        },
                        getLayer: function(layer) {
                            return "undefined" == typeof layer ? layer = this.currentLayer : "string" == typeof layer ? layer = this.getLayerIndex(layer) : layer instanceof Phaser.TilemapLayer && (layer = layer.index), 
                            layer;
                        },
                        setPreventRecalculate: function(value) {
                            if (value === !0 && this.preventingRecalculate !== !0 && (this.preventingRecalculate = !0, 
                            this.needToRecalculate = {}), value === !1 && this.preventingRecalculate === !0) {
                                this.preventingRecalculate = !1;
                                for (var i in this.needToRecalculate) this.calculateFaces(i);
                                this.needToRecalculate = !1;
                            }
                        },
                        calculateFaces: function(layer) {
                            if (this.preventingRecalculate) return void (this.needToRecalculate[layer] = !0);
                            for (var above = null, below = null, left = null, right = null, y = 0, h = this.layers[layer].height; h > y; y++) for (var x = 0, w = this.layers[layer].width; w > x; x++) {
                                var tile = this.layers[layer].data[y][x];
                                tile && (above = this.getTileAbove(layer, x, y), below = this.getTileBelow(layer, x, y), 
                                left = this.getTileLeft(layer, x, y), right = this.getTileRight(layer, x, y), tile.collides && (tile.faceTop = !0, 
                                tile.faceBottom = !0, tile.faceLeft = !0, tile.faceRight = !0), above && above.collides && (tile.faceTop = !1), 
                                below && below.collides && (tile.faceBottom = !1), left && left.collides && (tile.faceLeft = !1), 
                                right && right.collides && (tile.faceRight = !1));
                            }
                        },
                        getTileAbove: function(layer, x, y) {
                            return y > 0 ? this.layers[layer].data[y - 1][x] : null;
                        },
                        getTileBelow: function(layer, x, y) {
                            return y < this.layers[layer].height - 1 ? this.layers[layer].data[y + 1][x] : null;
                        },
                        getTileLeft: function(layer, x, y) {
                            return x > 0 ? this.layers[layer].data[y][x - 1] : null;
                        },
                        getTileRight: function(layer, x, y) {
                            return x < this.layers[layer].width - 1 ? this.layers[layer].data[y][x + 1] : null;
                        },
                        setLayer: function(layer) {
                            layer = this.getLayer(layer), this.layers[layer] && (this.currentLayer = layer);
                        },
                        hasTile: function(x, y, layer) {
                            return layer = this.getLayer(layer), this.layers[layer].data[y][x].index > -1;
                        },
                        removeTile: function(x, y, layer) {
                            if (layer = this.getLayer(layer), x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height && this.hasTile(x, y, layer)) {
                                var tile = this.layers[layer].data[y][x];
                                return this.layers[layer].data[y][x] = new Phaser.Tile(this.layers[layer], -1, x, y, this.tileWidth, this.tileHeight), 
                                this.layers[layer].dirty = !0, this.calculateFaces(layer), tile;
                            }
                        },
                        removeTileWorldXY: function(x, y, tileWidth, tileHeight, layer) {
                            return layer = this.getLayer(layer), x = this.game.math.snapToFloor(x, tileWidth) / tileWidth, 
                            y = this.game.math.snapToFloor(y, tileHeight) / tileHeight, this.removeTile(x, y, layer);
                        },
                        putTile: function(tile, x, y, layer) {
                            if (null === tile) return this.removeTile(x, y, layer);
                            if (layer = this.getLayer(layer), x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height) {
                                var index;
                                return tile instanceof Phaser.Tile ? (index = tile.index, this.hasTile(x, y, layer) ? this.layers[layer].data[y][x].copy(tile) : this.layers[layer].data[y][x] = new Phaser.Tile(layer, index, x, y, tile.width, tile.height)) : (index = tile, 
                                this.hasTile(x, y, layer) ? this.layers[layer].data[y][x].index = index : this.layers[layer].data[y][x] = new Phaser.Tile(this.layers[layer], index, x, y, this.tileWidth, this.tileHeight)), 
                                this.collideIndexes.indexOf(index) > -1 ? this.layers[layer].data[y][x].setCollision(!0, !0, !0, !0) : this.layers[layer].data[y][x].resetCollision(), 
                                this.layers[layer].dirty = !0, this.calculateFaces(layer), this.layers[layer].data[y][x];
                            }
                            return null;
                        },
                        putTileWorldXY: function(tile, x, y, tileWidth, tileHeight, layer) {
                            return layer = this.getLayer(layer), x = this.game.math.snapToFloor(x, tileWidth) / tileWidth, 
                            y = this.game.math.snapToFloor(y, tileHeight) / tileHeight, this.putTile(tile, x, y, layer);
                        },
                        searchTileIndex: function(index, skip, reverse, layer) {
                            "undefined" == typeof skip && (skip = 0), "undefined" == typeof reverse && (reverse = !1), 
                            layer = this.getLayer(layer);
                            var c = 0;
                            if (reverse) {
                                for (var y = this.layers[layer].height - 1; y >= 0; y--) for (var x = this.layers[layer].width - 1; x >= 0; x--) if (this.layers[layer].data[y][x].index === index) {
                                    if (c === skip) return this.layers[layer].data[y][x];
                                    c++;
                                }
                            } else for (var y = 0; y < this.layers[layer].height; y++) for (var x = 0; x < this.layers[layer].width; x++) if (this.layers[layer].data[y][x].index === index) {
                                if (c === skip) return this.layers[layer].data[y][x];
                                c++;
                            }
                            return null;
                        },
                        getTile: function(x, y, layer, nonNull) {
                            return "undefined" == typeof nonNull && (nonNull = !1), layer = this.getLayer(layer), 
                            x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height ? -1 === this.layers[layer].data[y][x].index ? nonNull ? this.layers[layer].data[y][x] : null : this.layers[layer].data[y][x] : null;
                        },
                        getTileWorldXY: function(x, y, tileWidth, tileHeight, layer) {
                            return "undefined" == typeof tileWidth && (tileWidth = this.tileWidth), "undefined" == typeof tileHeight && (tileHeight = this.tileHeight), 
                            layer = this.getLayer(layer), x = this.game.math.snapToFloor(x, tileWidth) / tileWidth, 
                            y = this.game.math.snapToFloor(y, tileHeight) / tileHeight, this.getTile(x, y, layer);
                        },
                        copy: function(x, y, width, height, layer) {
                            if (layer = this.getLayer(layer), !this.layers[layer]) return void (this._results.length = 0);
                            "undefined" == typeof x && (x = 0), "undefined" == typeof y && (y = 0), "undefined" == typeof width && (width = this.layers[layer].width), 
                            "undefined" == typeof height && (height = this.layers[layer].height), 0 > x && (x = 0), 
                            0 > y && (y = 0), width > this.layers[layer].width && (width = this.layers[layer].width), 
                            height > this.layers[layer].height && (height = this.layers[layer].height), this._results.length = 0, 
                            this._results.push({
                                x: x,
                                y: y,
                                width: width,
                                height: height,
                                layer: layer
                            });
                            for (var ty = y; y + height > ty; ty++) for (var tx = x; x + width > tx; tx++) this._results.push(this.layers[layer].data[ty][tx]);
                            return this._results;
                        },
                        paste: function(x, y, tileblock, layer) {
                            if ("undefined" == typeof x && (x = 0), "undefined" == typeof y && (y = 0), layer = this.getLayer(layer), 
                            tileblock && !(tileblock.length < 2)) {
                                for (var diffX = tileblock[1].x - x, diffY = tileblock[1].y - y, i = 1; i < tileblock.length; i++) this.layers[layer].data[diffY + tileblock[i].y][diffX + tileblock[i].x].copy(tileblock[i]);
                                this.layers[layer].dirty = !0, this.calculateFaces(layer);
                            }
                        },
                        swap: function(tileA, tileB, x, y, width, height, layer) {
                            layer = this.getLayer(layer), this.copy(x, y, width, height, layer), this._results.length < 2 || (this._tempA = tileA, 
                            this._tempB = tileB, this._results.forEach(this.swapHandler, this), this.paste(x, y, this._results, layer));
                        },
                        swapHandler: function(value) {
                            value.index === this._tempA ? value.index = this._tempB : value.index === this._tempB && (value.index = this._tempA);
                        },
                        forEach: function(callback, context, x, y, width, height, layer) {
                            layer = this.getLayer(layer), this.copy(x, y, width, height, layer), this._results.length < 2 || (this._results.forEach(callback, context), 
                            this.paste(x, y, this._results, layer));
                        },
                        replace: function(source, dest, x, y, width, height, layer) {
                            if (layer = this.getLayer(layer), this.copy(x, y, width, height, layer), !(this._results.length < 2)) {
                                for (var i = 1; i < this._results.length; i++) this._results[i].index === source && (this._results[i].index = dest);
                                this.paste(x, y, this._results, layer);
                            }
                        },
                        random: function(x, y, width, height, layer) {
                            if (layer = this.getLayer(layer), this.copy(x, y, width, height, layer), !(this._results.length < 2)) {
                                for (var indexes = [], t = 1; t < this._results.length; t++) if (this._results[t].index) {
                                    var idx = this._results[t].index;
                                    -1 === indexes.indexOf(idx) && indexes.push(idx);
                                }
                                for (var i = 1; i < this._results.length; i++) this._results[i].index = this.game.rnd.pick(indexes);
                                this.paste(x, y, this._results, layer);
                            }
                        },
                        shuffle: function(x, y, width, height, layer) {
                            if (layer = this.getLayer(layer), this.copy(x, y, width, height, layer), !(this._results.length < 2)) {
                                for (var indexes = [], t = 1; t < this._results.length; t++) this._results[t].index && indexes.push(this._results[t].index);
                                Phaser.Utils.shuffle(indexes);
                                for (var i = 1; i < this._results.length; i++) this._results[i].index = indexes[i - 1];
                                this.paste(x, y, this._results, layer);
                            }
                        },
                        fill: function(index, x, y, width, height, layer) {
                            if (layer = this.getLayer(layer), this.copy(x, y, width, height, layer), !(this._results.length < 2)) {
                                for (var i = 1; i < this._results.length; i++) this._results[i].index = index;
                                this.paste(x, y, this._results, layer);
                            }
                        },
                        removeAllLayers: function() {
                            this.layers.length = 0, this.currentLayer = 0;
                        },
                        dump: function() {
                            for (var txt = "", args = [ "" ], y = 0; y < this.layers[this.currentLayer].height; y++) {
                                for (var x = 0; x < this.layers[this.currentLayer].width; x++) txt += "%c  ", args.push(this.layers[this.currentLayer].data[y][x] > 1 ? this.debugMap[this.layers[this.currentLayer].data[y][x]] ? "background: " + this.debugMap[this.layers[this.currentLayer].data[y][x]] : "background: #ffffff" : "background: rgb(0, 0, 0)");
                                txt += "\n";
                            }
                            args[0] = txt, console.log.apply(console, args);
                        },
                        destroy: function() {
                            this.removeAllLayers(), this.data = [], this.game = null;
                        }
                    }, Phaser.Tilemap.prototype.constructor = Phaser.Tilemap, Object.defineProperty(Phaser.Tilemap.prototype, "layer", {
                        get: function() {
                            return this.layers[this.currentLayer];
                        },
                        set: function(value) {
                            value !== this.currentLayer && this.setLayer(value);
                        }
                    }), Phaser.TilemapLayer = function(game, tilemap, index, width, height) {
                        width |= 0, height |= 0, this.game = game, this.map = tilemap, this.index = index, 
                        this.layer = tilemap.layers[index], this.canvas = Phaser.Canvas.create(width, height), 
                        this.context = this.canvas.getContext("2d"), this.baseTexture = new PIXI.BaseTexture(this.canvas), 
                        this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new Phaser.Frame(0, 0, 0, width, height, "tilemapLayer", game.rnd.uuid()), 
                        Phaser.Image.call(this, this.game, 0, 0, this.texture, this.textureFrame), this.name = "", 
                        this.type = Phaser.TILEMAPLAYER, this.fixedToCamera = !0, this.cameraOffset = new Phaser.Point(0, 0), 
                        this.renderSettings = {
                            enableScrollDelta: !0,
                            overdrawRatio: .2,
                            copyCanvas: null,
                            copySliceCount: 4
                        }, this.debug = !1, this.debugSettings = {
                            missingImageFill: "rgb(255,255,255)",
                            debuggedTileOverfill: "rgba(0,255,0,0.4)",
                            forceFullRedraw: !0,
                            debugAlpha: .5,
                            facingEdgeStroke: "rgba(0,255,0,1)",
                            collidingTileOverfill: "rgba(0,255,0,0.2)"
                        }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, 
                        this._wrap = !1, this._mc = {
                            scrollX: 0,
                            scrollY: 0,
                            renderWidth: 0,
                            renderHeight: 0,
                            tileWidth: tilemap.tileWidth,
                            tileHeight: tilemap.tileHeight,
                            cw: tilemap.tileWidth,
                            ch: tilemap.tileHeight,
                            tilesets: []
                        }, this._scrollX = 0, this._scrollY = 0, this._results = [], game.device.canvasBitBltShift || (this.renderSettings.copyCanvas = Phaser.TilemapLayer.ensureSharedCopyCanvas());
                    }, Phaser.TilemapLayer.sharedCopyCanvas = null, Phaser.TilemapLayer.ensureSharedCopyCanvas = function() {
                        return this.sharedCopyCanvas || (this.sharedCopyCanvas = Phaser.Canvas.create(2, 2)), 
                        this.sharedCopyCanvas;
                    }, Phaser.TilemapLayer.prototype = Object.create(Phaser.Image.prototype), Phaser.TilemapLayer.prototype.constructor = Phaser.TilemapLayer, 
                    Object.defineProperty(Phaser.TilemapLayer.prototype, "tileColor", {
                        get: function() {
                            return this.debugSettings.missingImageFill;
                        },
                        set: function(value) {
                            this.debugSettings.missingImageFill = value;
                        }
                    }), Phaser.TilemapLayer.prototype.postUpdate = function() {
                        Phaser.Image.prototype.postUpdate.call(this);
                        var camera = this.game.camera;
                        this.scrollX = camera.x * this.scrollFactorX, this.scrollY = camera.y * this.scrollFactorY, 
                        this.render(), 1 === this._cache[7] && (this.position.x = (camera.view.x + this.cameraOffset.x) / camera.scale.x, 
                        this.position.y = (camera.view.y + this.cameraOffset.y) / camera.scale.y);
                    }, Phaser.TilemapLayer.prototype.resizeWorld = function() {
                        this.game.world.setBounds(0, 0, this.layer.widthInPixels, this.layer.heightInPixels);
                    }, Phaser.TilemapLayer.prototype._fixX = function(x) {
                        return 0 > x && (x = 0), 1 === this.scrollFactorX ? x : this._scrollX + (x - this._scrollX / this.scrollFactorX);
                    }, Phaser.TilemapLayer.prototype._unfixX = function(x) {
                        return 1 === this.scrollFactorX ? x : this._scrollX / this.scrollFactorX + (x - this._scrollX);
                    }, Phaser.TilemapLayer.prototype._fixY = function(y) {
                        return 0 > y && (y = 0), 1 === this.scrollFactorY ? y : this._scrollY + (y - this._scrollY / this.scrollFactorY);
                    }, Phaser.TilemapLayer.prototype._unfixY = function(y) {
                        return 1 === this.scrollFactorY ? y : this._scrollY / this.scrollFactorY + (y - this._scrollY);
                    }, Phaser.TilemapLayer.prototype.getTileX = function(x) {
                        return Math.floor(this._fixX(x) / this._mc.tileWidth);
                    }, Phaser.TilemapLayer.prototype.getTileY = function(y) {
                        return Math.floor(this._fixY(y) / this._mc.tileHeight);
                    }, Phaser.TilemapLayer.prototype.getTileXY = function(x, y, point) {
                        return point.x = this.getTileX(x), point.y = this.getTileY(y), point;
                    }, Phaser.TilemapLayer.prototype.getRayCastTiles = function(line, stepRate, collides, interestingFace) {
                        stepRate || (stepRate = this.rayStepRate), "undefined" == typeof collides && (collides = !1), 
                        "undefined" == typeof interestingFace && (interestingFace = !1);
                        var tiles = this.getTiles(line.x, line.y, line.width, line.height, collides, interestingFace);
                        if (0 === tiles.length) return [];
                        for (var coords = line.coordinatesOnLine(stepRate), results = [], i = 0; i < tiles.length; i++) for (var t = 0; t < coords.length; t++) {
                            var tile = tiles[i], coord = coords[t];
                            if (tile.containsPoint(coord[0], coord[1])) {
                                results.push(tile);
                                break;
                            }
                        }
                        return results;
                    }, Phaser.TilemapLayer.prototype.getTiles = function(x, y, width, height, collides, interestingFace) {
                        "undefined" == typeof collides && (collides = !1), "undefined" == typeof interestingFace && (interestingFace = !1);
                        var fetchAll = !(collides || interestingFace);
                        x = this._fixX(x), y = this._fixY(y);
                        for (var tx = Math.floor(x / this._mc.cw), ty = Math.floor(y / this._mc.ch), tw = Math.ceil((x + width) / this._mc.cw) - tx, th = Math.ceil((y + height) / this._mc.ch) - ty; this._results.length; ) this._results.pop();
                        for (var wy = ty; ty + th > wy; wy++) for (var wx = tx; tx + tw > wx; wx++) {
                            var row = this.layer.data[wy];
                            row && row[wx] && (fetchAll || row[wx].isInteresting(collides, interestingFace)) && this._results.push(row[wx]);
                        }
                        return this._results;
                    }, Object.defineProperty(Phaser.TilemapLayer.prototype, "wrap", {
                        get: function() {
                            return this._wrap;
                        },
                        set: function(value) {
                            this._wrap = value, this.dirty = !0;
                        }
                    }), Phaser.TilemapLayer.prototype.resolveTileset = function(tileIndex) {
                        var tilesets = this._mc.tilesets;
                        if (2e3 > tileIndex) for (;tilesets.length < tileIndex; ) tilesets.push(void 0);
                        var setIndex = this.map.tiles[tileIndex] && this.map.tiles[tileIndex][2];
                        if (null != setIndex) {
                            var tileset = this.map.tilesets[setIndex];
                            if (tileset && tileset.containsTileIndex(tileIndex)) return tilesets[tileIndex] = tileset;
                        }
                        return tilesets[tileIndex] = null;
                    }, Phaser.TilemapLayer.prototype.resetTilesetCache = function() {
                        for (var tilesets = this._mc.tilesets; tilesets.length; ) tilesets.pop();
                    }, Phaser.TilemapLayer.prototype.shiftCanvas = function(context, x, y) {
                        var canvas = context.canvas, copyW = canvas.width - Math.abs(x), copyH = canvas.height - Math.abs(y), dx = 0, dy = 0, sx = x, sy = y;
                        0 > x && (dx = -x, sx = 0), 0 > y && (dy = -y, sy = 0);
                        var copyCanvas = this.renderSettings.copyCanvas;
                        if (copyCanvas) {
                            var sliceCount = this.renderSettings.copySliceCount, sH = Math.ceil(copyH / sliceCount);
                            copyCanvas.width < copyW && (copyCanvas.width = copyW), copyCanvas.height < sH && (copyCanvas.height = sH);
                            var vShift;
                            dy >= sy ? vShift = sH : (vShift = -sH, dy += sH * (sliceCount - 1), sy += sH * (sliceCount - 1));
                            for (var copyContext = copyCanvas.getContext("2d"); sliceCount--; ) copyContext.clearRect(0, 0, copyW, sH), 
                            copyContext.drawImage(canvas, dx, dy, copyW, sH, 0, 0, copyW, sH), context.clearRect(sx, sy, copyW, sH), 
                            context.drawImage(copyCanvas, 0, 0, copyW, sH, sx, sy, copyW, sH), dy += vShift, 
                            sy += vShift;
                        } else context.save(), context.globalCompositeOperation = "copy", context.drawImage(canvas, dx, dy, copyW, copyH, sx, sy, copyW, copyH), 
                        context.restore();
                    }, Phaser.TilemapLayer.prototype.renderRegion = function(scrollX, scrollY, left, top, right, bottom) {
                        var context = this.context, width = this.layer.width, height = this.layer.height, tw = this._mc.tileWidth, th = this._mc.tileHeight, tilesets = this._mc.tilesets, lastAlpha = 0 / 0;
                        this._wrap || (right >= left && (left = Math.max(0, left), right = Math.min(width - 1, right)), 
                        bottom >= top && (top = Math.max(0, top), bottom = Math.min(height - 1, bottom)));
                        var tx, ty, x, y, xmax, ymax, baseX = left * tw - scrollX, baseY = top * th - scrollY, normStartX = (left + (1 << 20) * width) % width, normStartY = (top + (1 << 20) * height) % height;
                        for (context.fillStyle = this.tileColor, y = normStartY, ymax = bottom - top, ty = baseY; ymax >= 0; y++, 
                        ymax--, ty += th) {
                            y >= height && (y -= height);
                            var row = this.layer.data[y];
                            for (x = normStartX, xmax = right - left, tx = baseX; xmax >= 0; x++, xmax--, tx += tw) {
                                x >= width && (x -= width);
                                var tile = row[x];
                                if (tile && !(tile.index < 0)) {
                                    var index = tile.index, set = tilesets[index];
                                    void 0 === set && (set = this.resolveTileset(index)), tile.alpha === lastAlpha || this.debug || (context.globalAlpha = tile.alpha, 
                                    lastAlpha = tile.alpha), set ? set.draw(context, tx, ty, index) : this.debugSettings.missingImageFill && (context.fillStyle = this.debugSettings.missingImageFill, 
                                    context.fillRect(tx, ty, tw, th)), tile.debug && this.debugSettings.debuggedTileOverfill && (context.fillStyle = this.debugSettings.debuggedTileOverfill, 
                                    context.fillRect(tx, ty, tw, th));
                                }
                            }
                        }
                    }, Phaser.TilemapLayer.prototype.renderDeltaScroll = function(shiftX, shiftY) {
                        var scrollX = this._mc.scrollX, scrollY = this._mc.scrollY, renderW = this.canvas.width, renderH = this.canvas.height, tw = this._mc.tileWidth, th = this._mc.tileHeight, left = 0, right = -tw, top = 0, bottom = -th;
                        if (0 > shiftX ? (left = renderW + shiftX, right = renderW - 1) : shiftX > 0 && (right = shiftX), 
                        0 > shiftY ? (top = renderH + shiftY, bottom = renderH - 1) : shiftY > 0 && (bottom = shiftY), 
                        this.shiftCanvas(this.context, shiftX, shiftY), left = Math.floor((left + scrollX) / tw), 
                        right = Math.floor((right + scrollX) / tw), top = Math.floor((top + scrollY) / th), 
                        bottom = Math.floor((bottom + scrollY) / th), right >= left) {
                            this.context.clearRect(left * tw - scrollX, 0, (right - left + 1) * tw, renderH);
                            var trueTop = Math.floor((0 + scrollY) / th), trueBottom = Math.floor((renderH - 1 + scrollY) / th);
                            this.renderRegion(scrollX, scrollY, left, trueTop, right, trueBottom);
                        }
                        if (bottom >= top) {
                            this.context.clearRect(0, top * th - scrollY, renderW, (bottom - top + 1) * th);
                            var trueLeft = Math.floor((0 + scrollX) / tw), trueRight = Math.floor((renderW - 1 + scrollX) / tw);
                            this.renderRegion(scrollX, scrollY, trueLeft, top, trueRight, bottom);
                        }
                    }, Phaser.TilemapLayer.prototype.renderFull = function() {
                        var scrollX = this._mc.scrollX, scrollY = this._mc.scrollY, renderW = this.canvas.width, renderH = this.canvas.height, tw = this._mc.tileWidth, th = this._mc.tileHeight, left = Math.floor(scrollX / tw), right = Math.floor((renderW - 1 + scrollX) / tw), top = Math.floor(scrollY / th), bottom = Math.floor((renderH - 1 + scrollY) / th);
                        this.context.clearRect(0, 0, renderW, renderH), this.renderRegion(scrollX, scrollY, left, top, right, bottom);
                    }, Phaser.TilemapLayer.prototype.render = function() {
                        var redrawAll = !1;
                        if (this.visible) {
                            (this.dirty || this.layer.dirty) && (this.layer.dirty = !1, redrawAll = !0);
                            var renderWidth = this.canvas.width, renderHeight = this.canvas.height, scrollX = 0 | this._scrollX, scrollY = 0 | this._scrollY, mc = this._mc, shiftX = mc.scrollX - scrollX, shiftY = mc.scrollY - scrollY;
                            if (redrawAll || 0 !== shiftX || 0 !== shiftY || mc.renderWidth !== renderWidth || mc.renderHeight !== renderHeight) return mc.scrollX = scrollX, 
                            mc.scrollY = scrollY, (mc.renderWidth !== renderWidth || mc.renderHeight !== renderHeight) && (mc.renderWidth = renderWidth, 
                            mc.renderHeight = renderHeight), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, 
                            this.debugSettings.forceFullRedraw && (redrawAll = !0)), !redrawAll && this.renderSettings.enableScrollDelta && Math.abs(shiftX) + Math.abs(shiftY) < Math.min(renderWidth, renderHeight) ? this.renderDeltaScroll(shiftX, shiftY) : this.renderFull(), 
                            this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.baseTexture.dirty(), 
                            this.dirty = !1, !0;
                        }
                    }, Phaser.TilemapLayer.prototype.renderDebug = function() {
                        var tx, ty, x, y, xmax, ymax, scrollX = this._mc.scrollX, scrollY = this._mc.scrollY, context = this.context, renderW = this.canvas.width, renderH = this.canvas.height, width = this.layer.width, height = this.layer.height, tw = this._mc.tileWidth, th = this._mc.tileHeight, left = Math.floor(scrollX / tw), right = Math.floor((renderW - 1 + scrollX) / tw), top = Math.floor(scrollY / th), bottom = Math.floor((renderH - 1 + scrollY) / th), baseX = left * tw - scrollX, baseY = top * th - scrollY, normStartX = (left + (1 << 20) * width) % width, normStartY = (top + (1 << 20) * height) % height;
                        for (context.strokeStyle = this.debugSettings.facingEdgeStroke, y = normStartY, 
                        ymax = bottom - top, ty = baseY; ymax >= 0; y++, ymax--, ty += th) {
                            y >= height && (y -= height);
                            var row = this.layer.data[y];
                            for (x = normStartX, xmax = right - left, tx = baseX; xmax >= 0; x++, xmax--, tx += tw) {
                                x >= width && (x -= width);
                                var tile = row[x];
                                !tile || tile.index < 0 || !tile.collides || (this.debugSettings.collidingTileOverfill && (context.fillStyle = this.debugSettings.collidingTileOverfill, 
                                context.fillRect(tx, ty, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (context.beginPath(), 
                                tile.faceTop && (context.moveTo(tx, ty), context.lineTo(tx + this._mc.cw, ty)), 
                                tile.faceBottom && (context.moveTo(tx, ty + this._mc.ch), context.lineTo(tx + this._mc.cw, ty + this._mc.ch)), 
                                tile.faceLeft && (context.moveTo(tx, ty), context.lineTo(tx, ty + this._mc.ch)), 
                                tile.faceRight && (context.moveTo(tx + this._mc.cw, ty), context.lineTo(tx + this._mc.cw, ty + this._mc.ch)), 
                                context.stroke()));
                            }
                        }
                    }, Object.defineProperty(Phaser.TilemapLayer.prototype, "scrollX", {
                        get: function() {
                            return this._scrollX;
                        },
                        set: function(value) {
                            this._scrollX = value;
                        }
                    }), Object.defineProperty(Phaser.TilemapLayer.prototype, "scrollY", {
                        get: function() {
                            return this._scrollY;
                        },
                        set: function(value) {
                            this._scrollY = value;
                        }
                    }), Object.defineProperty(Phaser.TilemapLayer.prototype, "collisionWidth", {
                        get: function() {
                            return this._mc.cw;
                        },
                        set: function(value) {
                            this._mc.cw = 0 | value, this.dirty = !0;
                        }
                    }), Object.defineProperty(Phaser.TilemapLayer.prototype, "collisionHeight", {
                        get: function() {
                            return this._mc.ch;
                        },
                        set: function(value) {
                            this._mc.ch = 0 | value, this.dirty = !0;
                        }
                    }), Phaser.TilemapParser = {
                        parse: function(game, key, tileWidth, tileHeight, width, height) {
                            if ("undefined" == typeof tileWidth && (tileWidth = 32), "undefined" == typeof tileHeight && (tileHeight = 32), 
                            "undefined" == typeof width && (width = 10), "undefined" == typeof height && (height = 10), 
                            "undefined" == typeof key) return this.getEmptyData();
                            if (null === key) return this.getEmptyData(tileWidth, tileHeight, width, height);
                            var map = game.cache.getTilemapData(key);
                            if (map) {
                                if (map.format === Phaser.Tilemap.CSV) return this.parseCSV(key, map.data, tileWidth, tileHeight);
                                if (!map.format || map.format === Phaser.Tilemap.TILED_JSON) return this.parseTiledJSON(map.data);
                            } else console.warn("Phaser.TilemapParser.parse - No map data found for key " + key);
                        },
                        parseCSV: function(key, data, tileWidth, tileHeight) {
                            var map = this.getEmptyData();
                            data = data.trim();
                            for (var output = [], rows = data.split("\n"), height = rows.length, width = 0, y = 0; y < rows.length; y++) {
                                output[y] = [];
                                for (var column = rows[y].split(","), x = 0; x < column.length; x++) output[y][x] = new Phaser.Tile(map.layers[0], parseInt(column[x], 10), x, y, tileWidth, tileHeight);
                                0 === width && (width = column.length);
                            }
                            return map.format = Phaser.Tilemap.CSV, map.name = key, map.width = width, map.height = height, 
                            map.tileWidth = tileWidth, map.tileHeight = tileHeight, map.widthInPixels = width * tileWidth, 
                            map.heightInPixels = height * tileHeight, map.layers[0].width = width, map.layers[0].height = height, 
                            map.layers[0].widthInPixels = map.widthInPixels, map.layers[0].heightInPixels = map.heightInPixels, 
                            map.layers[0].data = output, map;
                        },
                        getEmptyData: function(tileWidth, tileHeight, width, height) {
                            var map = {};
                            map.width = 0, map.height = 0, map.tileWidth = 0, map.tileHeight = 0, "undefined" != typeof tileWidth && null !== tileWidth && (map.tileWidth = tileWidth), 
                            "undefined" != typeof tileHeight && null !== tileHeight && (map.tileHeight = tileHeight), 
                            "undefined" != typeof width && null !== width && (map.width = width), "undefined" != typeof height && null !== height && (map.height = height), 
                            map.orientation = "orthogonal", map.version = "1", map.properties = {}, map.widthInPixels = 0, 
                            map.heightInPixels = 0;
                            var layers = [], layer = {
                                name: "layer",
                                x: 0,
                                y: 0,
                                width: 0,
                                height: 0,
                                widthInPixels: 0,
                                heightInPixels: 0,
                                alpha: 1,
                                visible: !0,
                                properties: {},
                                indexes: [],
                                callbacks: [],
                                bodies: [],
                                data: []
                            };
                            return layers.push(layer), map.layers = layers, map.images = [], map.objects = {}, 
                            map.collision = {}, map.tilesets = [], map.tiles = [], map;
                        },
                        parseTiledJSON: function(json) {
                            function slice(obj, fields) {
                                var sliced = {};
                                for (var k in fields) {
                                    var key = fields[k];
                                    sliced[key] = obj[key];
                                }
                                return sliced;
                            }
                            if ("orthogonal" !== json.orientation) return console.warn("TilemapParser.parseTiledJSON - Only orthogonal map types are supported in this version of Phaser"), 
                            null;
                            var map = {};
                            map.width = json.width, map.height = json.height, map.tileWidth = json.tilewidth, 
                            map.tileHeight = json.tileheight, map.orientation = json.orientation, map.format = Phaser.Tilemap.TILED_JSON, 
                            map.version = json.version, map.properties = json.properties, map.widthInPixels = map.width * map.tileWidth, 
                            map.heightInPixels = map.height * map.tileHeight;
                            for (var layers = [], i = 0; i < json.layers.length; i++) if ("tilelayer" === json.layers[i].type) {
                                var layer = {
                                    name: json.layers[i].name,
                                    x: json.layers[i].x,
                                    y: json.layers[i].y,
                                    width: json.layers[i].width,
                                    height: json.layers[i].height,
                                    widthInPixels: json.layers[i].width * json.tilewidth,
                                    heightInPixels: json.layers[i].height * json.tileheight,
                                    alpha: json.layers[i].opacity,
                                    visible: json.layers[i].visible,
                                    properties: {},
                                    indexes: [],
                                    callbacks: [],
                                    bodies: []
                                };
                                json.layers[i].properties && (layer.properties = json.layers[i].properties);
                                for (var x = 0, row = [], output = [], t = 0, len = json.layers[i].data.length; len > t; t++) row.push(json.layers[i].data[t] > 0 ? new Phaser.Tile(layer, json.layers[i].data[t], x, output.length, json.tilewidth, json.tileheight) : new Phaser.Tile(layer, -1, x, output.length, json.tilewidth, json.tileheight)), 
                                x++, x === json.layers[i].width && (output.push(row), x = 0, row = []);
                                layer.data = output, layers.push(layer);
                            }
                            map.layers = layers;
                            for (var images = [], i = 0; i < json.layers.length; i++) if ("imagelayer" === json.layers[i].type) {
                                var image = {
                                    name: json.layers[i].name,
                                    image: json.layers[i].image,
                                    x: json.layers[i].x,
                                    y: json.layers[i].y,
                                    alpha: json.layers[i].opacity,
                                    visible: json.layers[i].visible,
                                    properties: {}
                                };
                                json.layers[i].properties && (image.properties = json.layers[i].properties), images.push(image);
                            }
                            map.images = images;
                            for (var tilesets = [], i = 0; i < json.tilesets.length; i++) {
                                var set = json.tilesets[i];
                                if (set.image) {
                                    var newSet = new Phaser.Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);
                                    set.tileproperties && (newSet.tileProperties = set.tileproperties), newSet.updateTileData(set.imagewidth, set.imageheight), 
                                    tilesets.push(newSet);
                                } else console.warn("Phaser.TilemapParser - Image Collection Tilesets are not support");
                            }
                            map.tilesets = tilesets;
                            for (var objects = {}, collision = {}, i = 0; i < json.layers.length; i++) if ("objectgroup" === json.layers[i].type) {
                                objects[json.layers[i].name] = [], collision[json.layers[i].name] = [];
                                for (var v = 0, len = json.layers[i].objects.length; len > v; v++) if (json.layers[i].objects[v].gid) {
                                    var object = {
                                        gid: json.layers[i].objects[v].gid,
                                        name: json.layers[i].objects[v].name,
                                        x: json.layers[i].objects[v].x,
                                        y: json.layers[i].objects[v].y,
                                        visible: json.layers[i].objects[v].visible,
                                        properties: json.layers[i].objects[v].properties
                                    };
                                    objects[json.layers[i].name].push(object);
                                } else if (json.layers[i].objects[v].polyline) {
                                    var object = {
                                        name: json.layers[i].objects[v].name,
                                        type: json.layers[i].objects[v].type,
                                        x: json.layers[i].objects[v].x,
                                        y: json.layers[i].objects[v].y,
                                        width: json.layers[i].objects[v].width,
                                        height: json.layers[i].objects[v].height,
                                        visible: json.layers[i].objects[v].visible,
                                        properties: json.layers[i].objects[v].properties
                                    };
                                    object.polyline = [];
                                    for (var p = 0; p < json.layers[i].objects[v].polyline.length; p++) object.polyline.push([ json.layers[i].objects[v].polyline[p].x, json.layers[i].objects[v].polyline[p].y ]);
                                    collision[json.layers[i].name].push(object), objects[json.layers[i].name].push(object);
                                } else if (json.layers[i].objects[v].polygon) {
                                    var object = slice(json.layers[i].objects[v], [ "name", "type", "x", "y", "visible", "properties" ]);
                                    object.polygon = [];
                                    for (var p = 0; p < json.layers[i].objects[v].polygon.length; p++) object.polygon.push([ json.layers[i].objects[v].polygon[p].x, json.layers[i].objects[v].polygon[p].y ]);
                                    objects[json.layers[i].name].push(object);
                                } else if (json.layers[i].objects[v].ellipse) {
                                    var object = slice(json.layers[i].objects[v], [ "name", "type", "ellipse", "x", "y", "width", "height", "visible", "properties" ]);
                                    objects[json.layers[i].name].push(object);
                                } else {
                                    var object = slice(json.layers[i].objects[v], [ "name", "type", "x", "y", "width", "height", "visible", "properties" ]);
                                    object.rectangle = !0, objects[json.layers[i].name].push(object);
                                }
                            }
                            map.objects = objects, map.collision = collision, map.tiles = [];
                            for (var i = 0; i < map.tilesets.length; i++) for (var set = map.tilesets[i], x = set.tileMargin, y = set.tileMargin, count = 0, countX = 0, countY = 0, t = set.firstgid; t < set.firstgid + set.total && (map.tiles[t] = [ x, y, i ], 
                            x += set.tileWidth + set.tileSpacing, count++, count !== set.total) && (countX++, 
                            countX !== set.columns || (x = set.tileMargin, y += set.tileHeight + set.tileSpacing, 
                            countX = 0, countY++, countY !== set.rows)); t++) ;
                            var i, j, k, layer, tile, sid, set;
                            for (i = 0; i < map.layers.length; i++) for (layer = map.layers[i], j = 0; j < layer.data.length; j++) for (row = layer.data[j], 
                            k = 0; k < row.length; k++) tile = row[k], tile.index < 0 || (sid = map.tiles[tile.index][2], 
                            set = map.tilesets[sid], set.tileProperties && set.tileProperties[tile.index - set.firstgid] && (tile.properties = set.tileProperties[tile.index - set.firstgid]));
                            return map;
                        }
                    }, Phaser.Tileset = function(name, firstgid, width, height, margin, spacing, properties) {
                        ("undefined" == typeof width || 0 >= width) && (width = 32), ("undefined" == typeof height || 0 >= height) && (height = 32), 
                        "undefined" == typeof margin && (margin = 0), "undefined" == typeof spacing && (spacing = 0), 
                        this.name = name, this.firstgid = 0 | firstgid, this.tileWidth = 0 | width, this.tileHeight = 0 | height, 
                        this.tileMargin = 0 | margin, this.tileSpacing = 0 | spacing, this.properties = properties || {}, 
                        this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = [];
                    }, Phaser.Tileset.prototype = {
                        draw: function(context, x, y, index) {
                            var coordIndex = index - this.firstgid << 1;
                            coordIndex >= 0 && coordIndex + 1 < this.drawCoords.length && context.drawImage(this.image, this.drawCoords[coordIndex], this.drawCoords[coordIndex + 1], this.tileWidth, this.tileHeight, x, y, this.tileWidth, this.tileHeight);
                        },
                        containsTileIndex: function(tileIndex) {
                            return tileIndex >= this.firstgid && tileIndex < this.firstgid + this.total;
                        },
                        setImage: function(image) {
                            this.image = image, this.updateTileData(image.width, image.height);
                        },
                        setSpacing: function(margin, spacing) {
                            this.tileMargin = 0 | margin, this.tileSpacing = 0 | spacing, this.image && this.updateTileData(this.image.width, this.image.height);
                        },
                        updateTileData: function(imageWidth, imageHeight) {
                            var rowCount = (imageHeight - this.tileMargin) / (this.tileHeight + this.tileSpacing), colCount = (imageWidth - this.tileMargin) / (this.tileWidth + this.tileSpacing);
                            (rowCount % 1 !== 0 || colCount % 1 !== 0) && console.warn("Phaser.Tileset - image tile area is not an even multiple of tile size"), 
                            rowCount = Math.floor(rowCount), colCount = Math.floor(colCount), (this.rows && this.rows !== rowCount || this.columns && this.columns !== colCount) && console.warn("Phaser.Tileset - actual and expected number of tile rows and columns differ"), 
                            this.rows = rowCount, this.columns = colCount, this.total = rowCount * colCount, 
                            this.drawCoords.length = 0;
                            for (var tx = this.tileMargin, ty = this.tileMargin, y = 0; y < this.rows; y++) {
                                for (var x = 0; x < this.columns; x++) this.drawCoords.push(tx), this.drawCoords.push(ty), 
                                tx += this.tileWidth + this.tileSpacing;
                                tx = this.tileMargin, ty += this.tileHeight + this.tileSpacing;
                            }
                        }
                    }, Phaser.Tileset.prototype.constructor = Phaser.Tileset, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = Phaser), 
                    exports.Phaser = Phaser) : "undefined" != typeof define && define.amd ? define("Phaser", function() {
                        return root.Phaser = Phaser;
                    }()) : root.Phaser = Phaser;
                }.call(this), browserify_shim__define__module__export__("undefined" != typeof Phaser ? Phaser : window.Phaser);
            }.call(global, void 0, void 0, void 0, void 0, function(ex) {
                module.exports = ex;
            });
        }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
        _process: "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\node_modules\\grunt-browserify\\node_modules\\browserify\\node_modules\\process\\browser.js"
    } ],
    "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\lib\\stats.min.js": [ function(require, module, exports) {
        (function(global) {
            __browserify_shim_require__ = require, function(module, exports, require, define, browserify_shim__define__module__export__) {
                var Stats = function() {
                    var l = Date.now(), m = l, g = 0, n = 1 / 0, o = 0, h = 0, p = 1 / 0, q = 0, r = 0, s = 0, f = document.createElement("div");
                    f.id = "stats", f.addEventListener("mousedown", function(b) {
                        b.preventDefault(), t(++s % 2);
                    }, !1), f.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
                    var a = document.createElement("div");
                    a.id = "fps", a.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002", 
                    f.appendChild(a);
                    var i = document.createElement("div");
                    i.id = "fpsText", i.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
                    i.innerHTML = "FPS", a.appendChild(i);
                    var c = document.createElement("div");
                    for (c.id = "fpsGraph", c.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff", 
                    a.appendChild(c); 74 > c.children.length; ) {
                        var j = document.createElement("span");
                        j.style.cssText = "width:1px;height:30px;float:left;background-color:#113", c.appendChild(j);
                    }
                    var d = document.createElement("div");
                    d.id = "ms", d.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none", 
                    f.appendChild(d);
                    var k = document.createElement("div");
                    k.id = "msText", k.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
                    k.innerHTML = "MS", d.appendChild(k);
                    var e = document.createElement("div");
                    for (e.id = "msGraph", e.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0", 
                    d.appendChild(e); 74 > e.children.length; ) j = document.createElement("span"), 
                    j.style.cssText = "width:1px;height:30px;float:left;background-color:#131", e.appendChild(j);
                    var t = function(b) {
                        switch (s = b) {
                          case 0:
                            a.style.display = "block", d.style.display = "none";
                            break;

                          case 1:
                            a.style.display = "none", d.style.display = "block";
                        }
                    };
                    return {
                        REVISION: 11,
                        domElement: f,
                        setMode: t,
                        begin: function() {
                            l = Date.now();
                        },
                        end: function() {
                            var b = Date.now();
                            g = b - l, n = Math.min(n, g), o = Math.max(o, g), k.textContent = g + " MS (" + n + "-" + o + ")";
                            var a = Math.min(30, 30 - 30 * (g / 200));
                            return e.appendChild(e.firstChild).style.height = a + "px", r++, b > m + 1e3 && (h = Math.round(1e3 * r / (b - m)), 
                            p = Math.min(p, h), q = Math.max(q, h), i.textContent = h + " FPS (" + p + "-" + q + ")", 
                            a = Math.min(30, 30 - 30 * (h / 100)), c.appendChild(c.firstChild).style.height = a + "px", 
                            m = b, r = 0), b;
                        },
                        update: function() {
                            l = this.end();
                        }
                    };
                };
                browserify_shim__define__module__export__("undefined" != typeof Stats ? Stats : window.Stats);
            }.call(global, void 0, void 0, void 0, void 0, function(ex) {
                module.exports = ex;
            });
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {} ]
}, {}, [ "C:\\Users\\sgray\\workspace\\Website\\gamesrc\\src\\js\\game\\app.js" ]);
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.io=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

module.exports = _dereq_('./lib/');

},{"./lib/":2}],2:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var parser = _dereq_('socket.io-parser');
var Manager = _dereq_('./manager');
var debug = _dereq_('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var io;

  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = _dereq_('./manager');
exports.Socket = _dereq_('./socket');

},{"./manager":3,"./socket":5,"./url":6,"debug":10,"socket.io-parser":46}],3:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var eio = _dereq_('engine.io-client');
var Socket = _dereq_('./socket');
var Emitter = _dereq_('component-emitter');
var parser = _dereq_('socket.io-parser');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var object = _dereq_('object-component');
var debug = _dereq_('debug')('socket.io-client:manager');
var indexOf = _dereq_('indexof');
var Backoff = _dereq_('backo2');

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connected = [];
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    this.nsps[nsp].id = this.engine.id;
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connect', function(){
      socket.id = self.engine.id;
      if (!~indexOf(self.connected, socket)) {
        self.connected.push(socket);
      }
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connected, socket);
  if (~index) this.connected.splice(index, 1);
  if (this.connected.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.backoff.reset();
  this.readyState = 'closed';
  this.engine && this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('close');
  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);
  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":4,"./socket":5,"./url":6,"backo2":7,"component-bind":8,"component-emitter":9,"debug":10,"engine.io-client":11,"indexof":42,"object-component":43,"socket.io-parser":46}],4:[function(_dereq_,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],5:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var parser = _dereq_('socket.io-parser');
var Emitter = _dereq_('component-emitter');
var toArray = _dereq_('to-array');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var debug = _dereq_('debug')('socket.io-client:socket');
var hasBin = _dereq_('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  if (this.io.autoConnect) this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug('calling ack %s with %j', packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

},{"./on":4,"component-bind":8,"component-emitter":9,"debug":10,"has-binary":38,"socket.io-parser":46,"to-array":50}],6:[function(_dereq_,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = _dereq_('parseuri');
var debug = _dereq_('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  // define unique id
  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"debug":10,"parseuri":44}],7:[function(_dereq_,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],8:[function(_dereq_,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],9:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],10:[function(_dereq_,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + ' '
      + fmt
      + ' +' + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn't have 'apply'
    window.console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || '').split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i < len; i++) {
    name = split[i].replace('*', '.*?');
    if (name[0] === '-') {
      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
    }
    else {
      debug.names.push(new RegExp('^' + name + '$'));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable('');
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
  if (ms >= min) return (ms / min).toFixed(1) + 'm';
  if (ms >= sec) return (ms / sec | 0) + 's';
  return ms + 'ms';
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i < len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i < len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],11:[function(_dereq_,module,exports){

module.exports =  _dereq_('./lib/');

},{"./lib/":12}],12:[function(_dereq_,module,exports){

module.exports = _dereq_('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = _dereq_('engine.io-parser');

},{"./socket":13,"engine.io-parser":25}],13:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = _dereq_('./transports');
var Emitter = _dereq_('component-emitter');
var debug = _dereq_('debug')('engine.io-client:socket');
var index = _dereq_('indexof');
var parser = _dereq_('engine.io-parser');
var parseuri = _dereq_('parseuri');
var parsejson = _dereq_('parsejson');
var parseqs = _dereq_('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(':');
    opts.hostname = pieces.shift();
    if (pieces.length) {
      opts.port = pieces.pop();
    } else if (!opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = this.secure ? '443' : '80';
    }
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized || null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = _dereq_('./transport');
Socket.transports = _dereq_('./transports');
Socket.parser = _dereq_('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 == this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  var transport;
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.emit('error', err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket('ping');
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i < this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket('message', msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  var packet = { type: type, data: data };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    function close() {
      self.onClose('forced close');
      debug('socket closing - telling transport to close');
      self.transport.close();
    }

    function cleanupAndClose() {
      self.removeListener('upgrade', cleanupAndClose);
      self.removeListener('upgradeError', cleanupAndClose);
      close();
    }

    function waitForUpgrade() {
      // wait for upgrade to finish since we can't send packets while pausing a transport
      self.once('upgrade', cleanupAndClose);
      self.once('upgradeError', cleanupAndClose);
    }

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./transport":14,"./transports":15,"component-emitter":9,"debug":22,"engine.io-parser":25,"indexof":42,"parsejson":34,"parseqs":35,"parseuri":36}],14:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var parser = _dereq_('engine.io-parser');
var Emitter = _dereq_('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":9,"engine.io-parser":25}],15:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = _dereq_('xmlhttprequest');
var XHR = _dereq_('./polling-xhr');
var JSONP = _dereq_('./polling-jsonp');
var websocket = _dereq_('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling-jsonp":16,"./polling-xhr":17,"./websocket":19,"xmlhttprequest":20}],16:[function(_dereq_,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = _dereq_('./polling');
var inherit = _dereq_('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":18,"component-inherit":21}],17:[function(_dereq_,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = _dereq_('xmlhttprequest');
var Polling = _dereq_('./polling');
var Emitter = _dereq_('component-emitter');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        data = 'ok';
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":18,"component-emitter":9,"component-inherit":21,"debug":22,"xmlhttprequest":20}],18:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parseqs = _dereq_('parseqs');
var parser = _dereq_('engine.io-parser');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = _dereq_('xmlhttprequest');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

},{"../transport":14,"component-inherit":21,"debug":22,"engine.io-parser":25,"parseqs":35,"xmlhttprequest":20}],19:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parser = _dereq_('engine.io-parser');
var parseqs = _dereq_('parseqs');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:websocket');

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = _dereq_('ws');

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = 'arraybuffer';
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i < l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn't
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug('websocket closed before onclose event');
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit('drain');
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

},{"../transport":14,"component-inherit":21,"debug":22,"engine.io-parser":25,"parseqs":35,"ws":37}],20:[function(_dereq_,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = _dereq_('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":40}],21:[function(_dereq_,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],22:[function(_dereq_,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = _dereq_('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // This hackery is required for IE8,
  // where the `console.log` function doesn't have 'apply'
  return 'object' == typeof console
    && 'function' == typeof console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      localStorage.removeItem('debug');
    } else {
      localStorage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = localStorage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{"./debug":23}],23:[function(_dereq_,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = _dereq_('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":24}],24:[function(_dereq_,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],25:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = _dereq_('./keys');
var hasBinary = _dereq_('has-binary');
var sliceBuffer = _dereq_('arraybuffer.slice');
var base64encoder = _dereq_('base64-arraybuffer');
var after = _dereq_('after');
var utf8 = _dereq_('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = _dereq_('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./keys":26,"after":27,"arraybuffer.slice":28,"base64-arraybuffer":29,"blob":30,"has-binary":31,"utf8":33}],26:[function(_dereq_,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],27:[function(_dereq_,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],28:[function(_dereq_,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],29:[function(_dereq_,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],30:[function(_dereq_,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var b = new Blob(['hi']);
    return b.size == 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }
  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

module.exports = (function() {
  if (blobSupported) {
    return global.Blob;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],31:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (obj.hasOwnProperty(key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"isarray":32}],32:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],33:[function(_dereq_,module,exports){
(function (global){
/*! http://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from http://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from http://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);

		// console.log(JSON.stringify(codePoints.map(function(x) {
		// 	return 'U+' + x.toString(16).toUpperCase();
		// })));

		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],34:[function(_dereq_,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],35:[function(_dereq_,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],36:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],37:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],38:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"isarray":39}],39:[function(_dereq_,module,exports){
module.exports=_dereq_(32)
},{}],40:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = _dereq_('global');

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = 'XMLHttpRequest' in global &&
    'withCredentials' in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{"global":41}],41:[function(_dereq_,module,exports){

/**
 * Returns `this`. Execute this without a "context" (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * "global" scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],42:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],43:[function(_dereq_,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],44:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
  var m = re.exec(str || '')
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  return uri;
};

},{}],45:[function(_dereq_,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = _dereq_('isarray');
var isBuf = _dereq_('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is-buffer":47,"isarray":48}],46:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var debug = _dereq_('debug')('socket.io-parser');
var json = _dereq_('json3');
var isArray = _dereq_('isarray');
var Emitter = _dereq_('component-emitter');
var binary = _dereq_('./binary');
var isBuf = _dereq_('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'BINARY_EVENT',
  'ACK',
  'BINARY_ACK',
  'ERROR'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":45,"./is-buffer":47,"component-emitter":9,"debug":10,"isarray":48,"json3":49}],47:[function(_dereq_,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],48:[function(_dereq_,module,exports){
module.exports=_dereq_(32)
},{}],49:[function(_dereq_,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == "object" && JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;

  if (JSON3 && nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera >= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
      // Safari < 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == "bug-string-char-index") {
      // IE <= 7 doesn't support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = "a"[0] != "a";
    } else if (name == "json") {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has("json-stringify") && has("json-parse");
    } else {
      var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
      // Test `JSON.stringify`.
      if (name == "json-stringify") {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === "0" &&
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === "0" &&
              stringify(new String()) == '""' &&
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &&
              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &&
              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &&
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === "1" &&
              stringify([value]) == "[1]" &&
              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
              // `"[null]"`.
              stringify([undef]) == "[null]" &&
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == "null" &&
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == "[null,null,null]" &&
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` => `\u0008`).
              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === "1" &&
              stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == "json-parse") {
        var parse = JSON3.parse;
        if (typeof parse == "function") {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse("0") === 0 && !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
              if (parseSupported) {
                try {
                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse('"\t"');
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse("01") !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse("1.") !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has("json")) {
    // Common `[[Class]]` name aliases.
    var functionClass = "[object Function]";
    var dateClass = "[object Date]";
    var numberClass = "[object Number]";
    var stringClass = "[object String]";
    var arrayClass = "[object Array]";
    var booleanClass = "[object Boolean]";

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has("bug-string-char-index");

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          "toString": 1
        }, members).toString != getClass) {
          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object's prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this && !(property in parent && this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      'boolean': 1,
      'number': 1,
      'string': 1,
      'undefined': 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment's `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko <= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
        };
      } else if (size == 2) {
        // Safari <= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = "constructor"))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has("json-stringify")) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: "\\\\",
        34: '\\"',
        8: "\\b",
        12: "\\f",
        10: "\\n",
        13: "\\r",
        9: "\\t"
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be <= 6.
      var leadingZeroes = "000000";
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = "\\u00";
      var quote = function (value) {
        var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split("");
        }
        for (; index < length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode < 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + '"';
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == "object" && value) {
          className = getClass.call(value);
          if (className == dateClass && !isProperty.call(value, "toJSON")) {
            if (value > -1 / 0 && value < 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle's `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                "." + toPaddedString(3, milliseconds) + "Z";
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return "null";
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return "" + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `"null"`.
          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote("" + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == "object") {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index < length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? "null" : element);
            }
            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + ":"}
                // be the concatenation of `member` and the `space` character."
                // The "`space` character" refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
              }
            });
            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == "function" || typeof filter == "object" && filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) > 0) {
              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
            }
          } else if (className == stringClass) {
            whitespace = width.length <= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera <= 7.54u2 discards the values associated with empty string keys
        // (`""`) only if they are used directly within an object member list
        // (e.g., `!("" in { "": 1})`).
        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has("json-parse")) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: "\\",
        34: '"',
        47: "/",
        98: "\b",
        116: "\t",
        110: "\n",
        102: "\f",
        114: "\r"
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `"$"` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index < length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `"` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = "@", Index++; Index < length;) {
                charCode = source.charCodeAt(Index);
                if (charCode < 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `"`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index < position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode("0x" + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode >= 32 && charCode != 92 && charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode >= 48 && charCode <= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == "true") {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == "false") {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == "null") {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return "$";
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == "$") {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == "string") {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == "[") {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == "]") {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "]") {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == ",") {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == "{") {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == "}") {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "}") {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == "object" && value) {
          // `forEach` can't be used to traverse an array in Opera <= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = "" + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != "$") {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],50:[function(_dereq_,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}]},{},[1])
(1)
});

var socket = io('http://localhost:3700');

socket.on('connect', function(){
     console.log('socket connected');
});

socket.on('news', function (data) {
    //console.log("Player connected: "+data);
    socket.emit('my other event', {
        my: 'data'
    });
});